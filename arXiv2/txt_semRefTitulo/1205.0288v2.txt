
We consider the problem of simultaneously learning to linearly combine a very large
number of kernels and learn a good predictor based on the learnt kernel. When the
number of kernels d to be combined is very large, multiple kernel learning methods whose
computational cost scales linearly in d are intractable. We propose a randomized version
of the mirror descent algorithm to overcome this issue, under the objective of minimizing
the group p-norm penalized empirical risk. The key to achieve the required exponential
speed-up is the computationally efficient construction of low-variance estimates of the
gradient. We propose importance sampling based estimates, and find that the ideal
distribution samples a coordinate with a probability proportional to the magnitude of
the corresponding gradient. We show the surprising result that in the case of learning
the coefficients of a polynomial kernel, the combinatorial structure of the base kernels
to be combined allows the implementation of sampling from this distribution to run
in O(log(d)) time, making the total computational cost of the method to achieve an optimal solution to be O(log(d)/2 ), thereby allowing our method to operate for very large
values of d. Experiments with simulated and real data confirm that the new algorithm is
computationally more efficient than its state-of-the-art alternatives.

1

Introduction

We look into the computational challenge of finding a good predictor in a multiple kernel
learning (MKL) setting where the number of kernels is very large. In particular, we are
interested in cases where the base kernels come from a space with combinatorial structure
and thus their number d could be exponentially large. Just like some previous works (e.g.
Rakotomamonjy et al., 2008; Xu et al., 2008; Nath et al., 2009) we start with the approach
that views the MKL problem as a nested, large scale convex optimization problem, where
the first layer optimizes the weights of the kernels to be combined. More specifically, as the
1

objective we minimize the group p-norm penalized empirical risk. However, as opposed to
these works whose underlying iterative methods have a complexity of ‚Ñ¶(d) for just any one
iteration, following (Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; RichtaÃÅrik and
TakaÃÅcÃÇ, 2011) we use a randomized coordinate descent method, which was effectively used in
these works to decrease the per iteration complexity to O(1). The role of randomization in our
method is to use it to build an unbiased estimate of the gradient at the most recent iteration.
The issue then is how the variance (and so the number of iterations required) scales with d.
As opposed to the above mentioned works, in this paper we propose to make the distribution
over the updated coordinate dependent on the history. We will argue that sampling from a
distribution that is proportional to the magnitude of the gradient vector is desirable to keep
the variance (actually, second moment) low and in fact we will show that there are interesting
cases of MKL (in particular, the case of combining kernels coming from a polynomial family
of kernels) when efficient sampling (i.e., sampling at a cost of O(log d)) is feasible from this
distribution. Then, the variance is controlled by the a priori weights put on the kernels,
making it potentially independent of d. Under these favorable conditions (and in particular,
for the polynomial kernel set with some specific prior weights), the complexity of the method
as a function of d becomes logarithmic, which makes our MKL algorithm feasible even for
large scale problems. This is to be contrasted to the approach of Nesterov (2010, 2012) where
a fixed distribution is used and where the a priori bounds on the method‚Äôs convergence rate,
and, hence, its computational cost to achieve a prescribed precision, will depend linearly on d
(note that we are comparing upper bounds here, so the actual complexity could be smaller).
Our algorithm is based on the mirror descent (or mirror descent) algorithm (similar to the
work of RichtaÃÅrik and TakaÃÅcÃÇ (2011) who uses uniform distributions).
It is important to mention that there are algorithms designed to handle the case of
infinitely many kernels, for example, the algorithms by Argyriou et al. (2005, 2006); Gehler
and Nowozin (2008). However, these methods lack convergence rate guarantees, and, for
example, the consistency for the method of Gehler and Nowozin (2008) works only for ‚Äúsmall‚Äù
d. The algorithm of Bach (2008), though practically very efficient, suffers from the same
deficiency. A very interesting proposal by Cortes et al. (2009) considers learning to combine
a large number of kernels and comes with guarantees, though their algorithm restricts the
family of kernels in a specific way.
The rest of the paper is organized as follows. The problem is defined formally in Section 2.
Our new algorithm is presented and analyzed in Section 3, while its specialized version
for learning polynomial kernels is given in Section 4. Finally, experiments are provided in
Section 5.

2

Preliminaries

In this section we give the formal definition of our problem. Let I denote a finite index set,
indexing the predictors (features)
the set of predictors considered
 to be combined, and define
P
over the input space X as F = fw : X ‚Üí R : fw (x) = i‚ààI hwi , œÜi (x)i , x ‚àà X . Here Wi
is a Hilbert space over the reals, œÜi : X ‚Üí Wi is a feature-map, hx, yi is the inner product
.
over the Hilbert space that x, y belong to and w = (wi )i‚ààI ‚àà W = √ói‚ààI Wi (as an example,
Wi may just be a finite dimensional Euclidean space). The problem we consider is to solve

2

the optimization problem
minimize Ln (fw ) + Pen(fw )

subject to w ‚àà W ,
and Ln (fw ) = n1
convex losses `t

(1)
Pn

where Pen(fw ) is a penalty that will be specified later,
t=1 `t (fw (xt ))is the
empirical risk of predictor fw , defined in terms of the
: R ‚Üí R (1 ‚â§ t ‚â§ n)
and inputs xt ‚àà X (1 ‚â§ t ‚â§ n). The solution w‚àó of the above penalized empirical risk
minimization problem is known to have favorable generalization properties under various
conditions, see, e.g., Hastie et al. (2009). In supervised learning problems `t (y) = `(yt , y)
for some loss function ` : R √ó R ‚Üí R, such as the squared-loss, `(yt , y) = 21 (y ‚àí yt )2 , or the
hinge-loss, `t (yt , y) = max(1 ‚àí yyt , 0), where in the former case yt ‚àà R, while in the latter
case yt ‚àà {‚àí1, +1}. We note in passing that for the sake of simplicity, we shall sometimes
abuse notation and write Ln (w) for Ln (fw ) and even drop the index n when the sample-size
is unimportant.
As mentioned above, in this paper we consider the special case in (1) when the penalty
is a so-called group p-norm penalty with 1 ‚â§ p ‚â§ 2, a case considered earlier, e.g., by Kloft
et al. (2011). Thus our goal is to solve
!2
p
1 X p
p
minimize Ln (w) +
œÅi kwi k2
,
(2)
w‚ààW
2
i‚ààI

where the scaling factors œÅi > 0, i ‚àà I, are assumed to be given. We introduce the notation
u = (ui ) ‚àà RI to denote the column vector obtained from the values ui .
The rationale of using the squared weighted p-norm is that for 1 ‚â§ p < 2 it is expected to
encourage sparsity at the group level which should allow one to handle cases when I is very
large (and the case p = 2 comes for free from the same analysis). The actual form, however,
is also chosen for reasons of computational convenience. In fact, the reason to use the 2-norm
of the weights is to allow the algorithm to work even with infinite-dimensional feature vectors
(and thus weights) by resorting to the kernel trick. To see how this works, just notice that
the penalty in (2) can also be written as
!2
(
)
p
2 kw k2
X p
X
œÅ
i
2
i
œÅi kwi kp2
= inf
: Œ∏‚àà‚àÜ p
,
2‚àíp
Œ∏i
i‚ààI

i‚ààI

where for ŒΩ ‚â• 1, ‚àÜŒΩ = {Œ∏ ‚àà [0, 1]|I| : kŒ∏kŒΩ ‚â§ 1} is the positive quadrant of the |I|-dimensional
`ŒΩ -ball (see, e.g., Micchelli and Pontil, 2005, Lemma 26). Hence, defining
1 X œÅ2i kwi k22
J(w, Œ∏) = L(w) +
2
Œ∏i
i‚ààI

for any w ‚àà W, Œ∏ ‚àà [0, 1]|I| , an equivalent form of (2) is
minimize J(w, Œ∏)

w‚ààW,Œ∏‚àà‚àÜŒΩ

(3)

where ŒΩ = p/(2 ‚àí p) ‚àà [1, ‚àû) and we define 0/0 = 0 and u/0 = ‚àû for u > 0, which implies
that wi = 0 if Œ∏i = 0. That this minimization problem is indeed equivalent to our original
task (2) for the chosen value of ŒΩ follows from the fact that J(w, Œ∏) is jointly convex in (w, Œ∏).1
1

Here and in what follows by equivalence we mean that the set of optimums in terms of w (the primary
optimization variable) is the same in the two problems.

3

Let Œ∫i : X √ó X ‚Üí R be the reproducing kernel underlying œÜi : Œ∫i (x, x0 ) = hœÜi (x), œÜi (x0 )i
(x, x0 ‚àà X ) and let Hi = HŒ∫i the corresponding reproducing kernel Hilbert space (RKHS).
Then, for any given fixed value of Œ∏, the above problem becomes an instance
P of a standard
penalized learning problem in the RKHS HŒ∏ underlying the kernel Œ∫Œ∏ = i‚ààI Œ∏i œÅ‚àí2
i Œ∫i . In
particular, by the theorem on page 353 in Aronszajn (1950), the problem of finding w ‚àà W
for fixed Œ∏ can be seen to be equivalent to minimizef ‚ààHŒ∏ L(f ) + 21 kf k2HŒ∏ , and thus (2) is
seen to be equivalent to minimizef ‚ààHŒ∏ ,Œ∏‚àà‚àÜŒΩ L(f ) + 21 kf k2HŒ∏ . Thus, we see that the method
can be thought of as finding the weights of a kernel Œ∫Œ∏ and a predictor minimizing the HŒ∏ norm penalized empirical risk. This shows that our problem is an instance of multiple kernel
learning (for an exhaustive survey of MKL, see, e.g., GoÃànen and Alpaydƒ±n, 2011 and the
references therein).

3

The new approach

When I is small, or moderate in size, the joint-convexity of J allows one to use off-the-shelf
solvers to find the joint minimum of J. However, when I is large, off-the-shelf solvers might
be slow or they may run out of memory. Targeting this situation we propose the following
approach: Exploiting again that J(w, Œ∏) is jointly convex in (w, Œ∏), find the optimal weights
by finding the minimizer of
.
J(Œ∏) = inf J(w, Œ∏),
w

.
or, alternatively, J(Œ∏) = J(w‚àó (Œ∏), Œ∏), where w‚àó (Œ∏) = arg minw J(w, Œ∏) (here we have slightly
abused notation by reusing the symbol J). Note that J(Œ∏) is convex by the joint convexity of
J(w, Œ∏). Also, note that w‚àó (Œ∏) exists and is well-defined as the minimizer of J(¬∑, Œ∏) is unique
for any Œ∏ ‚àà ‚àÜŒΩ (see also Proposition 3.2 below). Again, exploiting the joint convexity of
J(w, Œ∏), we find that if Œ∏‚àó is the minimizer of J(Œ∏), then w‚àó (Œ∏‚àó ) will be an optimal solution
to the original problem (2). To optimize J(Œ∏) we propose to use stochastic gradient descent
with artificially injected randomness to avoid the need to fully evaluate the gradient of J.
More precisely, our proposed algorithm is an instance of a randomized version of the mirror
descent algorithm (Rockafellar, 1976; Martinet, 1978; Nemirovski and Yudin, 1998), where in
each time step only one coordinate of the gradient is sampled.

3.1

A randomized mirror descent algorithm

Before giving the algorithm, we need a few definitions. Let d = |I|, A ‚äÇ Rd be nonempty
with a convex interior A‚ó¶ . We call the function Œ® : A ‚Üí R a Legendre (or barrier) potential
if it is strictly convex, its partial derivatives exist and are continuous, and for every sequence
{xk } ‚äÇ A approaching the boundary of A, limk‚Üí‚àû k‚àáŒ®(xk )k = ‚àû. Here ‚àá is the gradient
‚àÇ
operator: ‚àáŒ®(x) = ( ‚àÇx
Œ®(x))> is the gradient of Œ®. When ‚àá is applied to a non-smooth
0
convex function J (Œ∏) (J may be such without additional assumptions) then ‚àáJ 0 (Œ∏) is defined
as any subgradient of J 0 at Œ∏. The corresponding Bregman-divergence DŒ® : A √ó A‚ó¶ ‚Üí R
is defined as DŒ® (Œ∏, Œ∏0 ) = Œ®(Œ∏) ‚àí Œ®(Œ∏0 ) ‚àí h‚àáŒ®(Œ∏0 ), Œ∏ ‚àí Œ∏0 i. The Bregman projection Œ†Œ®,K :
A‚ó¶ ‚Üí K corresponding to the Legendre potential Œ® and a closed convex set K ‚äÇ Rd such
that K ‚à© A 6= ‚àÖ is defined, for all Œ∏ ‚àà A‚ó¶ as Œ†Œ®,K (Œ∏) = arg minŒ∏0 ‚ààK‚à©A Dœà (Œ∏0 , Œ∏).
Algorithm 1 shows a randomized version of the standard mirror descent method with an
unbiased gradient estimate. By assumption, Œ∑k > 0 is deterministic. Note that step 1 of the
4

Algorithm 1 Randomized mirror descent algorithm
1: Input: A, K ‚äÇ Rd , where K is closed and convex with K ‚à© A 6= ‚àÖ, Œ® : A ‚Üí R Legendre,
step sizes {Œ∑k }, a subroutine, GradSampler, to sample the gradient of J at an arbitrary
vector Œ∏ ‚â• 0
2: Initialization: Œ∏ (0) = arg minŒ∏‚ààK‚à©A Œ®(Œ∏), k = 0.
3: repeat
4:
k = k + 1.
(k‚àí1) )
5:
Obtain gÃÇk = GradSampler(Œ∏

(k)
6:
Œ∏ÃÉ = arg minŒ∏‚ààA Œ∑k‚àí1 hgÃÇk , Œ∏i + DŒ® (Œ∏, Œ∏(k‚àí1) ) .
7:
Œ∏(k) = Œ†Œ®,K (Œ∏ÃÉ(k) ).
8: until convergence.
algorithm is well-defined since Œ∏ÃÉ(k) ‚àà A‚ó¶ by the assumption that k‚àáŒ®(x)k tends to infinity
as x approaches the boundary of A. The performance of Algorithm 1 is bounded in the next
theorem. The analysis follows the standard proof technique of analyzing the mirror descent
algorithm (see, e.g., Beck and Teboulle, 2003), however, in a slightly more general form than
what we have found in the literature. In particular, compared to (Nemirovski et al., 2009a;
Nesterov, 2010, 2012; Shalev-Shwartz and Tewari, 2011; RichtaÃÅrik and TakaÃÅcÃÇ, 2011), our
analysis allows for the conditional distribution of the noise in the gradient estimate to be
history dependent. The proof is included in Section A in the appendix.
Theorem 3.1. Assume that Œ® is Œ±-strongly convex with respect to some norm k ¬∑ k (with
dual norm k ¬∑ k‚àó ) for some Œ± > 0, that is, for any Œ∏ ‚àà A‚ó¶ , Œ∏0 ‚àà A
Œ®(Œ∏0 ) ‚àí Œ®(Œ∏) ‚â• ‚àáŒ®(Œ∏), Œ∏0 ‚àí Œ∏ + Œ±2 kŒ∏0 ‚àí Œ∏k2 .

(4)

Suppose, furthermore, that Algorithm 1 is run for T time steps. For 0 ‚â§ k ‚â§ T ‚àí 1 let Fk
denote the œÉ-algebra generated by Œ∏1 , . . . , Œ∏k . Assume that, for all 1 ‚â§ k ‚â§ T , gÃÇk ‚àà Rd is an
unbiased estimate of ‚àáJ(Œ∏(k‚àí1) ) given Fk‚àí1 , that is,
E [ gÃÇk | Fk‚àí1 ] = ‚àáJ(Œ∏(k‚àí1) ).

(5)

Further, assume that there exists a deterministic constant B ‚â• 0 such that for all 1 ‚â§ k ‚â§ T ,


E kgÃÇk k2‚àó Fk‚àí1 ‚â§ B a.s.
(6)
Finally, assume that Œ¥ = supŒ∏0 ‚ààK‚à©A Œ®(Œ∏0 ) ‚àí Œ®(Œ∏(0) ) is finite. Then, if Œ∑k‚àí1 =
k ‚â• 1, it holds that
!#
"
r
T
1 X (k‚àí1)
2BŒ¥
E J
Œ∏
‚àí inf J(Œ∏) ‚â§
.
Œ∏‚ààK‚à©A
T
Œ±T

q

2Œ±Œ¥
BT

for all

(7)

k=1

Furthermore, if
kgÃÇk k2‚àó ‚â§ B 0

5

a.s.

(8)

B0

for some deterministic constant
and Œ∑k‚àí1 =
it holds with probability at least 1 ‚àí  that
J

T
1 X (k‚àí1)
Œ∏
T

q

2Œ±Œ¥
B0T

!

r
‚àí inf J(Œ∏) ‚â§

k=1

for all k ‚â• 1 then, for any 0 <  < 1,

2B 0 Œ¥
Œ±T

Œ∏‚ààK‚à©A

s
+4

B 0 Œ¥ log 1
.
Œ±T

(9)

The convergence rate in the above theorem can be improved if stronger assumptions are
made on J, for example if J is assumed to be strongly convex, see, for example, (Hazan et al.,
2007; Hazan and Kale, 2011).
Efficient implementation of Algorithm 1 depends on efficient implementations of steps
1-1, namely, computing an estimate of the gradient, solving the minimization for Œ∏ÃÉ(k) , and
projecting it into K. The first problem is related to the choice of gradient estimate we use,
which, in turn, depends on the structure of the feature space, while the last two problems
depend on the choice of the Legendre function. In the next subsections we examine how these
choices can be made to get a practical variant of the algorithm.

3.2

Application to multiple kernel learning

It remains to define the gradient estimates gÃÇk in Algorithm 1. We start by considering
importance sampling based estimates. First, however, let us first verify whether the gradient
exist. Along the way, we will also derive some explicit expressions which will help us later.
Closed-form expressions for the gradient. Let us first consider how w‚àó (Œ∏) can be
calculated for a fixed value of Œ∏. As it will turn out, this calculation will be useful not
only when the procedure is stopped (to construct the predictor fw‚àó (Œ∏) but also during the
iterations when we will need to calculate the derivative of J with respect to Œ∏i . The following
proposition summarizes how w‚àó (Œ∏) can be obtained. Note that this type of result is standard
(see, e.g., Shawe-Taylor and Cristianini, 2004; SchoÃàlkopf and Smola, 2002), thus we include
it only for the sake of completeness (the proof is included in Section A in the appendix).
Proposition 3.2. For 1 ‚â§ t ‚â§ n, let `‚àót : R ‚Üí R denote the convex conjugate of `t : `‚àót (v) =
0 )i, and let K =
supœÑ ‚ààR {vœÑ ‚àí `t (œÑ )}, v ‚àà R. For i ‚àà I, recall that Œ∫i (x, x0 ) = hœÜi (x), œÜi (xP
i
(Œ∫i (xt , xs ))1‚â§t,s‚â§n be the n √ó n kernel matrix underlying Œ∫i and let KŒ∏ = i‚ààI œÅŒ∏2i Ki be the
i
P
Œ∏i
kernel matrix underlying Œ∫Œ∏ =
Œ∫
.
Then,
for
any
fixed
Œ∏,
the
minimizer
w‚àó (Œ∏) of
i
2
i‚ààI œÅi
J(¬∑, Œ∏) satisfies
n
Œ∏i X ‚àó
wi‚àó (Œ∏) = 2
Œ± (Œ∏)œÜi (xt ), i ‚àà I ,
(10)
œÅi t=1 t
where

(
Œ±‚àó (Œ∏) = arg min
Œ±‚ààRn

n

1 >
1X ‚àó
Œ± KŒ∏ Œ± +
`t (‚àínŒ±t )
2
n

)
.

(11)

t=1

Based on this proposition, we can compute the
Ppredictor fw‚àó (Œ∏) usingPthe kernels {Œ∫i }i‚ààI
and the dual variables (Œ±t‚àó (Œ∏))1‚â§t‚â§n : fw‚àó (Œ∏) (x) = i‚ààI hwi‚àó (Œ∏), œÜi (x)i = nt=1 Œ±t‚àó (Œ∏)Œ∫Œ∏ (xt , x) .

6

Let us now consider the differentiability of J = J(Œ∏) and how to compute its derivatives.
Under proper conditions with standard calculations (e.g., Rakotomamonjy et al., 2008) we
find that J is differentiable over ‚àÜ and its derivative can be written as2

 ‚àó >
‚àÇ
Œ± (Œ∏) Ki Œ±‚àó (Œ∏)
J(Œ∏) = ‚àí
.
(12)
‚àÇŒ∏
œÅ2i
i‚ààI
Importance sampling based estimates. Let d = |I| and let ei , i ‚àà I denote the ith unit
vector of the standard basis of Rd , that is, the ith coordinate of ei is 1 while the others are
0. Introduce
D
E
gk,i = ‚àáJ(Œ∏(k‚àí1) ), ei , i ‚àà I
(13)
to denote the ith component of the gradient of J in iteration k (that is, gk,i can be computed
based on (12)). Let sk‚àí1 ‚àà [0, 1]I be a distribution over I, computed in some way based on
the information available up to the end of iteration k ‚àí 1 of the algorithm (formally, sk‚àí1 is
Fk‚àí1 -measurable). Define the importance sampling based gradient estimate to be
gÃÇk,i =

I{Ik =i}
gk,Ik ,
sk‚àí1,Ik

i ‚àà I, where Ik ‚àº sk‚àí1,¬∑ .

(14)

That is, the gradient estimate is obtained by first sampling an index from sk‚àí1,¬∑ and then
setting the gradient estimate to be zero at all indices i ‚àà I except when i = Ik in which
gk,I
case its value is set to be the ratio sk‚àí1,Ik . It is easy to see that as long as sk‚àí1,i > 0 holds
k

whenever gk,i 6= 0, then it holds that E [ gÃÇk | Fk‚àí1 ] = ‚àáJ(Œ∏(k‚àí1) ) a.s.
Let us now derive the conditions under which the second moment of the gradient estimate
stays bounded. Define Ck‚àí1 = ‚àáJ(Œ∏(k‚àí1) ) 1 . Given the expression for the gradient of J
shown in (12), we see that supk‚â•1 Ck‚àí1 < ‚àû will always hold provided that Œ±‚àó (Œ∏) is continuous
since (Œ∏(k‚àí1) )k‚â•1 is guaranteed to belong to a compact set (the continuity of Œ±‚àó is discussed
in Section B in the appendix).
1
Define the probability distribution qk‚àí1,¬∑ as follows: qk‚àí1,i = Ck‚àí1
|gk,i | , i ‚àà I. Then
2
qk‚àí1,I

2
2
keIk k2‚àó = s2 k Ck‚àí1
keIk k2‚àó . Therefore, it also holds
it holds that kgÃÇk k2‚àó = s2 1 gk,I
k
k‚àí1,Ik
k‚àí1,Ik
2


P
qk‚àí1,i
qk‚àí1,i
2
2
2
2
that E kgÃÇk k2‚àó Fk‚àí1 = Ck‚àí1
i‚ààI sk‚àí1,i kei k‚àó ‚â§ Ck‚àí1 maxi‚ààI sk‚àí1,i kei k‚àó . This shows that


q
supk‚â•1 E kgÃÇk k2‚àó Fk‚àí1 < ‚àû will hold as long as supk‚â•1 maxi‚ààI sk‚àí1,i
< ‚àû and supk‚â•1 Ck‚àí1 <
k‚àí1,i
‚àû. Note that when sk‚àí1 = qk‚àí1 , the gradient estimate becomes gÃÇk,i = Ck‚àí1 I{It =i} . That is,
in this case we see that in order to be able to calculate gÃÇk,i , we need to be able to calculate
Ck‚àí1 efficiently.

Choosing the potential Œ®. The efficient sampling of the gradient is not the only practical
issue, since the choice of the Legendre function
and the convex set K may also cause some
P
complications. For example, if Œ®(x) =
i‚ààI xi (ln xi ‚àí 1), then the resulting algorithm
is exponential weighting, and one needs to store and update |I| weights, which is clearly
infeasible if |I| is very large (or infinite). On the other hand, if Œ®(x) = 12 kxk22 and we project
2

For completeness, the calculations are given in Section B in the appendix.

7

Algorithm 2 Projected stochastic gradient algorithm.
1:
2:
3:
4:
5:
6:

(0)

Initialization: Œ®(x) = 21 kxk22 , Œ∏i = 0 for all i ‚àà I, k = 0, step sizes {Œ∑k }.
repeat
k = k + 1.
Sample a gradient estimate gÃÇk of g(Œ∏(k‚àí1 ) randomly according to (14).
Œ∏(k) = Œ†Œ®,‚àÜ2 (Œ∏(k‚àí1) ‚àí Œ∑k‚àí1 gÃÇk ).
until convergence.

to K = ‚àÜ2 , the positive quadrant of the `2 -ball (with A = [0, ‚àû)I ), we obtain a stochastic
projected gradient method, shown in Algorithm 2. This is in fact the algorithm that we
use in the experiments. Note that in (2) this corresponds to using p = 4/3. The reason we
made this choice is because in this case projection is a simple scaling operation. Had we
chosen K = ‚àÜ1 , the `2 -projection would very often cancel many of the nonzero components,
resulting in an overall slow progress. Based on the above calculations and Theorem 3.1 we
obtain the following performance bound for our algorithm.
Corollary 3.3. Assume that Œ±‚àó (Œ∏) is continuous on ‚àÜ2 . Then there exists a C > 0 such
q
‚àÇ
that k ‚àÇŒ∏
J(Œ∏)k1 ‚â§ C for all Œ∏ ‚àà ‚àÜ2 . Let B = 21 C 2 maxi‚ààI,1‚â§k‚â§T sk‚àí1,i
. If Algorithm 2 is run
k‚àí1,i
‚àö
for T steps with Œ∑k‚àí1 = Œ∑ = 1/ BT , k = 1, . . . , T , then, for all Œ∏ ‚àà ‚àÜ2 ,
!#
"
r
T
1 X (k‚àí1)
B
‚àí J(Œ∏) ‚â§
Œ∏
.
E J
T
T
k=1

Note that to implement Algorithm 2 efficiently, one has to be able to sample from sk‚àí1,¬∑
and compute the importance sampling ratio gk,i /sk,i efficiently for any k and i.

4

Example: Learning polynomial kernels

In this section we show how our method can be applied in the context of multiple kernel learning. We provide an example when the kernels in I are tensor products of a set of base kernels
(this we shall call learning polynomial kernels). The importance of this example follows from
the observation of GoÃànen and Alpaydƒ±n (2011) that the non-linear kernel learning methods of
Cortes et al. (2009), which can be viewed as a restricted form of learning polynomial kernels,
are far the best MKL methods in practice and can significantly outperform state-of-the-art
SVM with a single kernel or with the uniform combination of kernels.
Assume that we are given a set of base kernels {Œ∫1 , . . . , Œ∫r }. In this section we consider the
set KD of product kernels of degree at most D: Choose I = {(r1 , . . . , rd ) : 0 ‚â§ Q
d ‚â§ D, 1 ‚â§ ri ‚â§ r}
and the multi-index r1:d = (r1 , . . . , rd ) ‚àà I defines the kernel Œ∫r1:d (x, x0 ) = di=1 Œ∫ri (x, x0 ).
For d = 0 we define Œ∫r1:0 (x, x0 ) = 1. Note that indices that are the permutations of each
other define the same kernel. On the language of statistical modeling, Œ∫r1:d models interactions of order d between the features underlying the base kernels Œ∫1 , . . . , Œ∫r . Also note that
|I| = Œò(rD ), that is, the cardinality of I grows exponentially fast in D.
We assume that œÅr1:d depends only on d, the order of interactions in Œ∫r1:d . By abusing

8

Algorithm 3 Polynomial kernel sampling. The symbol
denotes the Hadamard product/power.
1: Input: Œ± ‚àà Rn , the solution to the dual problem; kernel matrices {K1 , . . . , Kr }; the
degree
of the polynomial kernel, the weights (œÅ20 , . . . , œÅ2D ).
PD
r
>
2: S ‚Üê
j=1 KDj , M ‚Üê Œ±Œ±
E
0
‚àí2
3: Œ¥(d0 ) ‚Üê œÅd0 M, S d , d0 ‚àà {0, . . . , D}
PD
4: Sample d from Œ¥(¬∑)/ d0 =0 Œ¥(d0 )
5: for i = 1 to d do
tr(M S (d‚àíi) K )
6:
œÄ(j) ‚Üê tr(M S (d‚àíi+1) j) , j ‚àà {1, . . . , r}
7:
Sample zi from œÄ(¬∑)
8:
M ‚Üê M K zi
9: end for
10: return (z1 , . . . , zd )
notation, we will write œÅd in the rest of this section to emphasize this.3 Our proposed
algorithm to sample from qk‚àí1,¬∑ is shown in Algorithm 3. The algorithm is written to return
a multi-index (z1 , . P
. . , zd ) that isP
drawn from qk‚àí1,¬∑ . The key idea underlying the algorithm
r
d
is to exploit that ( j=1 Œ∫j ) = r1:d ‚ààI Œ∫r1:d . The correctness of the algorithm is shown in
Section 4.1. In the description of the algorithm
denotes the matrix entrywise product
(a.k.a. Schur, or Hadamard product) and A s denotes A
.{z
. . A}, and we set the priority
|
s

of
A

to be higher than that of the ordinary matrix product (by definition, all the entries of
0 are 1).
Let us now discuss the complexity of Algorithm 3. For this, first note that computing all
0
the Hadamard products S d , d0 = 0, . . . , D requires O(Dn2 ) computations. Multiplication
with Mk‚àí1 can be done in O(n2 ) steps. Finally, note that each iteration of the for loop takes
O(rn2 ) steps, which results in the overall worst-case complexity of O(rn2 D) if Œ±‚àó (Œ∏k‚àí1 ) is
readily available. The computational complexity of determining Œ±‚àó (Œ∏k‚àí1 ) depends on the
exact form of `t , and can be done efficiently in many situations: if, for example, `t is the
squared loss, then Œ±‚àó can be computed in O(n3 ) time. An obvious improvement to the
approach described here, however, would be to subsample the empirical loss Ln , which can
bring further computational improvements. However, the exploration of this is left for future
work.
Finally, note that despite the exponential cardinality of |I|, due to the strong algebraic
structure of the space of kernels, Ck‚àí1 can be calculated
In fact, it is not hard to
P efficiently.
0 ). This also shows that if œÅ
see that with the notation of the algorithm, Ck‚àí1 = D
Œ¥(d
0
d
d =0
decays ‚Äúfast enough‚Äù, Ck‚àí1 can be bounded independently of the cardinality of I.

4.1

Correctness of the sampling procedure

In this section we prove the correctness of Algorithm 3.
As said earlier, we assume that œÅr1:d depends only on d, the order of interactions in Œ∫r1:d
3

Using importance sampling, more general weights can also be accommodated, too without effecting the
results as long as the range of weights (œÅr1:d ) is kept under control for all d.

9

and, by abusing notation, we will write œÅd to emphasize this. Let us
P how one can
Pnow consider
sample from qk‚àí1,¬∑ . The implementation relies on the fact that ( rj=1 Œ∫j )d = r1:d ‚ààI Œ∫r1:d .
Remember that we denoted the kernel matrix underlying some kernel k by Kk , and recall
that Kk is an n √ó n matrix. For brevity, in the rest of this section for Œ∫ = Œ∫r1:d we will write
Kr1:d instead of KŒ∫r1:d . Define Mk‚àí1 = Œ±‚àó (Œ∏k‚àí1 )Œ±‚àó (Œ∏k‚àí1 )> . Thanks to (12) and the rotation
property of trace, we have
(15)
gk,r1:d = ‚àíœÅ‚àí2
d tr(Mk‚àí1 Kr1:d ) .
P
The plan to sample from qk‚àí1,¬∑ = |gk,¬∑ |/ r1:d ‚ààI |gk,r1:d | is as follows: We first draw the order
of interactions, 0 ‚â§ dÀÜ ‚â§ D. Given dÀÜ = d, we restrict the draw of the random multi-index
ÀÜ
R1:d to the set {r1:d ‚àà I}. A multi-index will be sampled in a d-step
process: in each step
we will randomly choose an index from the indices of base kernels according to the following
distributions. Let S = K1 + . . . + Kr , let


œÅ‚àí2 tr(Mk‚àí1 S d )
P dÀÜ = d|Fk‚àí1 = PD d ‚àí2
d0 )
d0 =0 œÅd0 tr(Mk‚àí1 S
and, with a slight abuse of notation, for any 1 ‚â§ i ‚â§ d define


P Ri = ri |Fk‚àí1 , dÀÜ = d, R1:i‚àí1 = r1:i‚àí1




i
(d‚àíi)
tr Mk‚àí1
K
S
j=1 rj




= P
r
i‚àí1
(d‚àíi)
0
tr
M
K
K
S
0
r
k‚àí1
r
j
r =1
j=1
i
i

where we used the sequence notation (namely, s1:p denotes the sequence (s1 , . . . , sp )). We
have, by the linearity of trace and the definition of S that
r
X


tr Mk‚àí1



i‚àí1
j=1 Krj



Kri0

S

(d‚àíi)



ri0 =1


= tr Mk‚àí1



i‚àí1
j=1 Krj



S

(d‚àíi+1)



Thus, by telescoping,


P dÀÜ = d, R1:d = r1:d |Fk‚àí1
=

œÅ‚àí2
. . . Krd‚àí1 Krd )
d tr(Mk‚àí1 Kr1
.
PD
‚àí2
d0 )
d0 =0 œÅd0 tr(Mk‚àí1 S

as desired. An optimized implementation of drawing these random variables is shown as
Algorithm 3. The algorithm is written to return the multi-index R1:d .

5

Experiments

In this section we apply our method
P to the problem of multiple kernel learning in regression
with the squared loss: L(w) = 21 nt=1 (fw (xt ) ‚àí yt )2 , where (xt , yt ) ‚àà Rr √ó R are the inputoutput pairs in the data. In these experiments our aim is to learn polynomial kernels (cf.
Section 4).
10

We compare our method against several kernel learning algorithms from the literature
on synthetic and real data. In all experiments we report mean squared error over test sets.
A constant feature is added to act as offset, and the inputs and output are normalized to
have zero mean and unit variance. Each experiment is performed with 10 runs in which we
randomly choose training, validation, and test sets. The results are averaged over these runs.

5.1

Convergence speed

In this experiment we examine the speed of convergence of our method and compare it against
one of the fastest standard multiple kernel learning algorithms, that is, the p-norm multiple
kernel learning algorithm of Kloft et al. (2011) with p = 2,4 and the uniform coordinate
descent algorithm that updates one coordinate per iteration uniformly at random (Nesterov,
2010, 2012; Shalev-Shwartz and Tewari, 2011; RichtaÃÅrik and TakaÃÅcÃÇ, 2011). We aim to learn
polynomial kernels of up to degree 3 with all algorithms. Our method uses Algorithm 3
for sampling with D = 3. The set of provided base kernels is the linear kernels built from
input variables, that is, Œ∫(i) (x, x0 ) = x(i) x0(i) , where x(i) denotes the ith input variable. For
the other two algorithms the kernel set consists of product kernels from monomial terms for
D ‚àà {0, 1, 2, 3} built from r base kernels, where r is the number of input variables. The
number of distinct product kernels is r+D
D . In this experiment for all algorithms we use
ridge regression with its regularization parameter set to 10‚àí5 . Experiments with other values
of the regularization parameter achieved similar results.
We compare these methods in four datasets from the UCI machine learning repository
(Frank and Asuncion, 2010) and the Delve datasets5 . The specifications of these datasets are
shown in Table 1. We run all algorithms for a fixed amount of time and measure the value
Table 1: Specifications of datasets used in experiments.
Dataset
german
ionosphere
ringnorm
sonar
splice
waveform

# of variables
20
34
20
60
60
21

Training size
350
140
500
83
500
500

Validation size
150
36
1000
21
1000
1000

Test size
500
175
2000
104
1491
2000

of the objective function (1), that is, the sum of the empirical loss and the regularization
term. Figure 1 shows the performance of these algorithms. In this figure Stoch represents
our algorithms, Kloft represents the algorithm of Kloft et al. (2011), and UCD represents
the uniform coordinate descent algorithm. The results show that our method consistently
outperforms the other algorithms in convergence speed. Note that our stochastic method
updates one kernel coefficient per iteration, while Kloft updates r+D
kernel coefficients
D
per iteration. The difference between the two methods is analogous to the difference between stochastic gradient vs. full gradient algorithms. While UCD also updates one kernel
4

Note that p = 2 in Kloft et al. (2011) notation corresponds to p = 4/3 or ŒΩ = 2 in our notation, which
gives the same objective function that we minimize with Algorithm 2.
5
See, www.cs.toronto.edu/~delve/data/datasets.html

11

10

10

german

objective function

ionosphere

6

10
Kloft
Stoch
UCD

ringnorm

6

10

4

4

10

waveform

6

10

4

10

10

5

10

2

2

10

0

10

0

10

0

2

10

0

10

10

10

‚àí2

‚àí2

10
‚àí5

10

0

‚àí4

50
100
time (sec.)

150

10

0

‚àí2

10

10

‚àí4

5

10
15
time (sec.)

20

10

0

‚àí4

100

200
300
time (sec.)

400

10

0

100
200
time (sec.)

300

Figure 1: Convergence comparison of our method and other algorithms.
coefficient per iteration its naive method of selecting coordinates results in a slower overall convergence compared to our algorithm. In the next section we compare our algorithm
against several representative methods from the MKL literature.

5.2

Synthetic data

In this experiment we examine the effect of the size of the kernel space on prediction accuracy
and training time of MKL algorithms. We generated data for a regression problem. Let r
denote the number of dimensions of the input space. The inputs are chosen uniformly at
random from [‚àí1, 1]r . The output of each instance is the uniform combination of 10 monomial
terms of degree 3 or less. These terms are chosen uniformly at random among all possible
terms. The outputs are noise free. We generated data for r ‚àà {5, 10, 20, . . . , 100}, with 500
training and 1000 test points. The regularization parameter of the ridge regression algorithm
was tuned from {10‚àí8 , . . . , 102 } using a separate validation set with 1000 data points.
We compare our method (Stoch) against the algorithm of Kloft et al. (2011) (Kloft),
the nonlinear kernel learning method of Cortes et al. (2009) (Cortes), and the hierarchical
kernel learning algorithm of Bach (2008) (Bach).6 The set of base kernels consists of r linear
kernels built from the input variables.
P Recall that the method of Cortes et al. (2009) only
considers kernels of the form Œ∫Œ∏ = ( ri=1 Œ∏i Œ∫i )D , where D is a predetermined integer that
specifies the degree of nonlinear kernel. Note that adding a constant feature is equivalent
to adding polynomial kernels of degree less than D to the combination too. We provide all
possible product kernels of degree 0 to D to the kernel learning method of Kloft et al. (2011).
For our method and the method of Bach (2008) we set the maximum kernel degree to D = 3.
The results are shown in Figure 2, the mean squared errors are on the left plot, while the
training times are on the right plot. In the training-time plot the numbers inside brackets
6
While several fast MKL algorithms are available in the literature, such as those of Sonnenburg et al. (2006);
Rakotomamonjy et al. (2008); Xu et al. (2010); Orabona and Luo (2011); Kloft et al. (2011), a comparison of
the reported experimental results shows that from among these algorithms the method of Kloft et al. (2011)
has the best performance overall. Hence, we decided to compare against only this algorithm. Also note
that the memory and computational cost of all these methods still scale linearly with the number of kernels,
making them unsuitable for the case we are most interested in. Furthermore, to keep the focus of the paper
we compare our algorithm to methods with sound theoretical guarantees. As such, it remains for future work
to compare with other methods, such as the infinite kernel learning of Gehler and Nowozin (2008), which lack
such guarantees but exhibit promising performance in practice.

12

1

250
Kloft
Stoch
Cortes
Bach
Uniform

0.9
0.8

200
training time (sec.)

0.7

MSE

0.6
0.5
0.4
0.3
0.2

150

100

50

0.1
0

20
40
60
80
number of dimensions of input space

0

100

20
[1,771]

40

60

80

100

[12,341]

[39,711]

[91,881]

[176,851]

Figure 2: Comparison of kernel learning methods in terms of test error (left) and training
time (right).
indicate the total number of distinct product kernels for each value of r. This is the number of
kernels fed to the Kloft algorithm. Since this method deals with a large number of kernels,
it was possible to precompute and keep the kernels in memory (8GB) for r ‚â§ 25. Therefore,
we ran this algorithm for r ‚â§ 25. For r > 25, we could use on-the-fly implementation of this
algorithm, however that further increases the training time. Note that the computational cost
of this method depends linearly on the number of kernels, which in this experiment, is cubic
in the number of input variables since D = 3. While the standard MKL algorithms, such
as Kloft, cannot handle such large kernel spaces, in terms of time and space complexity,
the other three algorithms can efficiently learn kernel combinations. However their predictive
accuracies are quite different. Note that the performance of the method of Cortes et al.
(2009) starts to degrade as r increases. This is due to the restricted family of kernels that
this method considers. The method of Bach (2008), which is well-suited to learn sparse
combination of product kernels, performs better than Cortes et al. (2009) for higher input
dimensions. Among all methods, our method performs best in predictive accuracy while its
computational cost is close to that of the other two competitors.

5.3

Real data

In this experiment we aim to compare several MKL methods in real datasets. We compare
our new algorithm (Stoch), the algorithm of Bach (2008) (Bach), and the algorithm of
Cortes et al. (2009) (Cortes). For each algorithm we consider learning polynomial kernels
of degree 2 and
P 3. We also include uniform combination of product kernels of degree D,
i.e. Œ∫D = ( ri=1 Œ∫i )D , for D ‚àà {1, 2, 3} (Uniform). To find out if considering higherorder interaction of input variables results in improved performance we also included a MKL
algorithm to which we only feed linear kernels (D = 1). We use the MKL algorithm of Kloft
et al. (2011) with p ‚àà {1, 2} (Kloft).
We compare these methods on six datasets from the UCI machine learning repository

13

ionosphere

german

ringnorm

0.78

Bach (d=2)
Bach (d=3)

MSE

Stoch (d=2)
Stoch (d=3)
Stoch (d=3, prior)

0.8

0.7

0.76
0.74

0.6

0.6
0.72
0.7

0.4

0.5

0.68
0.2

Cortes (d=2)
Cortes (d=3)
Kloft (p=1)
Kloft (p=2)
Uniform (d=1)
Uniform (d=2)
Uniform (d=3)

sonar

splice

waveform

0.9

0.8

0.6

0.5

0.55

0.45

0.5

0.4

0.7

0.45
0.4

0.35

0.6

0.35

0.3

Figure 3: Prediction error of different methods in the real data experiment
and Delve datasets. In these datasets the number of dimensions of the input space is 20
and above. The specifications of these datasets are shown in Table 1. The regularization
parameter is selected from the set {10‚àí4 , . . . , 103 } for all methods using a validation set. The
results are shown in Figure 3.
Overall, we observe that methods that consider non-linear variable interactions (Stoch,
Bach, and Cortes) perform better than linear methods (Kloft). Among non-linear methods, Cortes performs worse than the other two. We believe that this is due to the restricted
kernel space considered by this method. The performance of Stoch and Bach methods is
similar overall.
We observe that our method overfits when it considers kernels of degree 3. However, one
can easily prevent overfitting by assigning larger œÅ values to higher-degree kernels such that
the stochastic algorithm selects lower-degree kernels more often. For this purpose, we repeat
this experiment for D = 3 with a modified set of œÅ values, where we use œÅ2d = 1 for kernels of
degree 2 or less and œÅ2d = 4 for kernels of degree 3. With the new œÅ coefficients we observe an
improvement in algorithm‚Äôs performance. See Stoch (D = 3, prior) error values in Figure 3.

6

Conclusion

We introduced a new method for learning a predictor by combining exponentially many linear
predictors using a randomized mirror descent algorithm. We derived finite-time performance
bounds that show that the method efficiently optimizes our proposed criterion. Our proposed
method is a variant of a randomized stochastic coordinate descent algorithm, where the main
trick is the careful construction of an unbiased randomized estimate of the gradient vector
that keeps the variance of the method under control, and can be computed efficiently when
the base kernels have a certain special combinatorial structure. The efficiency of our method
14

was demonstrated for the practically important problem of learning polynomial kernels on a
variety of synthetic and real datasets comparing to a representative set of algorithms from
the literature. For this case, our method is able to compute an optimal solution in polynomial
time as a function of the logarithm of the number of base kernels. To our knowledge, ours is
the first method for learning kernel combinations that achieve such an exponential reduction
in complexity while satisfying strong performance guarantees, thus opening up the way to
apply it to extremely large number of kernels. Furthermore, we believe that our method is
applicable beyond the case studied in detail in our paper. For example, the method seems
extendible to the case when infinitely many kernels are combined, such as the case of learning
a combination of Gaussian kernels. However, the investigation of this important problem
remains subject to future work.
Acknowledgements
This work was supported by Alberta Innovates Technology Futures and NSERC.

A

Proofs

In this section we present the proofs of Theorem 3.1 and Proposition 3.2. The proof of
Theorem 3.1 is based on the standard proof of the convergence rate of the proximal point
algorithm, see, for example, (Beck and Teboulle, 2003), or the proof of Proposition 2.2 of
Nemirovski et al. (2009b), which carry over the same argument to solve very similar but less
general problems. We also provide some improvements and simplifications at the end. Before
giving the actual proof, we need the following standard lemma:
Lemma A.1 (Lemma 2.1 of Nemirovski et al. 2009b). Assume that Œ® is Œ±-strongly convex
with respect to some norm k ¬∑ k (i.e., (4) holds). Let Œ∏1 ‚àà K ‚à© A‚ó¶ , Œ∏ ‚àà K ‚à© A, and g ‚àà Rd .
Define Œ∏2 = arg minŒ∏0 ‚ààK‚à©A {hg, Œ∏0 i + DŒ® (Œ∏0 , Œ∏1 )}. Then
hg, Œ∏1 ‚àí Œ∏i ‚â§ DŒ® (Œ∏, Œ∏1 ) ‚àí DŒ® (Œ∏, Œ∏2 ) +

kgk2‚àó
.
2Œ±

We provide an alternate proof that is based on the so-called 3-DIV lemma. The 3-DIV
lemma (e.g., Lemma 11.1, Cesa-Bianchi and Lugosi, 2006) allows one to express the sum of
the divergences between the vectors u, v and v, w in terms of the divergence between u and
w and an additional ‚Äúerror term‚Äù, where u ‚àà A, v, w ‚àà A‚ó¶ :
DŒ® (u, v) + DŒ® (v, w) = DŒ® (u, w) + h‚àáœà(w) ‚àí ‚àáœà(v), u ‚àí vi .
Proof. Note that Œ∏2 ‚àà A‚ó¶ due to behavior of Œ® at the boundary of A. Thus, Œ® is differentiable
at Œ∏2 and
‚àá1 DŒ® (Œ∏2 , Œ∏1 ) = ‚àáœà(Œ∏2 ) ‚àí ‚àáœà(Œ∏1 ) ,

(16)

where ‚àá1 denotes differentiation of DŒ® w.r.t. its first variable. Let f (Œ∏0 ) = hg, Œ∏0 i+DŒ® (Œ∏0 , Œ∏1 ).
By the optimality property of Œ∏2 and since Œ∏ ‚àà K ‚à© A, we have
h‚àáf (Œ∏2 ), Œ∏2 ‚àí Œ∏i ‚â§ 0 .
15

Plugging in the definition of f together with the identity (16) gives
hg + ‚àáœà(Œ∏2 ) ‚àí ‚àáœà(Œ∏1 ), Œ∏2 ‚àí Œ∏i ‚â§ 0 .

(17)

Now, by the 3-DIV Lemma,
DŒ® (Œ∏, Œ∏2 ) + DŒ® (Œ∏2 , Œ∏1 ) = DŒ® (Œ∏, Œ∏1 ) + h‚àáŒ®(Œ∏1 ) ‚àí ‚àáŒ®(Œ∏2 ), Œ∏ ‚àí Œ∏2 i
= DŒ® (Œ∏, Œ∏1 ) + hg + ‚àáŒ®(Œ∏2 ) ‚àí ‚àáŒ®(Œ∏1 ), Œ∏2 ‚àí Œ∏i + hg, Œ∏ ‚àí Œ∏2 i .
Hence, by reordering and using the inequality (17) we get
DŒ® (Œ∏, Œ∏2 ) ‚àí DŒ® (Œ∏, Œ∏1 ) ‚â§ hg, Œ∏ ‚àí Œ∏2 i ‚àí DŒ® (Œ∏2 , Œ∏1 )
= hg, Œ∏1 ‚àí Œ∏2 i ‚àí DŒ® (Œ∏2 , Œ∏1 ) + hg, Œ∏ ‚àí Œ∏1 i
‚â§

kgk2‚àó
+ hg, Œ∏ ‚àí Œ∏1 i ,
2Œ±

where in the last line we used Young‚Äôs inequality7 and that due to the strong convexity of Œ®,

DŒ® (Œ∏2 , Œ∏1 ) ‚â• Œ±2 kŒ∏2 ‚àí Œ∏1 k2 .
Theorem 3.1. Assume that Œ® is Œ±-strongly convex with respect to some norm k ¬∑ k (with
dual norm k ¬∑ k‚àó ) for some Œ± > 0, that is, for any Œ∏ ‚àà A‚ó¶ , Œ∏0 ‚àà A
Œ®(Œ∏0 ) ‚àí Œ®(Œ∏) ‚â• ‚àáŒ®(Œ∏), Œ∏0 ‚àí Œ∏ + Œ±2 kŒ∏0 ‚àí Œ∏k2 .

(4)

Suppose, furthermore, that Algorithm 1 is run for T time steps. For 0 ‚â§ k ‚â§ T ‚àí 1 let Fk
denote the œÉ-algebra generated by Œ∏1 , . . . , Œ∏k . Assume that, for all 1 ‚â§ k ‚â§ T , gÃÇk ‚àà Rd is an
unbiased estimate of ‚àáJ(Œ∏(k‚àí1) ) given Fk‚àí1 , that is,
E [ gÃÇk | Fk‚àí1 ] = ‚àáJ(Œ∏(k‚àí1) ).

(5)

Further, assume that there exists a deterministic constant B ‚â• 0 such that for all 1 ‚â§ k ‚â§ T ,


E kgÃÇk k2‚àó Fk‚àí1 ‚â§ B a.s.
(6)
q
Finally, assume that Œ¥ = supŒ∏0 ‚ààK‚à©A Œ®(Œ∏0 ) ‚àí Œ®(Œ∏(0) ) is finite. Then, if Œ∑k‚àí1 = 2Œ±Œ¥
BT for all
k ‚â• 1, it holds that
"
!#
r
T
1 X (k‚àí1)
2BŒ¥
E J
Œ∏
‚àí inf J(Œ∏) ‚â§
.
(7)
Œ∏‚ààK‚à©A
T
Œ±T
k=1

Furthermore, if
kgÃÇk k2‚àó ‚â§ B 0 a.s.
(8)
q
2Œ±Œ¥
for some deterministic constant B 0 and Œ∑k‚àí1 = B
0 T for all k ‚â• 1 then, for any 0 <  < 1,
it holds with probability at least 1 ‚àí  that
s
!
r
T
B 0 Œ¥ log 1
1 X (k‚àí1)
2B 0 Œ¥
J
Œ∏
‚àí inf J(Œ∏) ‚â§
+4
.
(9)
Œ∏‚ààK‚à©A
T
Œ±T
Œ±T
k=1

7

Young‚Äôs inequality states that for any x, y vectors and Œ± > 0, hx, yi ‚â§ kxk‚àó kyk ‚â§

16

1
2



kxk2
‚àó
Œ±


+ Œ±kyk2 .

P
(T )
Proof. Introduce the average learning rates Œ∑ k = Œ∑k / Tk=1 Œ∑k‚àí1 , k = 1, . . . , T , the averaged
parameter estimates
T
X
(T )
Œ∏ÃÑ(T ‚àí1) =
Œ∑ k‚àí1 Œ∏(k‚àí1)
k=1

and choose some Œ∏‚àó ‚àà K ‚à© A. To prove the first part of the theorem,
it suffices to show that

(T
‚àí1)
‚àó
(k‚àí1)
the bound holds for J(Œ∏ÃÑ
) ‚àí J(Œ∏ ). Define gk = ‚àáJ Œ∏
. By the convexity of J(Œ∏),
we have
T


 


X
(T )
Œ∑ k‚àí1 J Œ∏(k‚àí1) ‚àí J(Œ∏‚àó )
J Œ∏ÃÑ(T ‚àí1) ‚àí J(Œ∏‚àó ) ‚â§

‚â§

=

k=1
T
X
k=1
T
X

D
E
(T )
Œ∑ k‚àí1 gk , Œ∏(k‚àí1) ‚àí Œ∏‚àó
T
E X
E
D
D
(T )
(T )
Œ∑ k‚àí1 gÃÇk , Œ∏(k‚àí1) ‚àí Œ∏‚àó +
Œ∑ k‚àí1 gk ‚àí gÃÇk , Œ∏(k‚àí1) ‚àí Œ∏‚àó (18)
k=1

k=1

Notice that the first term on the right hand side above is the sum of linearized losses appearing
in the standard analysis of the proximal point algorithm with loss functions gÃÇk and learning
(T )
rates Œ∑ k‚àí1 , and the second sum contains the term that depends on how well gÃÇk estimates
the gradient gk . Thus, in this way, it is separated how the proximal point algorithm and the
gradient estimate effect the convergence rate of the algorithm. The first sum can be bounded
by invoking the standard bound for the proximal point algorithm (we will give the very short
proof for completeness, based on Lemma A.1), while the second sum can be analyzed by
noticing that, by assumption (5), its elements form an {Fk }-adapted martingale-difference
sequence.
To bound the first sum, first note that the conditions of Lemma A.1 are satisfied for
(T )
Œ∏1 = Œ∏(k‚àí1) , Œ∏ = Œ∏‚àó , g = Œ∑ k‚àí1 gÃÇk , since Œ∏1 ‚àà K ‚à© A‚ó¶ (as mentioned beforehand, this follows
from the behavior of Œ® at the boundary of A). Further, note that due to the so-called
projection lemma (i.e., the DŒ® -projection of the unconstrained optimizer is the same as the
optimizer of the constrained optimization problem),we can conclude that Œ∏(k) = Œ∏2 , where Œ∏2
is defined in Lemma A.1. Thus, Lemma A.1 gives
D
E
Œ∑ 2 kgÃÇk k2‚àó
Œ∑k‚àí1 gÃÇk , Œ∏(k‚àí1) ‚àí Œ∏‚àó ‚â§ DŒ® (Œ∏‚àó , Œ∏(k‚àí1) ) ‚àí DŒ® (Œ∏‚àó , Œ∏(k ) + k‚àí1
.
2Œ±
Summing the above inequality for k = 1, . . . , T , the divergence terms cancel each other,
yielding
!
T
T
D
E
X
X
1
1
(T )
2
Œ∑ k‚àí1 gÃÇk , Œ∏(k‚àí1) ‚àí Œ∏‚àó ‚â§ PT
Œ∑k‚àí1
kgÃÇk k2‚àó .
DŒ® (Œ∏‚àó , Œ∏(0) ) ‚àí DŒ® (Œ∏‚àó , Œ∏(T ) ) +
2Œ±
Œ∑
k=1 k‚àí1
k=1
k=1
(19)
Let us now turn to the second sum. We start with developing a bound on the expected
(T )
regret. For any 1 ‚â§ k ‚â§ T , by construction Œ∑ k‚àí1 and Œ∏(k‚àí1) are Fk‚àí1 -measurable. This,
together with (5) gives
D
D
h
E
i
E
(T )
(T )
E Œ∑ k‚àí1 gk ‚àí gÃÇk , Œ∏‚àó ‚àí Œ∏(k‚àí1) Fk‚àí1 = Œ∑ k‚àí1 gk ‚àí E [ gÃÇk | Fk‚àí1 ] , Œ∏‚àó ‚àí Œ∏(k‚àí1) = 0 . (20)
17

Combining this result with (18) and (19) yields
h 

i
E J Œ∏ÃÑ(T ) ‚àí J(Œ∏‚àó ) ‚â§
‚â§

1

‚àó

DŒ® (Œ∏ , Œ∏
Œ∑
k‚àí1
k=1
1 PT
2
Œ¥ + 2Œ±
k=1 Œ∑k‚àí1 B
,
PT
k=1 Œ∑k‚àí1
PT

(0)

‚àó

) ‚àí DŒ® (Œ∏ , Œ∏

(T )

!
T
 

1 X 2
2
)+
Œ∑k‚àí1 E E kgÃÇk k‚àó Fk‚àí1
2Œ±
k=1

(21)

where we used the tower rule to bring in the bound (6), the nonnegativity of Bregman
divergences, and DŒ® (Œ∏, Œ∏(0) ) ‚â§ Œ®(Œ∏) ‚àí Œ®(Œ∏(0) ); the latter holds as ‚àáŒ®(Œ∏(0) ), Œ∏ ‚àí Œ∏(0) ‚â• 0
q
since Œ∏(0) minimizes Œ® on K. Substituting Œ∑k‚àí1 = Œ∑ = 2Œ±Œ¥
BT , k = 1, . . . , T finishes the proof
of (7).

To prove the high probability result (9), notice that thanks to (5) Œ∑k‚àí1 gk ‚àí gÃÇk , Œ∏‚àó ‚àí Œ∏(k‚àí1)
is an {Fk }-adapted martingale-difference sequence (cf. (20)). By the strong convexity of Œ®
we have
Œ± (k‚àí1)
kŒ∏
‚àí Œ∏‚àó k2 ‚â§ Œ®(Œ∏(k‚àí1) ) ‚àí Œ®(Œ∏‚àó ) ‚â§ Œ¥.
2
Furthermore, conditions
(5) and (8) imply that kgk k2‚àó ‚â§ B 0 a.s., and so by (8) we have
‚àö
kgk ‚àí gÃÇk k‚àó ‚â§ 2 B 0 a.s. Then by HoÃàlder‚Äôs inequality
r
E
D
2B 0 Œ¥
‚àó
(k‚àí1)
‚àó
(k‚àí1)
gk ‚àí gÃÇk , Œ∏ ‚àí Œ∏
‚â§ kgk ‚àí gÃÇk k‚àó kŒ∏ ‚àí Œ∏
k‚â§2
.
Œ±
Thus, by the Hoeffding-Azuma inequality (see, e.g., Lemma A.7, Cesa-Bianchi and Lugosi,
2006), for any 0 <  < 1 we have, with probability at least 1 ‚àí ,
v
!
u
T
T
D
E
u B0Œ¥ X
X
4
1
(T )
‚àó
(k‚àí1)
t
2
Œ∑ k‚àí1 gk ‚àí gÃÇk , Œ∏ ‚àí Œ∏
‚â§ PT
Œ∑k‚àí1 ln .
(22)
Œ±

Œ∑
k‚àí1
k=1
k=1
k=1
Combining (19) with (8) implies an almost sure upper bound on the first sum on the right
hand side of (18) as in (21) with B 0 in place of B. This, together
q with (22) proves the required
high probability bound (9) when substituting Œ∑k‚àí1 = Œ∑ 0 =

2Œ±Œ¥
B0T .


Proposition 3.2. For 1 ‚â§ t ‚â§ n, let `‚àót : R ‚Üí R denote the convex conjugate of `t : `‚àót (v) =
0 )i, and let K =
supœÑ ‚ààR {vœÑ ‚àí `t (œÑ )}, v ‚àà R. For i ‚àà I, recall that Œ∫i (x, x0 ) = hœÜi (x), œÜi (xP
i
(Œ∫i (xt , xs ))1‚â§t,s‚â§n be the n √ó n kernel matrix underlying Œ∫i and let KŒ∏ = i‚ààI œÅŒ∏2i Ki be the
i
P
Œ∏i
‚àó
kernel matrix underlying Œ∫Œ∏ =
i‚ààI œÅ2i Œ∫i . Then, for any fixed Œ∏, the minimizer w (Œ∏) of
J(¬∑, Œ∏) satisfies
n
Œ∏i X ‚àó
wi‚àó (Œ∏) = 2
Œ± (Œ∏)œÜi (xt ), i ‚àà I ,
(10)
œÅi t=1 t
where

(
‚àó

Œ± (Œ∏) = arg min
Œ±‚ààRn

n

1 >
1X ‚àó
Œ± KŒ∏ Œ± +
`t (‚àínŒ±t )
2
n
t=1

18

)
.

(11)

Proof. By introducing the variables œÑ = (œÑt )1‚â§t‚â§n ‚àà Rn and using the definition of L we can
write the optimization problem (3) as the constrained optimization problem
n

minimizen

w‚ààW,œÑ ‚ààR

1X
1 X œÅ2i kwi k22
`t (œÑt ) +
n
2
Œ∏i
t=1

s.t. œÑt =

X

hwi , œÜi (xt )i ,

(23)

i‚ààI

i‚ààI

In what follows, we call this problem the primal problem. The Lagrangian of this problem is
(
)
n
n
X
1 X œÅ2i kwi k22 X
. 1X
hwi , œÜi (xt )i ,
L(w, œÑ, Œ±) =
`t (œÑt ) +
+
Œ±t œÑt ‚àí
n
2
Œ∏i
t=1

t=1

i‚ààI

i‚ààI

Rn

where Œ± = (Œ±t )1‚â§t‚â§n ‚àà
is the vector of Lagrange multipliers (or dual variables) associated
.
with the n equality constraints. The Lagrange dual function, g(Œ±) = inf w,œÑ L(w, œÑ, Œ±), can be
readily seen to satisfy
!
n
1 >
1X ‚àó
g(Œ±) = ‚àí
Œ± KŒ∏ Œ± +
`t (‚àínŒ±t ) .
2
n
t=1

Now, since the objective function of the primal problem is convex and the primal problem
involves only affine equality constraints and the primal problem is clearly feasible, by Slater‚Äôs
condition (p.226, Boyd and Vandenberghe, 2004), if Œ±‚àó (Œ∏) is the maximizer of g(Œ±) then
w‚àó (Œ∏) = arg min infn L(w, œÑ, Œ±‚àó (Œ∏))
w‚ààW œÑ ‚ààR
(
)
n
X œÅ2 kwi k2 X
2
i
= arg min
‚àí
Œ±t hwi , œÜi (xt )i .
2Œ∏i
w‚ààW
t=1

i‚ààI

The minimum of the last expression is readily seen to be equal to the expression given in (10),
thus finishing the proof.


B

Calculating the derivative of J(Œ∏)

In this section we show that under mild conditions the derivative of J exist and we also give
explicit forms. These derivations are quite standard and a similar argument can be found in
the paper by (e.g.) Rakotomamonjy et al. (2008) specialized to the case when `t is the hinge
loss.
As it is well-known, thanks to the implicit function theorem (e.g., Brown and Page,
‚àÇ2
‚àÇ
1970, Theorem 7.5.6), provided that J = J(w, Œ∏) is such that ‚àÇŒ∏‚àÇw
J(w, Œ∏) and ‚àÇw
J(w, Œ∏)
are continuous, the gradient of J(Œ∏) can be computed by evaluating the partial derivative
‚àÇ
‚àÇ
‚àó
‚àÇŒ∏ J(w, Œ∏) of J(w, Œ∏) with respect to Œ∏ at (w (Œ∏), Œ∏)), that is, ‚àÇŒ∏ J(Œ∏) = ‚àÇŒ∏ J(w, Œ∏)|w=w‚àó (Œ∏) .Note
that the derivative is well-defined only if Œ∏ > 0, that is, when no coordinates of Œ∏ is zero, in
which case
 2 ‚àó

œÅi kwi (Œ∏)k22
‚àÇ
‚àó
J(w (Œ∏), Œ∏) = ‚àí
.
(24)
‚àÇŒ∏
Œ∏i2
i‚ààI
If Œ∏i = 0 for some i ‚àà I, we define the derivative in a continuous manner as
‚àÇ
J(Œ∏) =
‚àÇŒ∏

lim
0

Œ∏ ‚ÜíŒ∏

Œ∏0 ‚àà‚àÜ,Œ∏0 >0

19

‚àÇ
J(Œ∏0 )
‚àÇŒ∏

(25)

assuming that the limit exists. From (10) we get, for any i ‚àà I, kwi‚àó (Œ∏)k22 =
Combining with (24) we obtain

 ‚àó >
‚àÇ
Œ± (Œ∏) Ki Œ±‚àó (Œ∏)
‚àó
.
J(w (Œ∏), Œ∏) = ‚àí
‚àÇŒ∏
œÅ2i
i‚ààI

Œ∏i2 ‚àó
Œ± (Œ∏)> Ki Œ±‚àó (Œ∏).
œÅ4i

Now, by (25) and the implicit function theorem, Œ±‚àó (Œ∏) is a continuous function of Œ∏ provided
that the functions `‚àót (1 ‚â§ t ‚â§ n) are twice continuously differentiable. This shows that under
the conditions listed so far, the limit in (25) exists. In the application we shall be concerned
with, these conditions can be readily verified.

