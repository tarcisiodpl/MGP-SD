
Various tasks in decision making and decision support systems require selecting a preferred
subset of a given set of items. Here we focus on problems where the individual items are described
using a set of characterizing attributes, and a generic preference specification is required, that is,
a specification that can work with an arbitrary set of items. For example, preferences over the
content of an online newspaper should have this form: At each viewing, the newspaper contains a
subset of the set of articles currently available. Our preference specification over this subset should
be provided offline, but we should be able to use it to select a subset of any currently available
set of articles, e.g., based on their tags. We present a general approach for lifting formalisms
for specifying preferences over objects with multiple attributes into ones that specify preferences
over subsets of such objects. We also show how we can compute an optimal subset given such a
specification in a relatively efficient manner. We provide an empirical evaluation of the approach
as well as some worst-case complexity results.

1. Introduction
Work on reasoning with preferences focuses mostly on the task of recognizing preferred elements
within a given set. However, another problem of interest is that of selecting an optimal subset of
elements. Optimal subset selection is an important problem with many applications: the choice of
feature subsets in machine learning, selection of a preferred bundle of goods (as in, e.g., a home
entertainment system), finding the best set of items to display on the user’s screen, selecting the best
set of articles for a newspaper or the best members for a committee, etc.
Earlier work on this problem has mostly focused on the question of how one can construct an
ordering over subsets of elements given an ordering over the elements of the set (Barberà, Bossert,
& Pattanaik, 2004). The main distinction made has been between sets of items that are mutually
exclusive, in the sense that only one can eventually materialize, and sets in which the items will
jointly materialize. Our formalism is agnostic on this issue, although we are clearly motivated by
the latter case. As Barberà et al. note, most past work focused on the case of mutually exclusive
elements. This, for example, would be the case if we are selecting a set of alternatives from which
some decision-maker (or nature) will ultimately choose only one (e.g., courses of action). However,

©2009 AI Access Foundation. All rights reserved.

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

there is a substantial body of work on the latter setting in which items might materialize jointly, and
individual items are preferentially comparable.
This paper focuses on a somewhat different context for set-preference specification. First, we
assume that the items from which our subsets are composed are structured, in the sense that some set
of attributes is associated with them. For example, if the items are movies, these attributes could be
the genre, language, year, director; if the “items” are politicians, the attributes could be the political
views of the politicians on various topics, their party affiliation, their level of experience. Second,
we require a generic preference specification, in the sense that it can be used with diverse collections
of items. For example, if we are specifying guidelines for the composition of some committee, these
guidelines are generic, and can be used to induce a preference relation over subsets of any given set
of politicians, provided that the set of attributes is fixed. Third, we do not assume any preferential
ordering over the individual items, although that can certainly be captured by one of the attributes
describing the items.
An instructive example of the type of domain we have in mind is that of personalized online
newspapers. First, the problem of selection for a newspaper is one of subset selection – we have
to select a subset of the set of available articles to place in the newspaper. Second, the database
of articles is constantly changing. Therefore, an approach that requires explicitly specifying preferences for the inclusion of each specific item is inappropriate, both because the number of such
items is very large, and because this would require us to constantly change the preference specification as the set of items changes. Finally, we would not want to base our approach on a method for
transforming an ordering over items into an ordering over subsets of items, because we do not want
to have to rank each item, and because there are obvious instances of complementarity and substitutability. For instance, even if I prefer articles on Britney Spears to articles on any other topic, two
very similar articles about her may be less interesting than a set comprising one about her and one
about the Spice Girls.1
One recent work that considers a similar setting is that of desJardins and Wagstaff (2005), which
works by specifying preferences over more abstract properties of sets. In particular, desJardins and
Wagstaff offer a formalism for preference specification in which users can specify their preferences
about the set of values each attribute attains within the selected set of items. One could assert
whether the values attained by an attribute on the selected subset should be diverse or concentrated
around some specific value. In addition, desJardins and Wagstaff also suggest a heuristic search
algorithm for finding good, though not necessarily optimal, such sets of items.
In this work, we present a more general, two-tiered approach for dealing with set preferences in
the above setting. This approach combines a language for specifying certain types of set properties,
and an arbitrary preference specification language for expressing preferences over single, attributed
items. The basic idea is to first specify the set properties we care about, and then specify preferences
over the values of these properties. Such a specification induces a preference ordering over sets
based on the values these sets provide to the properties of interest. We believe that the suggested
approach is both intuitive and powerful. Although in this paper we focus on a particular set of
properties for which we have devised a relatively efficient optimization algorithm, in its most general
form, this two-tiered approach generalizes the approach of desJardins and Wagstaff (2005) because
diversity and specificity are just two set properties. In principle, one can express both more general
1. We realize that common rules of rationality may not apply to users with such preferences.

134

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

properties referring to multiple attributes, as well as more general conditional preferences over the
values of these properties.
Essentially, our approach re-states the problem of specifying preferences over sets in terms used
to specify preferences over single items. In our formulation, “items” stand for the possible sets,
and attributes of such “items” are their (user-defined) set-property values. Thus, in principle, this
approach allows us to re-use any formalism for specifying preferences over single items. In this paper we will consider two specific instantiations of such a formalism: qualitative preferences based
on CP or TCP-nets (Boutilier, Brafman, Domshlak, Hoos, & Poole, 2004; Brafman, Domshlak, &
Shimony, 2006a), and quantitative preferences represented as generalized additively independent
(GAI) value functions (Bacchus & Grove, 1995; Fishburn, 1969). The algorithm we suggest for
computing an optimal subset given qualitative preferences is based on a similar optimization algorithm for TCP-nets. But because the number of “items” in our case is very large, this algorithm is
modified substantially to exploit the special structure of these “items”. These modifications enable
us to compute an optimal subset faster.

2. Specifying Set Preferences
The formalism we use for set-preference specification makes one fundamental assumption: the
items from which sets of interest are built are described in terms of some attributes, and the values
of these attributes are what distinguishes different items. We shall use S to denote the set of individual items, and X to denote the set of attributes describing these items. For example, imagine that
the “items” in question are US senate members, and the attributes and their values are: Party affiliation (Republican, Democrat), Views (liberal, conservative, ultra conservative), and Experience
(experienced, inexperienced).
2.1 From Properties of Items to Properties of Item Sets
Given the set X of item-describing attributes, first, we can already talk about more complex item
properties, e.g., “senate members with liberal views”, or “inexperienced, conservative senate members”. More formally, let X be the union of the attribute domains, that is,
X = {X = x | X ∈ X , x ∈ Dom(X)} ,
and let LX be the propositional language defined over X with the usual logical operators. LX
provides us with a language for describing complex properties of individual items. Since items in S
can be viewed as models of LX , we can write o |= ϕ whenever o ∈ S and o is an item that satisfies
the property ϕ ∈ LX .
Given the language LX , we can now specify arbitrary properties of item sets based on the
attribute values of items in a set, such as the property of having at least two Democrats, or having
more Democrats than Republicans. More generally, given any item property ϕ ∈ LX , we can
talk about the number of items in a set that have property ϕ, which we denote by |ϕ|(S), that
is, |ϕ|(S) = |{o ∈ S|o |= ϕ}|. Often the set S is implicitly defined, and we simply write |ϕ|.
Thus, |Experience=experienced|(S) is the number of experienced members in S. Often, we simply
abbreviate this as |experienced|.
While |ϕ|(·) is an integer-valued property of sets, we can also specify boolean set properties as
follows: h|ϕ| REL ki, where ϕ ∈ LX , REL is a relational operator over integers, and k ∈ Z∗ is a
135

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

non-negative integer. This property is satisfied by a set S if |{o ∈ S|o |= ϕ}| REL k. In our running
example we use the following three set properties:
• P1 : h|Party affiliation = Republican ∨ Political view = conservative| ≥ 2i
• P2 : h|Experience = experienced| ≥ 2i
• P3 : h|Political view = liberal| ≥ 1i
P1 is satisfied (only) by sets with at least two members that are either Republican or conservative.
P2 is satisfied by sets with at least 2 experienced members. P3 is satisfied by sets with at least one
liberal.
We can also write h|ϕ| REL |ψ|i, with a similar interpretation. For example, h|Republican| >
|Democrat|i holds for sets containing more Republicans than Democrats. An even more general
language could include arithmetic operators (e.g., require twice as many Republicans as Democrats)
and aggregate functions (e.g., the average number of years on the job). All these are instances of
the general notion of specifying properties of sets as a function of the attribute values of the set’s
members. In this paper, we focus on the above language with the relational operators restricted to
equalities and inequalities. We do so because having a clear, concrete setting eases the presentation,
and because restricting the language allows us to provide more efficient subset-selection algorithms.
Indeed, many of the ideas we present here apply to more general languages. In particular, this
generality holds both for the overall preference-specification methodology, and for the search-overCSPs technique for computing optimal subsets introduced later in the paper. However, the more
specific techniques we use to implement these ideas, such as bounds generation, and the specific
translation of properties into CSPs, rely heavily on the use of specific, more restrictive languages.
Finally, we note an important property of our preference specification approach of being independent of the actual set of items available at the moment. This generality is important for many
applications where the same reasoning about set preferences must be performed on different, and
often initially unknown sets of items. For example, this is the case with specifying guidelines for
selecting articles for an online newspaper, or for selecting a set of k results for an information query.
2.2 Reasoning with Set Preferences
Once we have specified the set properties of interest, we can define preferences over the values of
these properties using any preference specification formalism. Here we discuss two specific formalisms, namely TCP-nets (Brafman et al., 2006a), an extension of CP-nets (Boutilier et al., 2004),
and Generalized Additively Independent (GAI)-value functions (Bacchus & Grove, 1995; Fishburn,
1969). The former is a formalism for purely qualitative preference specification, yielding a partial
preference order over the objects of interest. The latter is a quantitative specification formalism that
can represent any value function.
Let P = {P1 , . . . , Pk } be some collection of set properties. A TCP-net over P captures statements of the following two types:
(1) Conditional Value Preference Statements. “If Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl = pl is
preferred to Pl = p0l .” That is, when Pi1 , . . . , Pij have a certain value, we prefer one value for
Pl to another value for Pl .

136

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

(2) Relative Importance Statements. “If Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl is more important than
Pm .” That is, when Pi1 , . . . , Pij have a certain value, we prefer a better value for Pl even if we
have to compromise on the value of Pm .
Each such statement allows us to compare between certain pairs of item sets as follows:
- The statement “if Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl = pl is preferred to Pl = p0l ” implies
that given any two sets S, S 0 for which (1) Pi1 = pi1 ∧ · · · ∧ Pij = pij holds, (2) S satisfies
Pl = pl and S 0 satisfies Pl = p0l , and (3) S and S 0 have identical values on all properties
except Pl , we have that S is preferred to S 0 .
- The statement “if Pi1 = pi1 ∧ · · · ∧ Pij = pij then Pl is more important than Pm ” implies
that given any two sets S, S 0 for which (1) Pi1 = pi1 ∧ · · · ∧ Pij = pij holds, (2) S has a more
preferred value for Pl , and (3) S and S 0 have identical values on all attributes except Pl and
Pm , we have that S is preferred to S 0 . (Notice that we do not care about the value of Pm if Pl
is improved.)
We refer the reader to the work of Brafman et al. (2006a) for more details on TCP-nets, their
graphical structure, their consistency, etc. The algorithms in this paper, when used with TCP-nets,
assume an acyclic TCP-net Brafman et al.. The latter property ensures both consistency of the
provided preferences, as well as existence of certain “good” orderings of P with respect to the
TCP-net.
As an example, consider the following preferences of the president for forming a committee.
He prefers at least two members that are either Republican or conservative, that is, he prefers P1
to P1 unconditionally. (Depending on the context, we use P to denote both the property P and the
value P = true. We use P to denote P = false.) If P1 holds, he prefers P2 over P2 (that is, at least
two experienced members), so that the committee recommendations carry more weight. If P1 holds,
he prefers P2 to P2 (that is, all but one are inexperienced) so that it would be easier to influence
their decision. The president unconditionally prefers to have at least one liberal, that is, he prefers
P3 to P3 , so as to give the appearance of balance. However, P3 is less important than both P1 and
P2 . There is an additional “external” constraint (or possibly a preference) that the total number of
members be three.2
GAI value functions map the elements of interest (item sets in our case) into real values quantifying theP
relative desirability of these elements. Structure-wise, GAI value functions have the form
U (S) = i=1,...,n Ui (Pi (S)), where each Pi ⊂ P is a subset of properties. For example, the President’s preferences imply the following GAI structure: U (S) = U1 (P1 (S), P2 (S)) + U2 (P3 (S))
because the President’s conditional preferences over P2 ’s value tie P1 and P2 together, but are independent of P3 ’s value. U1 would capture the weight of this conditional preference, combined
with the absolute preference for P1 ’s value. U2 would represent the value of property P3 . We
might quantify these preferences as follows: U1 (P1 , P2 ) = 10, U1 (P1 , P2 ) = 8, U1 (P1 , P2 ) = 2,
U1 (P1 , P2 ) = 5; while U2 (P3 ) = 1, U2 (P3 ) = 0. Of course, infinitely many other quantifications
are possible.
2. Some external constraints, such as this cardinality constraint, can be modeled as a preference with high
value/importance. In fact, this is how we model cardinality constraints in our implementation.

137

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

Q ← {∅}
Sopt ← ∅
while Q contains a set S such that UB(S) > Value(Sopt ) do
S ← argmaxS 0 ∈Q UB(S 0 )
Q ← QS
\ {S 0 | LB(Sopt ) ≥ UB(S 0 )}
Q ← Q {S ∪ {o} | o ∈ S \ S}
S ← argmaxS 0 ∈Q Value(S 0 )
if Value(S) > Value(Sopt ) then
Sopt ← S
end if
end while
return Sopt
Figure 1: Subset-space branch-and-bound search for an optimal subset of available items S.

3. Finding an Optimal Subset
In general, given a preference specification and a set S of available items, our goal is to find an
optimal subset Sopt ⊆ S with respect to the preference specification. That is, for any other set
S 0 ⊆ S, we have that the properties Sopt satisfies are no less desirable than the properties S 0 satisfies.
We now consider two classes of algorithms for finding such an optimal subset. These two classes
of algorithm differ in the space in which they search. In the next section, we describe a comparative
empirical evaluation of these algorithms. For our running example we use the following set of
available items S:
o1
o2
o3
o4

Republican
Republican
Democrat
Democrat

conservative
ultra conservative
conservative
liberal

inexperienced
experienced
experienced
experienced

3.1 Searching in Sets Space
The most obvious approach for generating an optimal subset is to search directly in the space of
subsets. A priori this approach is not too attractive, and indeed, we shall see later that our implementation of this approach did not scale up. However, given that often we are interested in sets of
small size and that heuristics can be used to enhance search quality, we thought it is worth exploring
this approach.
A branch-and-bound (B&B) algorithm in the space of sets is depicted in Figure 1. For each set
S, the algorithm assumes access to an upper bound UB(S) and to a lower bound LB(S) estimates on
the maximal value of a superset of S. The algorithm maintains a queue Q of sets, and this queue is
initialized to contain only the empty set. At each step, the algorithm selects a highest upper-bound
set S from the queue. Next, the algorithm removes from Q all sets S 0 with upper bound UB(S 0 )
being at most as good as the lower bound LB(S) of the selected set S, and adds to Q all the minimal
(that is, one-item) extensions of S. The latter sets correspond to the successors of S in the search
space. Different implementations of the algorithm differ in how they sort the queue. The best-first
version depicted in the pseudo-code sorts the queue according to a heuristic value of the set, and in
138

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

our case this heuristic is an upper bound on the value of the set’s supersets. In contrast, the depthfirst version always positions the children of the newly expanded node at the front of the queue. We
implemented and tested both versions.
The method used to generate bounds for a set S must depend on the actual preference representation formalism, as well as on the type of set properties being used, and the idea is more natural
given a quantitative value function. For a lower bound LB(S) we can use the actual value Value(S)
of S. Note that it is possible that all descendants of S will have lower values because, in general,
set-properties may not be monotonic (e.g., “average value higher than 5.”) However, since S itself
is a possible solution, this is a valid lower bound.
For an upper bound, we proceed as follows: First, we consider which set-property values are
consistent with S. That is, for each set property, we examine what values S and any of its supersets
can potentially provide to that property. For example, consider P2 and suppose S contains a single
experienced member. So currently, P2 holds. However, we can satisfy P2 if we add one more
experienced member. Thus, both values of P2 are consistent with S. In contrast, if we had two
experienced members in S, then P2 is inconsistent with S because no matter who we add to S,
we can never satisfy P2 . Next, given such sets of possible set-properties’ values with respect to
the set S, we can bound the value of S and of any of its supersets by maximizing values locally.
Specifically, in a GAI value function, we can look at each local function Ui , and consider which
assignment to it, from among the consistent values, would maximize Ui . Clearly, this may result
in an overall value overestimation, since we do not know whether these “locally optimizing” joint
assignments are consistent. Similar ideas can be used with other quantitative representations, as
in various soft-constraint formalisms (Bistarelli, Fargier, Montanari, Rossi, Schiex, & Verfaillie,
1999).
Consider our running example with the GAI value function as at the end of Section 2, and
consider searching for an optimal subset of S = {o1 , o2 , o3 , o4 } using a depth-first version of B&B.
We start with the empty set, and the property values provided by the empty set are P1 , P2 , P3 . Thus,
the lower bound LB(∅), which is the value of the empty-set, is 5. For the upper bound UB(∅), we
consider the best property values that are individually consistent with the extensions of ∅, which
are P1 , P2 , P3 , and their accumulative value is 11. Sopt is also initialized to the empty set, and
next we generate all of the children of the (only possible) selected set ∅, which are all singleton
sets: {o1 }, {o2 }, {o3 }, {o4 }. Except for {o4 }, they all have lower and upper bounds identical to
those of the empty set, and are inserted into the queue. {o4 } has a lower bound of 6 and the upper
bound is 11. Suppose {o1 } is the first queue element, and we select it for expansion. This results in
adding {o1 , o2 }, {o1 , o3 }, {o1 , o4 } into the queue, and the lower and upper bounds of these sets are
(8, 11), (8, 11), (6, 11), respectively. Next, the set {o1 , o2 } is examined with respect to the current
Sopt = ∅, and Sopt is assigned to {o1 , o2 }. Since we assumed here a depth-first version of B&B we
proceed with expanding {o1 , o2 }, obtaining {o1 , o2 , o3 }, {o1 , o2 , o4 } with lower and upper bounds
being, respectively, (10, 11) and (11, 11). With a lower bound of 11 for {o1 , o2 , o4 } we can prune
away all the rest of the nodes in the queue, and we are done.
An important issue for depth-first B&B is the order in which sets are generated. In our implementation, at each node in the search space, the items in S are ordered according to the sum of the
value of the properties they can help satisfy. For example, initially, a conservative member such as
o1 could help us satisfy P1 .
In contrast to quantitative preference representation formalisms, qualitative preferences typically induce a partial ordering over property collections. In this case, it is harder to generate strict
139

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

upper and lower bounds – as they must be comparable to any possible solution. One way to handle
this is to linearize the ordering and require the stronger property of optimality with respect to the
resulting total order. Here, TCP-nets present themselves as a good choice because there is an efficient and simple way of generating a value function consistent with an acyclic TCP-net (Brafman
& Domshlak, 2008). This value function retains the structure of the original network which is important to make the bounds computation efficient (notably, each Ui depends on a small number of
property values).
3.2 Searching over CSPs
The attractiveness of the item subsets is evaluated in terms of a fixed collection of set-properties P,
and thus different sets that provide all identical property values are equivalent from our perspective.
The immediate conclusion is that considering separately such preferentially equivalent subsets of
available items S is redundant. To remove this redundancy, we suggest an alternative method in
which we search directly over set-property value combinations. Of course, the problem is that given
a set-property value combination, it is not obvious whether we can find an actual subset of S that
has such a combination of properties. To answer this question, we generate a CSP that is satisfiable
if and only if there exists a subset of S with the considered set-property values. The overall search
procedure schematically works as follows.
1. Systematically generate combinations of set-property values.
2. For each such combination, search for a subset of S providing that combination of setproperty values.
3. Output a subset of S satisfying an optimal (achievable) combination of set-property values.
To make this approach as efficient as possible, we have to do two things, namely:
(1) Find a way to prune sub-optimal set-property value combinations as early as possible.
(2) Given a set-property value combination, quickly determine whether a subset of S satisfies this
combination.
Considering the first task, let P1 , . . . , Pk be an ordering of the set-properties P.3 Given such
an ordering of P, we incrementally generate a tree of property combinations. The root of that tree
corresponds to an empty assignment to P. For each node n corresponding to a partial assignment
P1 = p1 , . . . , Pj = pj , and for every possible value pj+1 of the property Pj+1 , the tree contains
a child of n corresponding to the partial assignment P1 = p1 , . . . , Pj = pj , Pj+1 = pj+1 . The
tree leaves correspond to (all) complete assignments to P. Such a tree for our running example
is depicted in Figure 2. Note that, implicitly, each node in this tree is associated with a (possibly
empty) set of subsets of S, notably, the subsets that provide the set-property value combination
associated with that node.
In our search for an optimal set, we expand this tree of set-property value combinations while
trying to expand as few tree nodes as possible by pruning certain value combinations of P as either
3. Throughout this paper, we will assume that in preference specifications using TCP nets, there are only conditional
preference (CP) arcs, and importance arcs, but no conditional importance (CI) arcs. While our scheme and implementations allow these arcs, CI arcs force the ordering of the set properties to be dynamic, as it may depend on value
assignments to previous properties. For clarity of exposition, we thus preferred not to present these technical details.

140

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

∅

P¯1

P1

P1 P2 P3

P¯1 P¯2

P1 P¯2

P1 P2
P1 P2 P¯3

P1 P¯2 P3 P1 P¯2 P¯3

P¯1 P¯2 P3

P¯1 P2

P¯1 P¯2 P¯3 P¯1 P2 P3

P¯1 P2 P¯3

Figure 2: Illustration of a search tree for our running example.
sub-optimal with respect to set preferences, or unsatisfiable with respect to S. A standard way
to do this is, again, by using a branch-and-bound search procedure, and this requires from us to
derive effective upper and lower bounds on the value of the best subset satisfying a partial value
combination for P. In addition, the order we associate with properties and their values affects our
pruning ability throughout the search process. To get the most leverage out of our bounds, we
would like to explore the children of a node in the decreasing order of their purported attractiveness.
Moreover, when fixing the ordering of the set-properties themselves, we would like properties that
can potentially contribute more to appear earlier in this ordering. For instance, P1 ’s value in our
running example has a greater influence on the overall attractiveness of a subset than the value of
P2 , and thus P1 should better be branched on first. In addition, P1 is preferred to be true, and thus
the subtree corresponding to P1 = true should better be explored first. Similarly, P2 is preferred to
be true when P1 = true, and preferred to be false, otherwise. This ordering is reflected in the tree
in Figure 2, for a left to right pre-order traversal of the tree.
Now, let us consider the second task of determining whether a subset of S satisfies a given setproperty value combination. Given such a partial assignment α to P, we set up the following CSP.
First, the CSP has a boolean variable xi for every available item oi ∈ S. In our example, the CSP
contains the variables x1 , . . . , x4 for items o1 , . . . , o4 respectively. Intuitively, xi = 1 encodes oi
being a part of our (searched for) subset of S, whereas xi = 0 means that oi is not in that subset.
Next, we translate every set-property value in α into a certain constraint on these variables. For
instance, if α[P1 ] = true, the constraint C1 : x1 + x2 + x3 ≥ 2 is added to the CSP. Note that
C1 explicitly encodes the requirement (of P1 = true) for the subset to have at least two of the
elements that satisfy Republican ∨ conservative. That is because {o1 , o2 , o3 } are all the candidates
in S that are either Republican or conservative. Alternately, if α[P1 ] = f alse, then the constraint
C1 : x1 + x2 + x3 < 2 is added to the CSP. Finally, if α does not specify a value for P1 , then no
constraints related to P1 should be added at all. Likewise, for α[P2 ] = true and α[P3 ] = true we
would add the constraints C2 : x2 + x3 + x4 ≥ 2 and C3 : x4 ≥ 1, respectively. In general, it
is not hard to verify that the CSP constructed this way for a concrete item set S and a set-property
value combination α is solvable if and only if S has a subset satisfying α. Moreover, if this CSP is
solvable, then any of its solutions explicitly provides us with such a subset of S.
It is worth briefly pointing out the difference between the CSPs we generate here and the more
typical CSPs usually discussed in the literature. Most work on general CSPs deals with constraints
141

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

over small, typically just two-variable, subsets of problem variables. In contrast, the constraints
in the CSPs generated in our optimization process are global, with each constraint being possibly defined over all the CSP variables. Yet another special property of CSPs constructed for our
purposes is that there is a sense in which it is meaningful to talk about partial assignments in our
context—unassigned variables can always be regarded de facto as if assigned the value “0” since
the corresponding items, by default, do not belong to the subset we search for.
Because partial assignments to set-properties P map to CSPs, each node in our tree of setproperty value combinations maps to a CSP, and the entire tree can be viewed as a tree of CSPs.
The important property of this tree-of-CSPs is that the children of each CSP node are CSPs obtained
by adding one additional constraint to the parent CSP, notably the constraint corresponding to the
additional property value that we want the set to satisfy. This implies that if some CSP node in
the tree is unsatisfiable, then all of its descendants are unsatisfiable as well. In fact, we can make
a stronger use of the nature of this search tree, recognizing that we can reuse the work done on a
parent node to speed up the solution of its children. To see the latter, consider some CSP C in our
tree-of-CSPs, some child CSP C 0 of C , and let S ⊆ S be a solution to C . As C 0 extends C with
a constraint C, any subset S 0 ⊆ S ruled out by C will be also ruled out by C 0 . Hence, if solving
C and C 0 considers subsets of S in the same order (that is, by using the same ordering over set
elements), then solving C 0 can start from the leaf node corresponding to S, the solution generated
for C . Moreover, if a constraint C represents a boolean set property, and S is not a solution to
C 0 = C ∪ {C}, then S has to be a solution to C ∪ {¬C}, which is the sibling of C 0 . Using these
ideas, we share the work done on different CSP nodes of our tree-of-CSPs. In fact, when all set
properties are boolean, this approach needs to backtrack over each property at most once (we call
this property “limited backtracking”), thereby considerably improving the empirical performance
of the algorithm.
The overall branch-and-bound algorithm in the space of CSPs is depicted in Figure 3. As is,
the algorithm is formulated for the case of quantitative preference formalisms. The formulation
of the algorithm for the qualitative case is essentially the same, with minor technical differences
and an important computational property. For CP/TCP-nets, we can guarantee that only limited
backtracking is required if we follow the following guidelines. First, we must order the variables
(line 1) in an order consistent with the topology of the network. Note that for TCP-nets, this ordering
may be conditional, that is, the order of two variables may vary depending on the value of some of
the earlier variables. Second, in line 2, the property values must be (possibly partially) ordered
from best to worst, given the values of the parent properties (which must be and will be instantiated
earlier). In that case, the first satisfiable set of properties constitutes an optimal choice (Brafman
et al., 2006a). Assuming we solve intermediate nodes in the tree-of-CSPs, we know that we should
backtrack at most once in each level assuming boolean set-properties, but, again, more backtracks
may occur with integer-valued properties.
The node data structure used by the algorithm has two attributes. For a search node n,
• n.α captures a partial assignment to the set-properties P associated with the node n, and
• n.S captures a subset of S satisfying n.α if such exists, and otherwise has the value false.
The functions Value, LB, and UB have the same semantics as in the subset-space search algorithm
in Figure 1. In the pseudocode we assume a fixed ordering over set-property values (line 2), but
one can vary it depending on earlier values (and we exploit that in our implementation). Finally, the
142

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:

Fix an ordering over set-properties P
Fix an ordering over the values of each set property P ∈ P
Fix an ordering over all available items S
Q ← {n[∅; ∅]}
Sopt ← ∅
while Q is not empty do
n ← pop(Q)
construct-and-solve-csp(n)
if n.S 6= f alse and UB(n.S) > Value(Sopt ) then
if Value(n.S) > Value(Sopt ) then
Sopt ← n.S
end if
Let P be the highest-ordered set property unassigned by n.α
for each possible value p of P do
n0 ← [n.α ∪ {P = p}; n.S]
Q ← Q ∪ {n0 }
. The position of n0 in Q depends on the search strategy
end for
end if
end while
return Sopt
Figure 3: CSP-space branch-and-bound search for an optimal subset of available items S.

pseudo-code leaves open the choice of search strategy for used by the branch-and-bound, and this
choice is fully captured by the queue insertion strategy in line 16.
To illustrate the flow of the algorithm, let us consider again our running example. Recall that
the example already has a requirement for the discovered subset to be of size 3, and this translates
into a constraint C : x1 + x2 + x3 + x4 = 3. The first CSP we consider has {C, C1 } as its only
constraints. Assume the CSP variables are ordered as {x1 , x2 , x3 , x4 }, with value 1 preceding value
0 for all xi . In that case, the first solution we find is S1 : x1 = 1, x2 = 1, x3 = 1, x4 = 0. Our
next CSP adds the constraint C2 . When solving this CSP, we continue to search (using the same
order on the xi ’s and their values) from the current solution S1 , which turns out to satisfy C2 as
well. Thus, virtually no effort is required to solve this CSP. Next, we want to also satisfy C3 . This
set of constraints corresponds to a leaf node in the tree-of-CSPs which corresponds to the complete
assignment P1 P2 P3 to the set-properties. Our current item set Sopt = S1 does not have a liberal,
so we have to continue to the assignment S2 : x1 = 1, x2 = 1, x3 = 0, x4 = 1 (requiring us to
backtrack in the CSP-solution space over the assignments to x4 and x3 ). We now have a set that
satisfies the properties in the leftmost leaf node in our tree-of-CSPs. If we can prove that this setproperty value combination is optimal using our upper/lower bounds, we are done. Otherwise, we
need to explore additional nodes in our tree-of-CSPs. In the latter case, the next CSP will correspond
to P1 , P2 , P3 , with constraints {C, C1 , C2 , C3 }. However, we already have a solution to this node,
and it is exactly S1 . To see that, note that S1 was a solution to the parent of our current CSP, but
it was not a solution to its sibling {C, C1 , C2 , C3 }. Hence, since P3 is a boolean property, S1 must
satisfy {C, C1 , C2 , C3 }.

143

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

3.3 Solving the underlying CSPs
Our algorithm for solving the intermediate CSPs is based on the well known backtrack-search algorithm, first presented by Prosser (1993) in a simple iterative form. At the same time, we have
adapted both the algorithm and some well known enhancements in CSP solving (such as NoGood
recording and forward checking (FC)) to the specifics of the CSPs in our setting.
Initially, variables and their values are statically ordered from the most to least constrained
(although we also discuss a few experiments performed with dynamic variable/value ordering). Our
motivation for static ordering is two-fold. First, because the constraints are very much global, we
can do the ordering at a preprocessing stage. Second, as discussed in the previous section, static
ordering allows us to better utilize solutions of CSPs when solving descendent CSPs.
The basic backtrack algorithm, which on its own, unsurpisingly performs quite poorly in our
setting, is refined by utilizing the following observations and techniques.
• Monotonicity of improving constraints. If the operator of the constraint is “=” and there
are more items having the constrained property already in the current partial solution, then
one cannot satisfy the constraint by making additional assignments. The same property holds
for the constraint operators “< ” and “≤”. Using this observation, it is possible to detect the
need to backtrack early on in the search.
• Forward Checking. A certain type of “forward checking” can be performed for our constraints. Clearly, if satisfying some constraint requires at least k items to be added to the
subset, and the number of remaining items that satisfy the desired property is less than k, then
the search algorithm must backtrack.
• “Can/Must” strategy. The “can/must” strategy corresponds to a more advanced check of the
interactions between the constraints. The idea is quite simple: if (i) at least p items must be
added to the constructed subset to satisfy the constraint Ci , (ii) at most q items can be added
to the constructed subset without violating another constraint Cj , (iii) all the items that can
be added and have the property constrained by Ci also have the property constrained by Cj ,
and, finally, (iv) p > q, then both Ci and Cj cannot be satisfied simultaneously. Moreover, no
further assignments to yet unassigned variables can resolve this conflict, and thus the situation
is a dead end. This kind of reasoning allows discovery of such barren nodes quite early in the
search, pruning large portions of the search tree. To reason correctly about the “can/must”
strategy, we have to maintain a data structure of unique items for each pair of constraints, as
well as to keep track of the number of remaining items that influence property constrained by
Ci and do not influence properties constrained by Cj .
As an example, assume we are in the middle of the search and we have two set properties:
SP1 : |A1 = a| ≥ 5 and SP2 : |A2 = b| ≤ 3. Suppose that we have already picked 3 items
that influence SP1 and 2 items that influence SP2 . As a result, to satisfy SP1 , we must add
at least another two items that influence it and to satisfy SP2 we can add at most one item
that influences SP2 . If all the items that we can choose from {ok ...on } have a value “a” for
the attribute A1 and value “b” for the attribute A2 , then obviously we cannot satisfy both SP1
and SP2 within this setting, and thus we should backtrack.
Finally, below we discuss recording NoGoods, an improvement of the basic backtracking algorithm
that proved to have the most impact in our setting.
144

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

3.3.1 N O G OOD R ECORDING
The standard definition of a NoGood in the CSP literature is that of a partial assignment that cannot
be extended into a full solution of the problem. Once we learn a NoGood, we can use it to prune
certain paths in the search tree. The smaller the NoGood, the more occasions we can use it, the
greater its pruning power. Thus, it is of interest to recognize minimal NoGoods, and different
techniques have been developed to perform NoGood resolution in order to produce the best and most
general NoGoods possible (see, e.g., Dechter, 1990; Schiex & Verfaillie, 1993; Dago & Verfaillie,
1996).
As noted earlier, the CSPs we generate differ significantly from the more typical binary CSPs.
Consequently, the NoGood recording algorithm has to be adapted accordingly. In particular, because our constraints are global, it makes sense to try generating NoGoods that are global, too.
Thus, instead of recording assignments to variables, we record the influence of the current assignment on the constraints. Every variable influences a set of constraints.4 Thus, as a NoGood, we
store the influence the set selected so far has on all the constraints. Specifically, suppose we have
generated the set S1 , and recognized that it is not extensible into a set satisfying the constraints.
(This immediately follows from the fact that we backtracked over this set.) We now generate a NoGood N that records for each property associated with each constraint, how many items satisfying
that property occur in S1 . Now, suppose we encounter a different set S2 that has the same effect
N on the constraints. If there are fewer options to extend S2 than there are to extend S1 , we know
that S2 , as well, cannot be extended into a solution. However, if there are more options to extend
S2 than S1 , we cannot conclude that S2 is a NoGood at this point. In order to better quantify the
options that were available to extend S1 we record, beyond the actual NoGood N , the level (depth)
in the assignment tree at which it was generated. Given that the CSP solver uses a static variable
ordering, we know that if we encounter a set S that generates the same properties as the NoGood
N , at a level no higher than that of S1 , we can safely prune its extensions. The reason for that is,
there are no additional extension options available for S than there were for S1 .
The correctness of the NoGood recording mechanism proposed here depends on having a static
variable ordering, as well as a specific value ordering for all the variables in the CSP, namely,
h1, 0i. To show correctness, we should note that a NoGood can be used only after it is recorded.
Consequently, any node using a NoGood would be to the right in the search tree of a node the
NoGood was recorded at. Here we would like to stress again that, since the constraints are global,
it does not matter which items are added to the subset, but rather what influence these items had on
the constraints. Any two sets having exactly the same influence on the constraints are identical with
respect to the optimization process.
3.3.2 S EARCH A LGORITHM
The procedure depicted in Figure 4 extends the basic backtrack algorithm by a subroutine C AN I M PROVE which can be altered to include any combination of the in-depth checks discussed earlier,
to utilize early conflict detection techniques, including the NoGoods check. Also added is a call to
the A DD N O G OOD subroutine for recording NoGoods while backtracking. P and n, the generated
instance of a CSP problem with variables indexed from 1 to |S| and the node in the tree-space search
4. We assume without loss of generality that every item in the set of available items influences at least one constraint in
the constraint set C , since items that influence no constraint can be safely eliminated.

145

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

respectively, are the inputs to the procedure. The algorithm systematically tries to assign values to
the problem variables, backtracking and recording NoGoods when facing a dead end.
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:

consistent ← n.S satisfies n.α
while not(consistent) do


if H AS VALUES(P .vars[i]) and C AN I MPROVE(P ) then
P.i ← L ABEL(P.i, consistent) . If current CSP variable has available values, try to set, update consistency
else

A
DD N O G OOD (P ,i)
. Record NoGood


P.i ← U NLABEL(P.i)
. Backtrack
end if
if P.i = 0 then
. If backtracked over the first indexed variable — no solution available
return false
end if
end while
return true
Figure 4: Conflict backtrack algorithm with NoGood recording

4. Experimental Results
We evaluate the different algorithms using a subset of the movie database publicly available from
imdb.com. We simulated a scenario of selecting movies for a three-day film festival according to
organizers preferences. Three models of growing complexity have been engineered to reflect the
preferences of the organizers; these models are defined in terms of 5, 9, and 14 set-properties, respectively. In addition, the total number of films is constrained to be 5 (which we actually modeled
using a very strong preference). Figure 5 depicts the list P14 of the 14 properties and their alterations; P5 and P9 consist of the corresponding prefixes (SP1 through SP5 , and SP1 through SP9 ,
respectively) of P14 . To produce even more complex problem instances that cause many backtracks
in the space of set-property assignments we slightly altered the 14-properties model, creating two
0 and P 00 .
additional models that are denoted henceforth as P14
14
4.1 Preference Specification
Figure 6 provides a verbal description of qualitative preferences for the film festival program which
we used in our experiments. Figure 7 depicts a TCP-net that encodes these preferences in terms of
the more concrete set-properties listed in Figure 5. For the experiments with GAI value functions,
these preferences were quantified by compiling this TCP-net into a GAI value function that orders
the items consistently with that TCP-net (Brafman & Domshlak, 2008). The task in our empirical
evaluation was to find an optimal subset of a set of available movies S ∈ {S400 , S1000 , S1600 , S3089 },
where Si corresponds to a set of i movies, and that with respect to each of the five models of
preferences over sets. All the experiments were conducted using Pentium 3.4 GHz processor with
2GB memory running Java 1.5 under Windows XP Professional. The runtimes reported in the tables
below are all in seconds, with “–” indicating process incompletion after four hours.

146

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

SP1 = h|Year ≥ 2002| = 5i
SP2 = h|Genre = Comedy| ≥ 2i
SP3 = h|Genre = Thriller| ≤ 3i
SP4 = h|Genre = Family| > 1i
SP5 = h|Color = B&W| > 1i
SP6 = h|Director = Spielberg| ≥ 1i
SP6 ∗ = h|Director = Spielberg| ≤ 1i
SP7 = h|Sound = Mono| ≥ 2i
SP8 = h|Genre = War ∨ Genre = Film-noir| = 0i

SP8 ∗ = h|Genre = War ∨ Genre = Film-noir| ≥ 4i
SP8 ∗∗ = h|Genre = Film-noir| ≥ 4i
SP9 = h|Location = North America| > 1i
SP10 = h|Actor = Famous ∨ Actress = Famous| = 5i
SP11 = h|Actress = Famous| ≥ 2i
SP12 = h|Genre = Drama| ≥ 2i
SP13 = h|Release Date < 1970| ≤ 1i
SP14 = h|Net Profit ≥ 1000000| ≥ 2i
SP14 ∗∗ = h|Net Profit ≥ 1000000| ≥ 5i

Figure 5: Set-properties used in modeling user preferences in the movies selection domain.
∗

0
Alteration of P14 , to achieve more backtracking - denoted as P14

∗∗

0
00
Further alteration of P14
to achieve even more backtracking - denoted as P14

1. I prefer new movies to old movies, and therefore prefer that all movies be from 2002 or later, and this is important
to me.
2. I love comedies, thrillers and family movies.
3. I prefer not to have too many movies in black and white (not more than one such movie).
4. If all the movies are new (after 2002) then I would prefer to have at least 2 comedies.
5. If I can find at least 2 comedies then I also prefer to have more than 1 family movie, but less then 3 thrillers.
However having the right number of family movies is more important to me than having the right number of
thrillers.
6. If not all the movies are new, I prefer to have at least 2 movies in black and white for the vintage touch.
7. If not all the movies are new, I prefer at least one movie to be directed by Steven Spielberg, but otherwise, I don’t
like his newer films
8. If the previous condition holds, then the number of movies with mono sound may be greater than 2.
9. I prefer not to have any war films or film-noir in the festival. However if this condition can not be satisfied,
then I prefer not to have any films that were filmed in North America and this is more important to me than my
preferences about the movie being in color or in B&W.
10. To draw more attention, I prefer all 5 movies to have famous actors or actresses.
11. To highlight female roles, I prefer at least 2 movies with a famous actress.
12. I prefer to have at least 2 dramas because people tend to think dramas are more sophisticated movies than any
other genre.
13. I prefer to have at least one classical movie.
14. I prefer to have at least one commercially successful movie, i.e. a movie whose net profit was more than one
million dollars.

Figure 6: Informal description of the assumed preferences for selecting a set of movies for a film
festival program.

First, our initial experiments quickly showed that the search in the space of subsets (Table 1)
does not scale up. With just over 20 elements, it did not converge to an optimal solution within an
hour, even when the preference specification involved only 5 set-properties. This outcome holds for
all combinations of qualitative and quantitative preference specifications, depth-first and best-first
schemes of branch-and-bound, and queue ordering based on set’s upper bound, lower bound, and

147

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

weighted combinations of both. Table 1 provides a snapshot of the corresponding results for a TCPnet specified over nine set properties. The table describes the total number of subsets generated
until an optimal subset was found (see the column “Subset until Sopt ”), the total number of subsets
generated until the optimal subset was recognized as optimal (under “Subsets generated”). DFS appears to be much more effective than BFS, but the branching factor of larger databases overwhelms
this approach. Also, it may be thought that with larger databases it should be easier to quickly
generate good sets, but we found that for moderately larger (e.g,. 25+) and much larger (e.g., 3000)
datasets, this approach is too slow. Various improvements may be possible, but given the much
better performance of the other approach discussed later, they are unlikely to make a difference.

SP2 : SP4 ≻ SP4
SP2 : SP4 ≻ SP4

SP2 : SP3 ≻ SP3
SP2 : SP3 ≻ SP3

SP1 : SP2 ≻ SP2
SP1 : SP2 ≻ SP2

SP1 ≻ SP1

SP3

SP2

SP1

SP4

SP5

SP6

SP8

SP1 ∧ SP6
SP1 ∧ SP6
SP1 ∧ SP6
SP1 ∧ SP6

:
:
:
:

SP7
SP7
SP7
SP7

SP9

SP14

SP7 ∧ SP9
SP7 ∧ SP9
SP7 ∧ SP9
SP7 ∧ SP9

:
:
:
:

SP14
SP14
SP14
SP14

SP8 : SP9 ≻ SP9
SP8 : SP9 ≻ SP9

SP8 ∧ SP9
SP8 ∧ SP9
SP8 ∧ SP9
SP8 ∧ SP9

:
:
:
:

SP12
SP12
SP12
SP12

≻ SP12
≻ SP12
≻ SP12
≻ SP12

SP12

≻ SP7
≻ SP7
≻ SP7
≻ SP7

SP1 : SP6 ≻ SP6
SP1 : SP6 ≻ SP6

SP1 : SP5 ≻ SP5
SP1 : SP5 ≻ SP5

SP8 ≻ SP8

SP7

SP13

SP11

SP9 : SP13 ≻ SP13
SP9 : SP13 ≻ SP13

SP10 : SP11 ≻ SP11
SP10 : SP11 ≻ SP11

≻ SP14
≻ SP14
≻ SP14
≻ SP14

SP10
SP14 : SP10 ≻ SP10
SP14 : SP10 ≻ SP10

Figure 7: TCP-net model of preference over sets of movies for the film festival program.
Next, we consider the CSP-space branch-and-bound search. In particular, here we compared
between the two variants of this approach that use dynamic and static variable and value orderings.
In what follows, these two variants are denoted as BB-D and BB-S, respectively. While static
variable/value orderings are usually considered to be a weaker approach to CSP solving, earlier
we have shown that, in our domain, static ordering allows for certain optimizations that have a
potential to improve the efficiency of the overall problem solving. In particular, static variable
ordering allows to record global NoGoods as described in Section 3.3.1; the results for algorithms
that record NoGoods are denoted by a name suffix “+ng”. In addition, we have tried to share

148

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

S8
S8
S10
S10
S15
S15
S20
S20

Method
BFS
DFS
BFS
DFS
BFS
DFS
BFS
DFS

Subsets until Sopt
18
83
40
672
7879
11434
28407
28407

Subsets generated
4075
630
15048
2935
104504
30547
486079
231616

Time (sec)
0.56
0.19
2.34
0.47
68.23
3.13
1584.67
28.578

Table 1: A snapshot of the results for subsets-space search. The preferences here are specified by a
TCP-net over nine set properties.
Method

S400

S1000

S1600

S3089

P5
P5
P5
P5
P5

BB-D
BB-S
BB-S+inc
BB-S+ng
BB-S+ng+inc

0.3
0.14
0.05
0.17
0.05

0.77
0.14
0.1
0.1
0.11

1.30
0.17
0.12
0.15
0.13

4.02
0.25
0.18
0.21
0.19

P9
P9
P9
P9
P9

BB-D
BB-S
BB-S+inc
BB-S+ng
BB-S+ng+inc

0.43
0.14
0.06
0.17
0.06

1.42
0.24
0.14
0.25
0.14

2.42
0.26
0.17
0.34
0.18

6.58
0.34
0.15
0.35
0.17

P14
P14
P14
P14
P14

BB-D
BB-S
BB-S+inc
BB-S+ng
BB-S+ng+inc

0.66
0.17
0.06
0.3
0.1

2.03
0.43
0.15
0.57
0.19

4.69
1.09
0.43
1.06
0.38

14.92
0.78
0.5
0.95
0.54

0
P14
0
P14
0
P14
0
P14

BB-S
BB-S+inc
BB-S+ng
BB-S+ng+inc

6.5
2.1
16.1
4.68

27.1
27
19.4
18.4

278
259
54.8
76.3

–
–
230.2
210.8

00
P14
00
P14
00
P14
00
P14
00
P14

BB-D
BB-S
BB-S+inc
BB-S+ng
BB-S+ng+inc

4113.48
101.4
81.03
110
107.9

–
5370
5523
269.9
266.8

–
16306
16643
646.1
646.8

–
–
–
3335
3013

Set-properties

Table 2: Empirical results of evaluating the CSP-space search procedures with qualitative preference specification using TCP-nets.

information between consecutive CSP problem instances while doing the search in the tree of CSPs;
the algorithms adopting this technique are denoted by a name suffix “+inc”.
Table 2 depicts the results of the evaluation of all variants of the CSP-space branch-and-bound
search algorithm (Figure 3). First, the table shows that the overhead of maintaining NoGoods does
not pay off for the simple preference specifications. However, for the more complex problems requiring more intense CSP solving, the use of NoGood recording proved to be very useful, letting us

149

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

Method

S400

S1000

S1600

S3089

P5
P9

BB-S
BB-S

0.24
0.16

0.14
0.25

0.17
0.28

0.26
0.41

P14
P14

BB-S+inc
BB-S+ng+inc

38.91
19

2376.40
160.53

–
494.98

–
1349.9

Set-properties

Table 3: Results for the CSP-space search with quantitative preference specification using GAI
value functions.

solve previously unsolvable instances. Next, the reader may notice from the table that, at least for
the problems used in our tests, the contribution of the incremental approach is not substantial. For
instance, NoGood recording by itself seems to contribute much more to the efficiency of the optimization process. Moreover, for the more complex problems, switching to the incremental version
sometimes even leads to performance degradation. It appears that the overhead of maintaining and
copying the partial solution in these cases does not pay off.
Our next set of experiments mirrored the first one, but now with GAI value functions instead
of the purely qualitative TCP-nets. The GAI functions were obtained by properly quantifying the
qualitative preferences used for the first tests. Table 3 provides a representative snapshots of the
results. With value functions over set-properties P5 and P9 the basic branch-and-bound algorithm
with static variable/value orderings performs and scales up (with growing set of alternatives S) quite
well. With the more complex value functions over the larger set of properties P14 the performance
significantly degrades, and even the incrementality-enhanced algorithm cannot solve problem instances with more than 1000 CSP variables. On the other hand, adding NoGoods recording proves
to dramatically improve the performance, leading to solving even the largest problem instances.
Tables 2 and 3 suggest a qualitative difference in the performance of the CSP-space search with
quantitative and qualitative preference representation models. There are good reasons to expect
such behavior. First, compact qualitative models of preference may (and typically do) admit more
than one optimal (that is, non-dominated) solution. That, in principle, makes finding one such
optimal solution easier. Second, if the preferences are captured by a TCP-net, then there are variable
orderings ensuring that the first solution found will be an optimal one. In contrast, with GAI value
functions, after we generate an optimal solution, typically we still have to explore the search tree to
prove that no better solution exists. In the worst case, we have to explore the entire tree of CSPs,
forcing us to explore a number of CSPs that is exponential in |P|.
In summary, the first conclusion to be taken from our experiments is that subsets-space search
fails to escape the trap of the large branching factor, while the stratified procedures for CSP-space
search show a much higher potential. On the problems that require little backtracking in the space of
CSPs, the latter procedures are actually very effective for both TCP-net and GAI function preference
specification. Obviously, if the procedure is forced to explore many different CSPs, the performance
unavoidably degrades. We note that, on larger databases, such backtracks often indicate an inherent
conflict between desirable set-properties, and such conflicts might possibly be recognized and resolved off-line. In this work we do not investigate this issue, leaving it as an optional direction for
future improvement.
The rather non-trivial example used in this section provides the reader also with the opportunity
to assess the suitability of different preference specification languages. For example, although we

150

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

used boolean-valued set properties, it may be argued that some of our natural-language preference
statements would better be expressed using integer-valued set properties. Similarly, users may find
that some other preference specification formalism, such as soft-constraints (Bistarelli et al., 1999),
can more naturally capture these natural language preferences. This is an opportunity for us to
reemphasize that while, for obvious reasons, we had to focus on a concrete choice of language, we
believe that the two-tiered approach suggested here is far more general.

5. Complexity Analysis
Though reasonable runtimes have been obtained by us empirically with search over CSPs, both
algorithm classes described above have a worst-case exponential running time. This begs the question of whether the problem itself is computationally hard. Obviously, with external constraints,
subset optimization is NP-hard. Below we show that even without external constraints, the problem
typically remains NP-hard, even with significant restrictions on the problem.
Naturally, the complexity of subset selection depends on the precise nature of the preference
specification formalism used. Most of the results presented here assume TCP-net-based specification. Hardness results for this model immediately apply to the GAI model, based on an existing
reduction (Brafman & Domshlak, 2008). In some cases, problems that are tractable under the TCPnet model become NP-hard when a GAI model is used, instead. Thus, unless stated otherwise, we
assume henceforth that preferences over properties are specified by a TCP-net.
In analyzing the complexity of the problem we consider the following problem parameters:
• n, the overall number of items in the data set.
• a, the number of attributes of the items.
• m, the number of set properties, i.e. number of nodes in the TCP-net.
• k, maximal property formula size, defined as the number of logical connectives (and, or, not)
in the formula.
• d maximum attribute domain size, i.e. the maximum number of distinct values for each
attribute.
• µ, the number of times an attribute value can appear in the dataset.
5.1 NP-Hard Classes
Theorem 1. When using TCP-based preferences over set properties, finding an optimal subset of a
given set of items (POS) is NP-hard even if the items are described only in terms of binary-valued
attributes, and all the set properties are atomic (that is, we have d = 2 and k = 0).
Proof. The proof is by a polynomial reduction from the well-known NP-hard Vertex Cover (VC)
problem. Given a graph G = (V, E), a vertex cover of G is a vertex subset V 0 ⊆ V covering all the
edges in the graph, that is, for every edge e ∈ E, there is a vertex v ∈ V 0 such that e is incident on
v. The optimization version of VC corresponds to finding a minimal size vertex cover of G.
Given an VC problem instance G = (V, E), we construct a POS problem instance by specifying a TCP-net N and an item set S as follows. For each vertex v ∈ V we create an item o (denoted
151

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

Pe1 ≻ Pe1

Pe2 ≻ Pe2

Pe3 ≻ Pe3

Pe1

Pe2

Pe3

Pek ≻ Pek
...

Pek

SUM
SUM = 0 ≻ SUM=1 ≻ SUM=2 ≻ . . . ≻ SUM=n

Figure 8: TCP-net in the reduction from VC to POS in the proof of Theorem 1.
by ov ), and thus we have |S| = |V | = n items. For each edge e ∈ E we define an attribute X
(denoted by Xe ), and thus we have |X | = |E| = a attributes. All the attributes in X are defined
to have a binary, {0, 1}, domain. For each item ov , the value of each attribute Xe is ov [Xe ] = 1
if and only if e is incident on v in G. Next, for each edge e ∈ E, we define a binary set property
Pe = h|Xe | > 0i that takes the value true if and only if at least one item in the selected subset provides the value 1 to the attribute Xe . In addition, we define a single multi-valued empty set property
SUM ≡ h||i5 . The domain of the SUM property is defined to be the integer-value range [0..n].
Note that, by construction, the properties utilize only one attribute per property, and thus no logical
connectives, providing us with k = 0. The preferences over these set properties are
1. For each binary property Pe , the preference is for the value true, that is, Pe  Pe .
2. For the empty property SUM we simply prefer smaller values, that is
(SUM = 0)  (SUM=1)  (SUM=2)  . . .  (SUM=n)
The only edges in the TCP-net N , depicted in Figure 8, are the importance arcs from each Pe to
SUM, meaning that we would rather have to temporize in the value of the SUM property than have
any of the Pe being f alse.
Proposition 1 ensures that any optimal subset in the POS problem constructed as above always
corresponds to a proper vertex cover of G.
Proposition 1. For any subset S of S that is undominated with respect to the constructed TCP-net
N , and every edge e ∈ E, we have Pe (S) = true.
Proof. Given an undominated (with respect to N ) subset S ⊆ S, let Pe be a set property such that
Pe (S) = f alse. By construction, there exists an item o ∈ S such that o[Xe ] = 1. Considering
S 0 = S ∪ {o}, we have S 0 being preferred to S with respect to N because (i) S and S 0 provide
exactly the same values to all the set properties except for Pe and SUM, (ii) S provides a preferred
5. Since the formula ϕ inside this set property is degenerate, and in fact equivalent to h|true|i, every item in the selection
set will have to comply with it. This set property is the simplest implementation of a counter

152

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

value to SUM while S 0 provides a preferred value to Pe , and (iii) preferential improvement of Pe
dominates that of SUM. Thus S 0 dominates S, contradicting the assumption that S is undominated.
Lemma 1. For any subset S of S that is undominated with respect to the constructed TCP-net N ,
there exists a vertex cover VS of G with |VS | = |S|.
Proof. The proof is straightforward. Let VS = {v | ov ∈ S}. Because S is undominated with
respect to N , from Proposition 1 we have Pe (S) = true for all binary “edge-related” properties
Pe . In turn, Pe (S) = true implies that o[Xe ] = 1 for at least one item o ∈ S. By the construction,
o[Xe ] = 1 if and only if vertex v covers edge e. Together with the mapping between the vertices V
and items S being bijective, the latter implies |VS | = |S|.
Lemma 2. There exists a minimal vertex cover of G of size s if and only if there exists a subset
S ⊆ S undominated with respect to N such that SUM(S) = s.
Proof. Let S be an undominated subset of S with |S| = s. By construction, we have Pe (S) = true
for all binary set properties Pe , and SUM(S 0 ) = s. By Lemma 1, there exists a vertex cover VS
of G with |VS | = s. Suppose to the contrary that VS is not minimal, that is, there exists a vertex
cover V 0 of G with |V 0 | < s. Now, construct the subset S 0 = {ov | v ∈ V 0 }. Since the mapping
between S and V is bijective, we have |S 0 | = |V 0 | < s, and thus SUM(S 0 ) < s. Likewise, by
construction of our set properties and V 0 being a vertex cover, we have Pe (S) = true for all Pe .
This, however, implies that S 0 is preferred to S with respect to N , contradicting the statement that
S is undominated.
Theorem 1 now follows immediately from Lemma 2 and the fact that the reduction is clearly
polynomial.
Theorem 2. Given TCP-based preferences over set properties, finding an optimal subset of a given
set of items (POS) is NP-hard even if the items are described in terms of a single attribute, all the
set properties are binary-valued, each containing at most 2 logical connectives (that is, we have
a = 1 and k = 2).
Proof. The proof is by a polynomial reduction from k-SAT, for any k ≥ 3. Given a k-SAT problem
instance over propositional variables V and logical formula Φ, we construct a POS problem instance by specifying a TCP-net N and an item set S as follows. For each variable v ∈ V , construct
an item ov and an item ov̄ , and thus S contains an item for every possible literal in the formula. The
value of the only attribute X is defined as follows: for each item ol , we have A(ol ) = l (where l is a
literal, either v or v̄, for all v ∈ V ). The binary set properties P for the TCP-net N are now defined
as follows.
• Properties ensuring that a variable assignment is legitimate. For each variable v ∈ V ,

Pv =h|X = v ∨ X = v̄| = 1i,
that is, for any S ⊆ S, Pv (S) = true if and only if S contains exactly one of the items
{ov , ov̄ }.
153

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

• Properties ensuring that Φ is satisfied. For each clause C = (l1 ∨ l2 ∨ l3 ∨ ...) ∈ Φ:
PC =h|X = l1 ∨ X = l2 ∨ X = l3 ∨ ...| ≥ 1i
that is, for any S ⊆ S, PC (S) = true if and only if S contains at least one item corresponding
to a literal in C.
Finally, to complete the preference specification, we make all properties independent (that is, the
TCP-net has no edges), and for each of the properties we prefer value true to value false.
To illustrate the above construction, consider a 3-SAT formula Φ = (x ∨ y ∨ z) ∧ (y) ∧ (x ∨ z).
For this formula, the construction leads to
item
ox
ox
oy
oy
oz
oz

X
x
x̄
y
ȳ
z
z̄

Set properties:
Px =h|X = x ∨ X = x| = 1i
Py =h|X = y ∨ X = y| = 1i
Pz =h|X = z ∨ X = z| = 1i
PC1 =h|X = x ∨ X = y ∨ X = z| ≥ 1i
PC2 =h|X = y| ≥ 1i
PC3 =h|X = x ∨ X = z| ≥ 1i

We now show that finding an undominated subset of S with respect to N as above is equivalent
to finding a satisfying assignment to Φ. Let S ⊆ S be undominated with respect to N . We can show
that S provides value true to all set propositions Pv and PC (in this case we call S an ultimately
preferred subset) if and only if Φ is satisfiable.
First, let S be an ultimately preferred subset of S. Given such S, we can construct a mapping
A : V 7→ {true, f alse} such that A(v) = true if ov ∈ S, and A(v) = f alse if ov̄ ∈ S. Note
that A is well-defined because, for an ultimately preferred subset S, all Pv (S) = true, and thus,
for each v ∈ V , exactly one item from {ov , ov̄ } is present in S. Clearly, A is a legal assignment for
Φ. In addition, we have all PC (S) = true. Thus, for each clause C ∈ Φ, at least one item with
X = li ∈ C belongs to S. By construction, this implies that A satisfies all the clauses in Φ, and
thus Φ is satisfiable.
Converesly, suppose that S ⊆ S is preferentially undominated with respect to N , but is not
ultimately preferred. If our POS problem has such an undominated subset S, we show that Φ is
unsatisfiable. Assuming the contrary, let A be a satisfying assignment of Φ. Given A, we construct
a subset SA ⊆ S as SA = {ol | literal l ∈ A}, and show that SA dominates S with respect to N
(contradicting the assumed undominance of S, and finalizing the proof of Theorem 2).
By construction, since A is a legal assignment to V , we have Pv (SA ) = true for all set properties Pv . Also, since A is a satisfying assignment for Φ, we have PC (SA ) = true for all set
properties PC . Therefore, SA is actually an ultimately preferred subset of S. Finally, since all the
set properties P are preferentially independent in N , and value true is always preferred to value
f alse for all the set properties, we have that SA dominates S with respect to N .
Notice that Theorems 1 and 2 do not subsume each other. Theorem 1 poses no restriction on the
number of item attributes in the problem instance, but does restrict the domain of all the attributes.
Theorem 2 restricts the number of attributes to 1, but has no restriction on the domain size of this
attribute, and its restriction on the property size is looser than that imposed in Theorem 1.
154

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

Finally, we note that tightening the condition of Theorem 2, by allowing only at most 1 connective in each set-property definition prevents us from using the same reduction as in the proof
of Theorem 2 because the respectibe satisfiability problems would be the polynomial-time solvable
2-SAT problems. Our conjecture, however, is that this fragment of POS is still NP-hard. In fact, in
Section 5.3 we show that the corresponding fragment of POS with the GAI preference specification
(instead of TCP-nets) is indeed NP-hard.
5.2 Tractable Classes
Several tractable classes of POS, obtained by further restricting the problem class discussed in
Theorem 2, and characterized by single-attribute item description (that is, a = 1), are discussed
below. In both trivially tractable (Section 5.2.1) and non-trivially tractable (Section 5.2.2) cases, we
assume that the relational symbols are either equalities or inequalities, that in the specification of
a property only equalities (“attribute = value”) are used, and in addition we do not allow an empty
set property to be specified. The latter restriction is due to the fact that the empty set property is
somewhat special, as it enriches the descriptive power by allowing one to simulate an additional
attribute in certain cases, and the single-attribute restriction is crucial for our tractability result.
Before we proceed with the actual results, note that, with a single-attribute item description, no
two set properties can be in a conflict that demands backtracking while choosing items (i.e. during
CSP solution). To illustrate such conflicts, consider the following examples.
1.

1.a h|A = ai | ≤ 5i
1.b h|A = ai | ≤ 3i

Set property 1.a is redundant, subsumed by 1.b

2.

2.a h|A = as | = 5i
2.b h|A = as | > 6i

One of these set properties must be false.

3.

3.a h|A = al | < 7i
3.b h|A = al | ≥ 9i

One of these set properties must be false.

All such conflicts between set-properties can be resolved offline, prior to the actual process of subset
selection, totally disregarding the available items. Hence, within the process of subset selection, we
assume that there are no conflicts between set properties. Consequently, subset selection can be
done in a greedy manner.
5.2.1 T RIVIALLY T RACTABLE C LASS
Theorem 3. Finding an optimal subset of a given set of items (POS) with respect to a TCP-net
preference specification is in P if the items are described in terms of a single attribute, and all the
set properties are atomic (that is, we have a = 1 and k = 0).
An algorithm for the problem class in Theorem 3 is depicted in Figure 9. The algorithm runs in
time O(m2 n), where m is the number of set properties and n is the number of available items S.
The for loop in line 4 of the algorithm iterates over all the set properties, each time checking compatibility with the previously considered properties, which requires Θ(m2 ) time. The procedures
G ET S ATISFYING S ET (·) and H AS S ATISFYING S ET (·) have to process each item in S only once.
Hence, the total running time of the algorithm is O(m2 n).6
6. This runtime analysis does not include the ordering of the TCP-net variables that is assumed to be given. One way to
do that would be a topological sort of the net, that obviously can be done in polynomial time.

155

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:

Sopt ← ∅
Fix a preference ordering over set properties P
Pass ← ∅
for each property P ∈ P do
while (not (P .isSatisfied)) do
if P is in conflict with Pass then
Set next value to P w.r.t. Pass
else
if H AS S ATISFYING S ET(P ) then
Sopt ← Sopt ∪ G ET S ATISFYING S ET(P )
P .isSatisfied ← true
Pass ← Pass ∪ {P }
end if
end if
end while
end for
return Sopt
procedure G ET S ATISFYING S ET(P )
S←∅
for each item o ∈ S do
if o has the property value defined by P then
S ← S ∪ {o}
end if
if |S| P .op P .cardinality then
return S
end if
end for
end procedure

. Offline conflict resolution

. If cardinality of S satisfies P

Figure 9: A polynomial-time algorithm for the POS problems with TCP-net preference specification, single-attribute item description, and all the set properties being atomic (that is,
a = 1 and k = 0).

5.2.2 N ON -T RIVIALLY T RACTABLE C LASS
At the end of Section 5.1 we have mentioned that the complexity of POS under limiting the setproperty description to at most one logical connective is still an open problem. If, however, we
impose the limitations summarized in Table 4, we can show that the problem becomes tractable.
Theorem 4. Finding an optimal subset of a given set of items (POS) with respect to a TCP-net
preference specification is in P if it is restricted as in Table 4.
First we should discuss the implicit limitations (or special problem properties) that are imposed
by the explicit limitations listed in Table 4.
156

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

1. All the items have only one attribute (a = 1)
2. All the property formulas have at most 1 connective (k = 1), and are positive (that is, we
disallow negation)
3. The empty property is disallowed
4. The number of attribute value appearances is limited to at most µ = 1 (that is, values in the
attribute domain cannot be repeated)
Table 4: Characteristics of the tractable subclass of POS presented in Section 5.2.2.
1. The restriction to at most one attribute-value appearance in the data set provides a one-toone correspondence between attribute values and items in S. This means that each item can
uniquely represent a specific attribute-value combination, and vice versa.
2. The restriction to a single-attribute item description renders the “∧” connective redundant.
That is because the properties using the “∧” logical connective can only be of the form:
X = xi ∧ X = xj .
(Without loss of generality we assume i 6= j, or otherwise we can simply drop one of the
terms.) These properties obviously cannot be satisfied because no item can have two different
values for the only attribute X. In fact, set properties defined this way are equivalent to a
property that is always f alse.
3. The only relevant cardinalities for the set properties are [0..2]. A property defined using only
one connective with the restriction on the number of repetitions is not expressive enough to
state a set property involving more than 2 items. If the value in a set property:
h|A = ai ∨ A = aj |

op

valuei

is greater than 2, and op ∈ {≥, >}, then again it cannot be satisfied. If the op of a property is
≤ or <, and the value is greater than 2, then it can be substituted by an effectively equivalent
set property with op being ≤ and value = 2 .
The algorithm for the problem class in Theorem 4 is depicted in Figure 10. This algorithm bears
some similarity to the algorithm in Figure 9, except that here the procedures G ET S ATISFYING S ET
and H AS S ATISFYING S ET reason simultaneously about satisfaction of collections of set-property
values, and do that by utilizing 2-SAT solving. Specifically, in Table 5 we show how any valid
property in such a POS problem can be translated into a 2-SAT CNF formula. In Lemma 3 we
prove the correctness of this translation. We should note that by using 2-SAT we can have an
answer to the question “Is there a subset of items satisfying some already evaluated set-property
values”. The procedures G ET S ATISFYING S ET and H AS S ATISFYING S ET use the aforementioned
reduction to 2-SAT to provide the answer in polynomial time.
Lemma 3. There is a subset S satisfying all the property-values Pass if and only if there is a
satisfying assignment A to the 2-SAT formula constructed from Pass .
157

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

h|X
h|X
h|X
h|X
h|X
h|X

= xi | > 2i ⇒ infeasible
= xi | ≥ 2i ⇒ infeasible
= xi | ≥ 1i ⇒ substituted by
= xi | = 1i and translated to (vi ) clause
= xi | ≥ 0i ⇒ translated to (vi ∨ v¯i ) clause
= xi | = 0i ⇒ translated to (v¯i ) clause
Properties having 0 logical connectives

h|X = xi ∨ X = xj | > 2i ⇒ infeasible
h|X = xi ∨ X = xj | ≥ 2i ⇒ substituted by
h|X = xi ∨ X = xj | = 2i and translated to (vi )
and (vj ) clauses
h|X = xi ∨ X = xj | ≥ 1i ⇒ translated to
(vi ∨ vj ) clause
h|X = xi ∨ X = xj | = 1i ⇒ translated to
(vi ∨ vj ) and (v¯i ∨ v¯j ) clauses
h|X = xi ∨ X = xj | ≥ 0i ⇒ translated to
(v¯i ∨ v¯j ) clause
h|X = xi ∨ X = xj | = 0i ⇒ translated to (v¯i )
and (v¯j ) clauses
Properties having 1 logical connective

Table 5: Translation of the set properties for the POS subclass in Section 5.2.2 to 2-SAT.
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:

Fix a preference ordering over set properties P
Sopt ← ∅
Pass ← ∅
for each property P ∈ P do
while (not (P .isSatisfied)) do
Set next value to P w.r.t. Pass
if H AS S ATISFYING S ET(Pass ) then
Sopt ← G ET S ATISFYING S ET(Pass )
P .isSatisfied ← true
Pass ← Pass ∪ {P }
end if
end while
end for
return Sopt

. Use reduction to 2-SAT
. Use reduction to 2-SAT

Figure 10: A poly-time algorithm for the POS problems with TCP-net preference specification,
and characteristics as in Table 4.

Proof. By construction, we have an injective correspondence between the properties in the POS
problem and clauses in the 2-SAT problem. Every property P ∈ P injectively corresponds to a
certain clause ϕP . Every item o ∈ S injectively corresponds to a propositional variable vi ∈ V .
Thus, the correspondence between the selected subset S and the assignment A is simply
vi = true ⇔ o ∈ S.

158

(1)

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

Because the translation is injective and rather straightforward (without introducing any auxiliary
clauses or properties), it is trivial that S is a subset that satisfies all the properties in Pass if and only
if A is an assignment that satisfies all the clauses in the corresponding 2-SAT formula.
The above shows correctness of the algorithm in Figure 10, and finalizes the proof of Theorem 4.
5.3 Complexity of POS: TCP-nets vs. GAI Preference Specification
With the restrictions as in Table 4 we were able to show that the POS problem with TCP-net
preference specification is tractable by reduction to 2-SAT, because there is no need to backtrack
while searching in the attribute value space. An interesting question is, what if the specification
were done using GAI functions?
Theorem 5. Finding an optimal subset of a given set of items (POS) with respect to a GAI preference specification is NP-hard even if the items are described in terms of a single attribute, all the set
properties are binary-valued, each containing at most 1 logical connective (that is, we have a = 1
and k = 1).
Proof. The proof is by a polynomial reduction from MAX-2SAT. As far as item definitions and
properties are concerned, the reduction is essentially the same as the reduction from k-SAT in the
proof of Theorem 2. That is, for each variable v ∈ V , construct an item ov and an item ov̄ . The
value of the only attribute X is defined as follows: for item ol , we have A(ol ) = l (where l is a
literal, either v or v̄, for all v ∈ V ). Set properties are also as in the proof of Theorem 2, but now
they are limited to only 2 variables per clauses (re-stated for convenience below):
• For each variable v ∈ V :

Pv =h|X = v ∨ X = v̄| = 1i,
that is, properties ensuring that a variable assignment is legitimate.
• For each clause C = (l1 ∨ l2 ) ∈ Φ:

PC =h|X = l1 ∨ X = l2 | ≥ 1i,
that is, properties ensuring that Φ is satisfied.
The value function specification is such that legitimate variable assignments are enforced, and a
larger number of clauses satisfied is preferred. This is achieved by using an additively independent
value function (i.e., where each factor contains a single variable), with values being as follows.
Each clause-satisfying property has a value of 1 for being true, and 0 for being f alse. Each literalsatisfying property has a value of 0 for being true, and a negative value of −2m for being f alse,
where m is the number of clauses.
Lemma 4. Given a GAI value function and item set S constructed as above for a 2-CNF formula
Φ, there exists a subset S ⊆ S with value of U (S) = p if and only if there exists an assignment A
satisfying p clauses in Φ.
159

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

Proof. Let S be any subset of S that has non-negative value. This implies by construction (since
there are only m clause-satisfying properties PC ) that all literal-satisfying properties must be true
for S, and the respective assignment AS can be constructed as in Equation 1. Conversely, let A
be a legitimate assignment to the variables V . One can define a corresponding set SA , for which
(by construction) all properties Pv are true. Also, observe that by construction the number of PC
set properties that are true on SA is the same as the number of clauses satisfied by the assignment
A.
The theorem follows immediately from the properties of the construction of the set properties
and preferences.
At the end of Section 5.1 we have noted that if the restrictions on the problem parameters are
more severe than in Theorem 2, by limiting the number of logical connectives per set property to
at most 1, we can no longer show whether the problem is tractable or NP-hard under the TCPnet preference specification. However, Theorem 5 shows that, with preferences specified using a
GAI value function, the problem is in fact NP-hard. Moreover, the problem class from Theorem
5 subsumes the class from Theorem 4, and thus provides an additional result showing that even
though with the TCP-net specification the respective problem is tractable, with a GAI preference
specification it becomes NP-hard.

6. Related Work
In the introduction, we mentioned the closely related work of desJardins and Wagstaff (2005). In
that approach, the motivation to provide the user with a diverse collection of values is either to
reflect the set of possible choices better for applications where the user must eventually select a
single item, or when the diversity of the selected set is an objective on its own. The work of Price
and Messinger (2005) is explicitly concerned with this problem. Specifically, they consider the
problem of recommending items to a user, and view it as a type of subset selection problem. For
example, suppose we want to recommend a digital camera to a user. We have a large set of available
cameras, and we are able to recommend k cameras. Price and Messinger consider the question
of how to select this set, proposing that the candidate set will maximize the expected value of the
user’s choice from this set. They suggest a concrete algorithmic approach for handling this problem.
The input to their problem is some form of partial representation of the user’s preferences (which
can be diverse, as in our work) and naturally, the concrete techniques are different from ours. Both
these papers share the assumption on ranking sets, common to most previous work as discussed
by Barberà et al. (2004), that ultimately one item will be selected from this set. However, they
do not necessarily start out with an initial ranking over single items, and as in our case, the work
of desJardins and Wagstaff utilizes the attribute value of items in the selection process.
Earlier work on ranking subsets was motivated by problems such as the college admissions
problem (Gale & Shapley, 1962), where we need to select the best set of fixed cardinality among a
pool of college candidates. The admissions officer has various criteria for a good class of students
and wishes to come up with an optimal choice. Some of the key questions that concerned this line
of work were what are good properties of such set rankings and whether they have some simple
representation. An example of a property of the set ranking that may be desirable is the following:
given a set S, if we replace some member c ∈ S with some other member c0 to obtain the set S 0 ,
and c0 is preferred to c, then S 0 is preferred to S. An example of a representation of the ranking
160

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

is an additive representation where items are associated with real values and one set is preferred to
another if the sum of its elements’ values is larger. It would be interesting to study similar question
in our context of structured objects.
This question of ranking sets appears in other areas, such as logics of preference and likelihood.
For example, the main question considered by Halpern (1997) is how to construct an ordering over
formulas based on an ordering over truth assignments. Formulas are associated with the set of
worlds in which they are satisfied, and hence, the question of comparing the likelihood of formulas
ψ and φ corresponds to that of ranking their respective set of models given the initial ranking on
single models. Much work on non-monotonic logics uses Shoham’s preference semantics (Shoham,
1987), and semantically, such work (see, e.g., Kraus, Lehmann, & Magidor, 1990) can be viewed as
attempting to answer the opposite question – define a ranking over single truth assignments given
some, possibly partial, ordering over formulas, i.e., sets of models.
A number of lines of work are related to our specification and solution methods. The first is
the work on Russian Doll Search (RDS), a well known algorithm for combinatorial optimization,
originally presented by Verfaillie, Lemaı̂tre, and Schiex (1996) as an efficient algorithm for Constraint Optimization Problems (COP). The idea behind the approach is to solve consecutively harder
problems. Initially, the problem is solved while considering only one variable. The optimal result
provides a lower bound. Each iteration, additional variables are considered, until eventually the original problem is solved. By using the lower bound obtained from the previous iteration (and other
optimizations) this technique is often able to solve the original problem more efficiently. Recently
Rollon and Larrosa (2007) extended Russian Doll Search to support multi-objective optimization
problems. In a multi-objective optimization problem the goal is to optimize several parameters
(attributes) of the variables in the problem. Usually all the parameters cannot be simultaneously
optimized. The technique of Rollon and Larrosa involves incremental solution with more and more
objectives included, and, in this sense, it is related to our search over CSPs approach in which we
incrementally consider more and more set properties. Indeed, different desirable set properties can
be viewed as different objectives.
Another related area is that of Pseudo-Boolean Constraint (PBC) Satisfaction Problems (Sheini
& Sakallah, 2005). A PBC has the form:
X
wi li ≥ k.
i

Here the li ’s are literals and we interpret their values as being either 0 (false) or 1 (true); the wi are
real-valued coefficients; and k is an integer. Thus Pseudo-Boolean CSPs are a special form of integer programs, and can nicely represent the cardinality constraints we generate. Thus, one option for
solving the type of CSPs generated here would be using a dedicated PBC solver. We run several popular PBC solvers on the satisfiability instances generated during the optimization: Pueblo (Sheini &
Sakallah, 2005), MiniSat (Eén & Sörensson, 2005), and Galena (Dixon & Ginsberg, 2002). These
solvers showed comparable results for satisfiable cases, while for the unsatisfiable cases, the PBC
solvers showed better performance. This appears to be due to their use of linear programming as a
preliminary test for satisfiability.
Another line of work that bears important connection to ours is that of winner determination
in combinatorial auctions. In regular auctions, bidders bid for a single item. In combinatorial auctions, bidders bid on bundles of items. Thus, bidders must provide their preferences over different
subsets of the set of auctioned items. The goal in combinatorial auctions is to allocate the set of
161

B INSHTOK , B RAFMAN , D OMSHLAK , & S HIMONY

goods to different bidders in the best manner (e.g., maximizing the payment to the seller or maximizing total welfare). This differs from the problem of selecting a single optimal subset with which
we are concerned. However, in both cases, preferences over subsets must be provided to the optimization algorithm. As the number of subsets is exponential in the number of items, researchers in
combinatorial auctions have sought bidding languages that can succinctly describe preferences of
interest (Boutilier & Hoos, 2001; Nisan, 2006). What distinguishes our specification approach is
its reliance on the existence of item features and the desire to provide a generic specification that
does not depend on the concrete set of items. Work in combinatorial auctions also attempts to break
the specification in some way. This is typically done by specifying values for small bundles and
providing rules for deriving the value of larger sets from the values of the smaller sets.

7. Conclusion
We suggested a simple, yet general approach to lifting any attribute-based preference specification
formalism to one for specifying preferences over sets. We then focused one instantiation of this idea
via a concrete language for specifying set properties, and suggested two methods for computing an
optimal subset given such a specification. One method is based on searching the space of explicit
subsets, while the other searches over implicit subsets represented as CSPs. Both search spaces
are meaningful regardless of the specific underlying preference specification algorithm although the
precise search and bounds generation method will vary. We focused on two concrete and popular
specification formalisms, one qualitative and one quantitative, on which we experiment and provide complexity results. Although the problem is generally NP-hard, as expected, the experimental
results are quite encouraging.
We wish to reemphasize that other choices, both for the set property language and the preference specification formalism are possible, and may be more appropriate in various cases. Indeed,
an interesting topic for future research would be to see which choices fit best some natural application areas; whether and how the algorithm presented in this paper can be modified to handle such
languages; and how the complexity of the optimal subset selection problem is affected by such
choices.
Though incremental search over CSPs appears to be the better method for optimal subset selection, it leaves a few questions open. First, it is an interesting question whether an efficient NoGood
recording scheme that does not rely on static variable and value orderings exists. Intuitively, such
a scheme should exist since the CSPs generated can be efficiently encoded into SAT as a boolean
CNF formula (Bailleux & Boufkhad, 2004; Eén & Sörensson, 2005), and clause learning is a well
known technique in SAT solving. Second, we have seen that while the incremental approach usually
improves the overall performance, its contribution is not substantial and what really improves the
performance is better individual CSP solving. This begs two questions: (1) Can we better utilize solutions across CSPs, and (2) Would representing and solving the CSPs generated as pseudo-boolean
CSPs (Manquinho & Roussel, 2006) or SAT instances lead to faster solution times? Naturally,
alternative approaches are also feasible.
Finally, in various applications, the set of elements gradually changes, and we need to adapt
the selected subset to these changes. An example is when we use this approach to choose the
most interesting current articles, and new articles constantly appear. It is likely that in this case the
preferred set is similar to the current set, and we would like to formulate an incremental approach
that adapts to such changes quickly.

162

G ENERIC P REFERENCES OVER S UBSETS OF S TRUCTURED O BJECTS

Acknowledgments
Preliminary versions of this work appeared in (Brafman, Domshlak, Shimony, & Silver, 2006b;
Binshtok, Brafman, Shimony, Mani, & Boutilier, 2007). The authors wish to thank our anonymous
reviewers for their useful comments and suggestions. Brafman was supported in part by NSF grant
IIS-0534662, Brafman and Domshlak were supported by the COST action IC0602, Binshtok, Brafman and Shimony were supported by Deutsche Telekom Laboratories at Ben-Gurion University, by
the Paul Ivanier Center for Robotics Research and Production Management, and by the Lynn and
William Frankel Center for Computer Science.

