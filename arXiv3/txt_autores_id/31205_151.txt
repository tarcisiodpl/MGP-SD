
Inspired by the recently introduced framework of AND/OR search spaces for graphical models, we propose to augment Multi-Valued Decision Diagrams (MDD) with AND nodes, in order
to capture function decomposition structure and to extend these compiled data structures to general weighted graphical models (e.g., probabilistic models). We present the AND/OR Multi-Valued
Decision Diagram (AOMDD) which compiles a graphical model into a canonical form that supports polynomial (e.g., solution counting, belief updating) or constant time (e.g. equivalence of
graphical models) queries. We provide two algorithms for compiling the AOMDD of a graphical
model. The first is search-based, and works by applying reduction rules to the trace of the memory
intensive AND/OR search algorithm. The second is inference-based and uses a Bucket Elimination
schedule to combine the AOMDDs of the input functions via the the APPLY operator. For both
algorithms, the compilation time and the size of the AOMDD are, in the worst case, exponential in
the treewidth of the graphical model, rather than pathwidth as is known for ordered binary decision
diagrams (OBDDs). We introduce the concept of semantic treewidth, which helps explain why
the size of a decision diagram is often much smaller than the worst case bound. We provide an
experimental evaluation that demonstrates the potential of AOMDDs.

1. Introduction
The paper extends decision diagrams into AND/OR multi-valued decision diagrams (AOMDDs)
and shows how graphical models can be compiled into these data-structures. The work presented in
this paper is based on two existing frameworks: (1) AND/OR search spaces for graphical models
and (2) decision diagrams.
1.1 AND/OR Search Spaces
AND/OR search spaces (Dechter & Mateescu, 2004a, 2004b, 2007) have proven to be a unifying
framework for various classes of search algorithms for graphical models. The main characteristic is
the exploitation of independencies between variables during search, which can provide exponential
speedups over traditional search methods that can be viewed as traversing an OR structure. The
c 2008 AI Access Foundation. All rights reserved.

M ATEESCU , D ECHTER & M ARINESCU

AND nodes capture problem decomposition into independent subproblems, and the OR nodes represent branching according to variable values. AND/OR spaces can accommodate dynamic variable
ordering, however most of the current work focuses on static decomposition. Examples of AND/OR
search trees and graphs will appear later, for example in Figures 6 and 7.
The AND/OR search space idea was originally developed for heuristic search (Nilsson, 1980).
In the context of graphical models, AND/OR search (Dechter & Mateescu, 2007) was also inspired
by search advances introduced sporadically in the past three decades for constraint satisfaction and
more recently for probabilistic inference and for optimization tasks. Specifically, it resembles the
pseudo tree rearrangement (Freuder & Quinn, 1985, 1987), that was adapted subsequently for distributed constraint satisfaction by Collin, Dechter, and Katz (1991, 1999) and more recently by
Modi, Shen, Tambe, and Yokoo (2005), and was also shown to be related to graph-based backjumping (Dechter, 1992). This work was extended by Bayardo and Miranker (1996) and Bayardo and
Schrag (1997) and more recently applied to optimization tasks by Larrosa, Meseguer, and Sanchez
(2002). Another version that can be viewed as exploring the AND/OR graphs was presented recently for constraint satisfaction (Terrioux & Jégou, 2003b) and for optimization (Terrioux & Jégou,
2003a). Similar principles were introduced recently for probabilistic inference, in algorithm Recursive Conditioning (Darwiche, 2001) as well as in Value Elimination (Bacchus, Dalmao, & Pitassi,
2003b, 2003a), and are currently at the core of the most advanced SAT solvers (Sang, Bacchus,
Beame, Kautz, & Pitassi, 2004).
1.2 Decision Diagrams
Decision diagrams are widely used in many areas of research, especially in software and hardware
verification (Clarke, Grumberg, & Peled, 1999; McMillan, 1993). A BDD represents a Boolean
function by a directed acyclic graph with two terminal nodes (labeled 0 and 1), and every internal
node is labeled with a variable and has exactly two children: low for 0 and high for 1. If isomorphic
nodes were not merged, we would have the full search tree, also called Shannon tree, which is the
usual full tree explored by a backtracking algorithm. The tree is ordered if variables are encountered
in the same order along every branch. It can then be compressed by merging isomorphic nodes
(i.e., with the same label and identical children), and by eliminating redundant nodes (i.e., whose
low and high children are identical). The result is the celebrated reduced ordered binary decision
diagram, or OBDD for short, introduced by Bryant (1986). However, the underlying structure is
OR, because the initial Shannon tree is an OR tree. If AND/OR search trees are reduced by node
merging and redundant nodes elimination we get a compact search graph that can be viewed as a
BDD representation augmented with AND nodes.
1.3 Knowledge Compilation for Graphical Models
In this paper we combine the two ideas, creating a decision diagram that has an AND/OR structure, thus exploiting problem decomposition. As a detail, the number of values is also increased
from two to any constant. In the context of constraint networks, decision diagrams can be used to
represent the whole set of solutions, facilitating solutions count, solution enumeration and queries
on equivalence of constraint networks. The benefit of moving from OR structure to AND/OR is in
a lower complexity of the algorithms and size of the compiled structure. It typically moves from
being bounded exponentially in pathwidth pw∗ , which is characteristic to chain decompositions or
linear structures, to being exponentially bounded in treewidth w∗ , which is characteristic of tree
466

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

structures (Bodlaender & Gilbert, 1991) (it always holds that w∗ ≤ pw∗ and pw∗ ≤ w∗ · log n,
where n is the number of variables of the model). In both cases, the compactness result achieved in
practice is often far smaller than what the bounds suggest.
A decision diagram offers a compilation of a propositional knowledge-base. An extension of
the OBDDs was provided by Algebraic Decision Diagrams (ADD) (Bahar, Frohm, Gaona, Hachtel,
Macii, Pardo, & Somenzi, 1993), where the terminal nodes are not just 0 or 1, but take values from
an arbitrary finite domain. The knowledge compilation approach has become an important research
direction in automated reasoning in the past decade (Selman & Kautz, 1996; Darwiche & Marquis,
2002; Cadoli & Donini, 1997). Typically, a knowledge representation language is compiled into a
compact data structure that allows fast responses to various queries. Accordingly, the computational
effort can be divided between an offline and an online phase where most of the work is pushed
offline. Compilation can also be used to generate compact building blocks to be used by online
algorithms multiple times. Macro-operators compiled during or prior to search can be viewed in
this light (Korf & Felner, 2002), while in graphical models the building blocks are the functions
whose compact compiled representations can be used effectively across many tasks.
As one example, consider product configuration tasks and imagine a user that chooses sequential options to configure a product. In a naive system, the user would be allowed to choose any valid
option at the current level based only on the initial constraints, until either the product is configured,
or else, when a dead-end is encountered, the system would backtrack to some previous state and
continue from there. This would in fact be a search through the space of possible partial configurations. Needless to say, it would be very unpractical, and would offer the user no guarantee of
finishing in a limited time. A system based on compilation would actually build the backtrack-free
search space in the offline phase, and represent it in a compact manner. In the online phase, only
valid partial configurations (i.e., that can be extended to a full valid configuration) are allowed, and
depending on the query type, response time guarantees can be offered in terms of the size of the
compiled structure.
Numerous other examples, such as diagnosis and planning problems, can be formulated as
graphical models and could benefit from compilation (Palacios, Bonet, Darwiche, & Geffner, 2005;
Huang & Darwiche, 2005a). In diagnosis, compilation can facilitate fast detection of possible faults
or explanations for some unusual behavior. Planning problems can also be formulated as graphical
models, and a compilation would allow swift adjustments according to changes in the environment.
Probabilistic models are one of the most used types of graphical models, and the basic query is to
compute conditional probabilities of some variables given the evidence. A compact compilation of a
probabilistic model would allow fast response to queries that incorporate evidence acquired in time.
For example, two of the most important tasks for Bayesian networks are computing the probability
of the evidence, and computing the maximum probable explanation (MPE). If some of the model
variables become assigned (evidence), these tasks can be performed in time linear in the compilation size, which in practice is in many cases smaller than the upper-bound based on the treewidth or
pathwidth of the graph. Formal verification is another example where compilation is heavily used
to compare equivalence of circuit design, or to check the behavior of a circuit. Binary Decision
Diagram (BDD) (Bryant, 1986) is arguably the most widely known and used compiled structure.
The contributions made in this paper to knowledge compilation in general and to decision diagrams in particular are the following:
1. We formally describe the AND/OR Multi-Valued Decision Diagram (AOMDD) and prove it
to be a canonical representation for constraint networks, given a pseudo tree.
467

M ATEESCU , D ECHTER & M ARINESCU

2. We extend the AOMDD to general weighted graphical models.
3. We give a compilation algorithm based on AND/OR search, that saves the trace of a memory
intensive search and then reduces it in one bottom up pass.
4. We present the APPLY operator that combines two AOMDDs and show that its complexity is
at most quadratic in the input, but never worse than exponential in the treewidth.
5. We give a scheduling order for building the AOMDD of a graphical model starting with
the AOMDDs of its functions which is based on a Variable Elimination algorithm. This
guarantees that the complexity is at most exponential in the induced width (treewidth) along
the ordering.
6. We show how AOMDDs relate to various earlier and recent compilation frameworks, providing a unifying perspective for all these methods.
7. We introduce the semantic treewidth, which helps explain why compiled decision diagrams
are often much smaller than the worst case bound.
8. We provide an experimental evaluation of the new data structure.
The structure of the paper is as follows. Section 2 provides preliminary definitions, a description
of binary decision diagrams and the Bucket Elimination algorithm. Section 3 gives an overview of
AND/OR search spaces. Section 4 introduces the AOMDD and discusses its properties. Section
5 describes a search-based algorithm for compiling the AOMDD. Section 6 presents a compilation
algorithm based on a Bucket Elimination schedule and the APPLY operation. Section 7 proves that
the AOMDD is a canonical representation for constraint networks given a pseudo tree, and Section
8 extends the AOMDD to weighted graphical models and proves their canonicity. Section 9 ties
the canonicity to the new concept of semantic treewidth. Section 10 provides an experimental
evaluation. Section 11 presents related work and Section 12 concludes the paper. All the proofs
appear in an appendix.

2. Preliminaries
Notations A reasoning problem is defined in terms of a set of variables taking values from finite
domains and a set of functions defined over these variables. We denote variables or subsets of
variables by uppercase letters (e.g., X, Y, . . .) and values of variables by lower case letters (e.g.,
x, y, . . .). Sets are usually denoted by bold letters, for example X = {X1 , . . . , Xn } is a set of
variables. An assignment (X1 = x1 , . . . , Xn = xn ) can be abbreviated as x = (hX1 , x1 i, . . . ,
hXn , xn i) or x = (x1 , . . . , xn ). For a subset of variables Y, DY denotes the Cartesian product of
the domains of variables in Y. The projection of an assignment x = (x1 , . . . , xn ) over a subset Y
is denoted by xY or x[Y]. We will also denote by Y = y (or y for short) the assignment of values
to variables in Y from their respective domains. We denote functions by letters f , g, h etc., and the
scope (set of arguments) of the function f by scope(f ).
2.1 Graphical Models
D EFINITION 1 (graphical model) A graphical model M is a 4-tuple, M = hX, D, F, ⊗i, where:
468

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

1. X = {X1 , . . . , Xn } is a finite set of variables;
2. D = {D1 , . . . , Dn } is the set of their respective finite domains of values;
3. F = {f1 , . . . , fr } is a set of positive real-valued discrete functions (i.e., their domains can
be listed), each defined over a subset of variables Si ⊆ X, called its scope, and denoted by
scope(fi ).
Q P
4. ⊗ is a combination operator1 (e.g., ⊗ ∈ { , , 1} – product, sum, join), that can take as
input two (or more) real-valued discrete functions, and produce another real-valued discrete
function.
The graphical model represents the combination of all its functions: ⊗ri=1 fi .
Several examples of graphical models appear later, for example: Figure 1 shows a constraint
network and Figure 2 shows a belief network.
In order to define the equivalence of graphical models, it is useful to introduce the notion of
universal graphical model that is defined by a single function.
D EFINITION 2 (universal equivalent graphical model) Given a graphical model M
=
hX, D, F1 , ⊗i the universal equivalent model of M is u(M) = hX, D, F2 = {⊗fi ∈F1 fi }, ⊗i.
Two graphical models are equivalent if they represent the same function. Namely, if they have
the same universal model.
D EFINITION 3 (weight of a full and a partial assignment) Given a graphical model M =
hX, D, Fi, the weight of a full assignment x = (x1 , . . . , xn ) is defined by w(x) =
⊗f ∈F f (x[scope(f )]). Given a subset of variables Y ⊆ X, the weight of a partial assignment
y is the combination of all the functions whose scopes are included in Y (denoted by FY ) evaluated
at the assigned values. Namely, w(y) = ⊗f ∈FY f (y[scope(f )]).
Consistency For most graphical models, the range of the functions has a special zero value “0”
that is absorbing relative to the combination operator (e.g., multiplication). Combining anything
with “0” yields a “0”. The “0” value expresses the notion of inconsistent assignments. It is a primary
concept in constraint networks but can also be defined relative to other graphical models that have a
“0” element.
D EFINITION 4 (consistent partial assignment, solution) Given a graphical model having a “0”
element, a partial assignment is consistent if its cost is non-zero. A solution is a consistent assignment to all the variables.
D EFINITION 5 (primal graph) The primal graph of a graphical model is an undirected graph that
has variables as its vertices and an edge connects any two variables that appear in the scope of the
same function.
The primal graph captures the structure of the knowledge expressed by the graphical model. In
particular, graph separation indicates independency of sets of variables given some assignments to
other variables. All of the advanced algorithms for graphical models exploit the graphical structure,
by using a heuristically good elimination order, a tree decomposition or some similar method. We
will use the concept of pseudo tree, which resembles the tree rearrangements introduced by Freuder
and Quinn (1985):
1. The combination operator can also be defined axiomatically (Shenoy, 1992).

469

M ATEESCU , D ECHTER & M ARINESCU

E

A

A

D

E

B

D
F

B

G

F

C

G
C

(a) Graph coloring problem

(b) Constraint graph

Figure 1: Constraint network
D EFINITION 6 (pseudo tree) A pseudo tree of a graph G = (X, E) is a rooted tree T having the
same set of nodes X, such that every arc in E is a backarc in T (A path in a rooted tree starts at the
root and ends at one leaf. Two nodes can be connected by a backarc only if there exists a path that
contains both).
We use the common concepts and parameters from graph theory, that characterize the connectivity of the graph, and how close it is to a tree or to a chain. The induced width of a graphical model
governs the complexity of solving it by Bucket Elimination (Dechter, 1999), and was also shown to
bound the AND/OR search graph when memory is used to cache solved subproblems (Dechter &
Mateescu, 2007).
D EFINITION 7 (induced graph, induced width, treewidth, pathwidth) An ordered graph is a
pair (G, d), where G = ({X1 , . . . , Xn }, E) is an undirected graph, and d = (X1 , . . . , Xn ) is an
ordering of the nodes. The width of a node in an ordered graph is the number of neighbors that
precede it in the ordering. The width of an ordering d, denoted w(d), is the maximum width over
all nodes. The induced width of an ordered graph, w∗ (d), is the width of the induced ordered graph
obtained as follows: for each node, from last to first in d, its preceding neighbors are connected
in a clique. The induced width of a graph, w∗ , is the minimal induced width over all orderings.
The induced width is also equal to the treewidth of a graph. The pathwidth pw∗ of a graph is the
treewidth over the restricted class of orderings that correspond to chain decompositions.
Various reasoning tasks, or queries can be defined over graphical models. Those can be defined formally using marginalization operators such as projection, summation and minimization.
However, since our goal is to present a compilation of a graphical model which is independent of
the queries that can be posed on it, we will discuss tasks in an informal manner only. For more
information see the work of Kask, Dechter, Larrosa, and Dechter (2005).
Throughout the paper, we will use two examples of graphical models: constraint networks
and belief networks. In the case of constraint networks, the functions can be understood as relations. In other words, the functions (also called constraints) can take only two values, {0, 1}, or
{f alse, true}. A 0 value indicates that the corresponding assignment to the variables is inconsistent (not allowed), and a 1 value indicates consistency. Belief networks are an example of the more
general case of graphical models (also called weighted graphical models). The functions in this case
are conditional probability tables, so the values of a function are real numbers in the interval [0, 1].

470

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Example 1 Figure 1(a) shows a graph coloring problem that can be modeled by a constraint network. Given a map of regions, the problem is to color each region by one of the given colors {red,
green, blue}, such that neighboring regions have different colors. The variables of the problems
are the regions, and each one has the domain {red, green, blue}. The constraints are the relation
“different” between neighboring regions. Figure 1(b) shows the constraint graph, and a solution
(A=red, B=blue, C=green, D=green, E=blue, F=blue, G=red) is given in Figure 1(a). A more
detailed example will be given later in Example 8.
Propositional Satisfiability A special case of a CSP is propositional satisfiability (SAT). A formula ϕ in conjunctive normal form (CNF) is a conjunction of clauses α1 , . . . , αt , where a clause
is a disjunction of literals (propositions or their negations). For example, α = (P ∨ ¬Q ∨ ¬R) is
a clause, where P , Q and R are propositions, and P , ¬Q and ¬R are literals. The SAT problem
is to decide whether a given CNF theory has a model, i.e., a truth-assignment to its propositions
that does not violate any clause. Propositional satisfiability (SAT) can be defined as a CSP, where
propositions correspond to variables, domains are {0, 1}, and constraints are represented by clauses,
for example the clause (¬A ∨ B) is a relation over its propositional variables that allows all tuples
over (A, B) except (A = 1, B = 0).
Cost Networks An immediate extension of constraint networks are cost networks where the set
of functions are real-valued cost functions, and the primary task is optimization. Also, GAI-nets
(generalized additive independence, Fishburn, 1970) can be used to represent utility functions. An
example of cost functions will appear in Figure 19.
D EFINITION
P8 (cost network, combinatorial optimization) A cost network is a 4-tuple,
hX, D, C, i, where X is a set of variables X = {X1 , . . . , Xn }, associated with a set of
discrete-valued domains, D = {D1 , . . . , Dn }, and a set of cost functions C = {C1 , . . . , Cr }. Each
Ci is a real-valued function defined on a subset of variables Si ⊆ X. The combination operator, is
P
. The reasoning problem is to find a minimum cost solution.

Belief Networks (Pearl, 1988) provide a formalism for reasoning about partial beliefs under conditions of uncertainty. They are defined by a directed acyclic graph over vertices representing random
variables of interest (e.g., the temperature of a device, the gender of a patient, a feature of an object, the occurrence of an event). The arcs signify the existence of direct causal influences between
linked variables quantified by conditional probabilities that are attached to each cluster of parentschild vertices in the network.
Q
D EFINITION 9 (belief networks) A belief network (BN) is a graphical model P = hX, D, PG , i,
where X = {X1 , . . . , Xn } is a set of variables over domains D = {D1 , . . . , Dn }. Given a directed acyclic graph G over X as nodes, PG = {P1 , . . . , Pn }, where Pi = {P (Xi | pa (Xi ) ) }
are conditional probability tables (CPTs for short) associated with each Xi , where pa(Xi ) are the
parents of Xi in the
Qacyclic graph G. A belief network represents a probability distribution over X,
P (x1 , . . . , xn ) = ni=1 P (xi |xpa(Xi ) ). An evidence set e is an instantiated subset of variables.
When formulated as a graphical model, functions in F denote conditional probability tables
and the scopes of these functions are determined by the directed acyclic graph G: each function
Q
fi ranges over variable Xi and its parents in G. The combination operator is product, ⊗ = .
The primal graph of a belief network (viewed as an undirected model) is called a moral graph. It
connects any two variables appearing in the same CPT.
471

M ATEESCU , D ECHTER & M ARINESCU

A Season

Sprinkler B

Watering D

A

C Rain

B

F Wetness

D

G Slippery

C

F

G

(a) Directed acyclic graph

(b) Moral graph

Figure 2: Belief network
Example 2 Figure 2(a) gives an example of a belief network over 6 variables, and Figure 2(b)
shows its moral graph . The example expresses the causal relationship between variables “Season”
(A), “The configuration of an automatic sprinkler system” (B), “The amount of rain expected”
(C), “The amount of manual watering necessary” (D), “The wetness of the pavement” (F ) and
“Whether or not the pavement is slippery” (G). The belief network expresses the probability distribution P (A, B, C, D, F, G) = P (A) · P (B|A) · P (C|A) · P (D|B, A) · P (F |C, B) · P (G|F ).
Another example of a belief network and CPTs appears in Figure 9.
The two most popular tasks for belief networks are defined below:
D EFINITION 10 (belief updating, most probable explanation (MPE)) Given a belief network
and evidence e, the belief updating task is to compute the posterior marginal probability of variable
Xi , conditioned on the evidence. Namely,
X

Bel(Xi = xi ) = P (Xi = xi | e) = α

n
Y

P (xk , e|xpak ),

{(x1 ,...,xi−1 ,xi+1 ,...,xn )|E=e,Xi =xi } k=1

where α is a normalization constant. The most probable explanation (MPE) task is to find a
complete assignment which agrees with the evidence, and which has the highest probability among
all such assignments. Namely, to find an assignment (xo1 , . . . , xon ) such that
P (xo1 , . . . , xon ) = maxx1 ,...,xn

n
Y

P (xk , e|xpak ).

k=1

2.2 Binary Decision Diagrams Review
Decision diagrams are widely used in many areas of research to represent decision processes. In
particular, they can be used to represent functions. Due to the fundamental importance of Boolean
functions, a lot of effort has been dedicated to the study of Binary Decision Diagrams (BDDs),
which are extensively used in software and hardware verification (Clarke et al., 1999; McMillan,
1993). The earliest work on BDDs is due to Lee (1959), who introduced the binary-decision program, that can be understood as a linear representation of a BDD (e.g., a depth first search ordering
of the nodes), where each node is a branching instruction indicating the address of the next instruction for both the 0 and the 1 value of the test variable. Akers (1978) presented the actual graphical
472

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

A
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C
0
1
0
1
0
1
0
1

f(ABC)
0
0
0
1
0
1
0
1

A

A

B

C

C

0

C

0

(a) Table

0

B

B

1

0

B

0

1

B

C

1

0

(b) Unordered tree

C

0

0

C

1

0

C

1

0

1

(c) Ordered tree

Figure 3: Boolean function representations
representation and further developed the BDD idea. However, it was Bryant (1986) that introduced
what is now called the Ordered Binary Decision Diagram (OBDD). He restricted the order of variables along any path of the diagram, and presented algorithms (most importantly the apply procedure, that combines two OBDDs by an operation) that have time complexity at most quadratic in the
sizes of the input diagrams. OBDDs are fundamental for applications with large binary functions,
especially because in many practical cases they provide very compact representations.
A BDD is a representation of a Boolean function. Given B = {0, 1}, a Boolean function
f : Bn → B, has n arguments, X1 , · · · , Xn , which are Boolean variables, and takes Boolean
values.
Example 3 Figure 3(a) shows a table representation of a Boolean function of three variables. This
explicit representation is the most straightforward, but also the most costly due to its exponential
requirements. The same function can also be represented by a binary tree, shown in Figure 3(b),
that has the same exponential size in the number of variables. The internal round nodes represent
the variables, the solid edges are the 1 (or high) value, and the dotted edges are the 0 (or low) value.
The leaf square nodes show the value of the function for each assignment along a path. The tree
shown in 3(b) is unordered, because variables do not appear in the same order along each path.
In building an OBDD, the first condition is to have variables appear in the same order (A,B,C)
along every path from root to leaves. Figure 3(c) shows an ordered binary tree for our function.
Once an order is imposed, there are two reduction rules that transform a decision diagram into an
equivalent one:
(1) isomorphism: merge nodes that have the same label and the same children.
(2) redundancy: eliminate nodes whose low and high edges point to the same node, and connect
parent of removed node directly to child of removed node.
Applying the two reduction rules exhaustively yields a reduced OBDD, sometimes denoted
rOBDD. We will just use OBDD and assume that it is completely reduced.
Example 4 Figure 4(a) shows the binary tree from Figure 3(c) after the isomorphic terminal nodes
(leaves) have been merged. The highlighted nodes, labeled with C, are also isomorphic, and Figure
4(b) shows the result after they are merged. Now, the highlighted nodes labeled with C and B are
redundant, and removing them gives the OBDD in Figure 4(c).
2.3 Bucket Elimination Review
Bucket Elimination (BE) (Dechter, 1999) is a well known variable elimination algorithm for inference in graphical models. We will describe it using the terminology for constraint networks, but BE
473

M ATEESCU , D ECHTER & M ARINESCU

A

A

B

B

C

C

C

0

1

A

B

C

B

C

C

0

(a) Isomorphic nodes

B

C

1

0

(b) Redundant nodes

1

(c) OBDD

Figure 4: Reduction rules
A:

A
C1(AC)
C2(AB)
C3(ABE)

B

C

C4(BCD)

h4(A)

B:

C2(AB)

E:

C3(ABE)

A

h3(AB)

h2(AB)

AB bucket-B
AB

ABE

C:
E

D

(a) Constraint network

D:

C1(AC)

h1(BC)

bucket-A

A

bucket-E

AB

ABC bucket-C
BC

BCD bucket-D

C4 (BCD)

(b) BE execution

(c) Bucket tree

Figure 5: Bucket Elimination
can also be applied to any graphical model. Consider a constraint network R = hX, D, Ci and an
ordering d = (X1 , X2 , . . . , Xn ). The ordering d dictates an elimination order for BE, from last to
first. Each variable is associated with a bucket. Each constraint from C is placed in the bucket of its
latest variable in d. Buckets are processed from Xn to X1 by eliminating the bucket variable (the
constraints residing in the bucket are joined together, and the bucket variable is projected out) and
placing the resulting constraint (also called message) in the bucket of its latest variable in d. After
its execution, BE renders the network backtrack free, and a solution can be produced by assigning
variables along d. BE can also produce the solutions count if marginalization is done by summation
(rather than projection) over the functional representation of the constraints, and join is substituted
by multiplication.
BE also constructs a bucket tree, by linking the bucket of each Xi to the destination bucket of
its message (called the parent bucket). A node in the bucket tree typically has a bucket variable, a
collection of constraints, and a scope (the union of the scopes of its constraints). If the nodes of the
bucket tree are replaced by their respective bucket variables, it is easy to see that we obtain a pseudo
tree.
Example 5 Figure 5(a) shows a network with four constraints. Figure5(b) shows the execution of
Bucket Elimination along d = (A, B, E, C, D). The buckets are processed from D to A.2 Figure
5(c) shows the bucket tree. The pseudo tree corresponding to the order d is given in Fig. 6(a).
2. The representation in Figure 5 reverses the top down bucket processing described in earlier papers (Dechter, 1999).

474

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Procedure GeneratePseudoTree(G, d)
1
2
3
4
5

input : graph G = (X, E); order d = (X1 , . . . , Xn )
output : Pseudo tree T
Make X1 the root of T
Condition on X1 (eliminate X1 and its incident edges from G). Let G1 , . . . , Gp be the resulting connected
components of G
for i = 1 to p do
Ti = GeneratePseudoTree (Gi , d|Gi )
Make root of Ti a child of X1

6 return T

2.4 Orderings and Pseudo Trees
Given an ordering d, the structural information captured in the primal graph through the scopes
of the functions F = {f1 , . . . , fr } can be used to create the unique pseudo tree that corresponds
to d (Mateescu & Dechter, 2005). This is precisely the bucket tree (or elimination tree), that is
created by BE (when variables are processed in reverse d). The same pseudo tree can be created by
conditioning on the primal graph, and processing variables in the order d, as described in Procedure
GeneratePseudoTree. In the following, d|Gi is the restriction of the order d to the nodes of
the graph Gi .

3. Overview of AND/OR Search Space for Graphical Models
The AND/OR search space is a recently introduced (Dechter & Mateescu, 2004a, 2004b, 2007)
unifying framework for advanced algorithmic schemes for graphical models. Its main virtue consists in exploiting independencies between variables during search, which can provide exponential
speedups over traditional search methods oblivious to problem structure. Since AND/OR MDDs
are based on AND/OR search spaces we need to provide a comprehensive overview for the sake of
completeness.
3.1 AND/OR Search Trees
The AND/OR search tree is guided by a pseudo tree of the primal graph. The idea is to exploit
the problem decomposition into independent subproblems during search. Assigning a value to a
variable (also known as conditioning), is equivalent in graph terms to removing that variable (and its
incident edges) from the primal graph. A partial assignment can therefore lead to the decomposition
of the residual primal graph into independent components, each of which can be searched (or solved)
separately. The pseudo tree captures precisely all these decompositions given an order of variable
instantiation.
D EFINITION 11 (AND/OR search tree of a graphical model) Given a graphical model M =
hX, D, Fi, its primal graph G and a pseudo tree T of G, the associated AND/OR search tree
has alternating levels of OR and AND nodes. The OR nodes are labeled Xi and correspond to
variables. The AND nodes are labeled hXi , xi i (or simply xi ) and correspond to value assignments.
The structure of the AND/OR search tree is based on T . The root is an OR node labeled with the
root of T . The children of an OR node Xi are AND nodes labeled with assignments hXi , xi i that

475

M ATEESCU , D ECHTER & M ARINESCU

A

A

B

1

B

B

0
E

E

0

C

D

1
C

0 1

E

0

1

D
0 1

(a) Pseudo tree

0 1

0
C

E

0

1

D

D

0 1

0 1

0 1

1
C

E

0

1

D

D

0 1

0 1

0 1

C
0

1

D

D

D

0 1

0 1

0 1

(b) Search tree

Figure 6: AND/OR search tree
are consistent with the assignments along the path from the root. The children of an AND node
hXi , xi i are OR nodes labeled with the children of variable Xi in the pseudo tree T .
Example 6 Figure 6 shows an example of an AND/OR search tree for the graphical model given in
Figure 5(a), assuming all tuples are consistent, and variables are binary valued. When some tuples
are inconsistent, some of the paths in the tree do not exist. Figure 6(a) gives the pseudo tree that
guides the search, from top to bottom, as indicated by the arrows. The dotted arcs are backarcs
from the primal graph. Figure 6(b) shows the AND/OR search tree, with the alternating levels of
OR (circle) and AND (square) nodes, and having the structure indicated by the pseudo tree.
The AND/OR search tree can be traversed by a depth first search algorithm, thus using linear
space. It was already shown (Freuder & Quinn, 1985; Bayardo & Miranker, 1996; Darwiche, 2001;
Dechter & Mateescu, 2004a, 2007) that:
T HEOREM 1 Given a graphical model M over n variables, and a pseudo tree T of depth m, the
size of the AND/OR search tree based on T is O(n k m ), where k bounds the domains of variables.
A graphical model of treewidth w∗ has a pseudo tree of depth at most w∗ log n, therefore it has an
∗
AND/OR search tree of size O(n k w log n ).
The AND/OR search tree expresses the set of all possible assignments to the problem variables
(all solutions). The difference from the traditional OR search space is that a solution is no longer a
path from root to a leaf, but rather a tree, defined as follows:
D EFINITION 12 (solution tree) A solution tree of an AND/OR search tree contains the root node.
For every OR node, it contains one of its child nodes and for each of its AND nodes it contains all
its child nodes, and all its leaf nodes are consistent.
3.2 AND/OR Search Graph
The AND/OR search tree may contain nodes that root identical subproblems. These nodes are said
to be unifiable. When unifiable nodes are merged, the search space becomes a graph. Its size
becomes smaller at the expense of using additional memory by the search algorithm. The depth first
search algorithm can therefore be modified to cache previously computed results, and retrieve them
when the same nodes are encountered again. The notion of unifiable nodes is defined formally next.

476

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

D EFINITION 13 (minimal AND/OR graph, isomorphism) Two AND/OR search graphs G and G0
are isomorphic if there exists a one to one mapping σ from the vertices of G to the vertices of G0
such that for any vertex v, if σ(v) = v 0 , then v and v 0 root identical subgraphs relative to σ. An
AND/OR graph is called minimal if all its isomorphic subgraphs are merged. Isomorphic nodes
(that root isomorphic subgraphs) are also said to be unifiable.
It was shown by Dechter and Mateescu (2007) that:
T HEOREM 2 A graphical model M has a unique minimal AND/OR search graph relative to a
pseudo-tree T .
The minimal AND/OR graph of a graphical model G relative to a pseudo tree T is denoted by
MT (G). Note that the definition of minimality used in the work of Dechter and Mateescu (2007)
is based only on isomorphism reduction. We will extend it here by also including the elimination
of redundant nodes. The previous theorem only shows that given an AND/OR graph, the merge
operator has a fixed point, which is the minimal AND/OR graph. We will show in this paper that
the AOMDD is a canonical representation, namely that any two equivalent graphical models can
be represented by the same unique AOMDD given that they accept the same pseudo tree, and the
AOMDD is minimal in terms of number of nodes.
Some unifiable nodes can be identified based on their contexts. We can define graph based
contexts for both OR nodes and AND nodes, just by expressing the set of ancestor variables in T
that completely determine a conditioned subproblem. However, it can be shown that using caching
based on OR contexts makes caching based on AND contexts redundant and vice versa, so we will
only use OR caching. Any value assignment to the context of X separates the subproblem below X
from the rest of the network.
D EFINITION 14 (OR context) Given a pseudo tree T of an AND/OR search space,
context(X) = [X1 . . . Xp ] is the set of ancestors of X in T , ordered descendingly, that are connected in the primal graph to X or to descendants of X.
D EFINITION 15 (context unifiable OR nodes) Given an AND/OR search graph, two OR nodes n1
and n2 are context unifiable if they have the same variable label X and the assignments of their
contexts is identical. Namely, if π1 is the partial assignment of variables along the path to n1 , and
π2 is the partial assignment of variables along the path to n2 , then their restriction to the context of
X is the same: π1 |context(X) = π2 |context(X) .
The depth first search algorithm that traverses the AND/OR search tree, can be modified to
traverse a graph, if enough memory is available. We could allocate a cache table for each variable X,
the scope of the table being context(X). The size of the cache table for X is therefore the product
of the domains of variables in its context. For each variable X, and for each possible assignment
to its context, the corresponding conditioned subproblem is solved only once and the computed
value is saved in the cache table, and whenever the same context assignment is encountered again,
the value of the subproblem is retrieved from the cache table. Such an algorithm traverses what is
called the context minimal AND/OR graph.
D EFINITION 16 (context minimal AND/OR graph) The context minimal AND/OR graph is obtained from the AND/OR search tree by merging all the context unifiable OR nodes.
477

M ATEESCU , D ECHTER & M ARINESCU

R

F

G

B

[]

C

A
J

K

[C]

H

[C]

L

[CK]

A

[CH]

N

[CKL]

B

[CHA]

O

[CKLN]

P

[CKO]

H
E
C

D

L

E

[CHAB]

R

[HAB]

J

[CHAE]

F

[AR]

D

[CEJ]

G

[AF]

M

[CD]

K
M
N
P
O

(a) Primal graph

(b) Pseudo tree
C

0

0

K

H

K

0

1

0

1

L

L

L

L

H

0

1

A

0

A

1

A

A

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

N

N

N

N

N

N

N

N

B

B

B

B

B

B

B

B

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

O

O

O

O

O

O

O

O

O

O

O

O

O

O

O

O

0

E

0

1

E

E

E

0

1

E

E

E

0

1

E

E

E

E

0

1

E

E

E

E

1

E

0

0

1

R

R

R

0

1

R

R

R

R

1

R

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
0 1 0 1 0 1 0 1 0 1
P

P

P

P

P

P

P

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

P
J

J

J

J

J

J

J

J

J

J

J

J

J

J

J

J

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

D

D

D

D

0 1 0 1 0 1 0 1

D

D

D

F

F

F

F

0 1 0 1 0 1 0 1

D

0 1 0 1 0 1 0 1

G

G

G

G

0 1 0 1 0 1 0 1
M

M

M

M

0 1 0 1 0 1 0 1

(c) Context minimal graph

Figure 7: AND/OR search graph
It was already shown (Bayardo & Miranker, 1996; Dechter & Mateescu, 2004a, 2007) that:
T HEOREM 3 Given a graphical model M, its primal graph G and a pseudo tree T , the size of the
context minimal AND/OR search graph based on T , and therefore the size of its minimal AND/OR
∗
search graph, is O(n k wT (G) ), where wT∗ (G) is the induced width of G over the depth first traversal
of T , and k bounds the domain size.

Example 7 Let’s look at the impact of caching on the size of the search space by examining a larger
example. Figure 7(a) shows a graphical model with binary variables and Figure 7(b) a pseudo tree
that drives the AND/OR search. The context of each node is given in square brackets. The context
minimal graph is given in Figure 7(c). Note that it is far smaller than the AND/OR search tree,
which has 28 = 256 AND nodes at the level of M alone (because M is at depth 8 in the pseudo tree).
The shaded rectangles show the size of each cache table, equal to the number of OR nodes that
appear in each one. A cache entry is useful whenever there are more than one incoming edges into
the OR node. Incidentally, the caches that are not useful (namely OR nodes with only one incoming
arc), are called dead caches (Darwiche, 2001), and can be determined based only on the pseudo
478

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

tree inspection, therefore a cache table need not be allocated for them. The context minimal graph
can also explain the execution of BE along the same pseudo tree (or, equivalently, along its depth
first traversal order). The buckets are the shaded rectangles, and the processing is done bottom up.
The number of possible assignments to each bucket equals the number of AND nodes that appear
in it. The message scope is identical to the context of the bucket variable, and the message itself is
identical to the corresponding cache table. For more details on the relationship between AND/OR
search and BE see the work of Mateescu and Dechter (2005).
3.3 Weighted AND/OR Graphs
In the previous subsections we described the structure of the AND/OR trees and graphs. In order
to use them to solve a reasoning task, we need to define a way of using the input function values
during the traversal of an AND/OR graph. This is realized by placing weights (or costs) on the
OR-to-AND arcs, dictated by the function values. Only the functions that are relevant contribute to
an OR-to-AND arc weight, and this is captured by the buckets relative to the pseudo tree:
D EFINITION 17 (buckets relative to a pseudo tree) Given a graphical model M = hX, D, F, ⊗i
and a pseudo tree T , the bucket of Xi relative to T , denoted BT (Xi ), is the set of functions whose
scopes contain Xi and are included in pathT (Xi ), which is the set of variables from the root to Xi
in T . Namely,
BT (Xi ) = {f ∈ F|Xi ∈ scope(f ), scope(f ) ⊆ pathT (Xi )}.

A function belongs to the bucket of a variable Xi iff its scope has just been fully instantiated
when Xi was assigned. Combining the values of all functions in the bucket, for the current assignment, gives the weight of the OR-to-AND arc:
D EFINITION 18 (OR-to-AND weights) Given an AND/OR graph of a graphical model M, the
weight w(n,m) (Xi , xi ) of arc (n, m) where Xi labels n and xi labels m, is the combination of
all the functions in BT (Xi ) assigned by values along the current path to the AND node m, πm .
Formally, w(n,m) (Xi , xi ) = ⊗f ∈BT (Xi ) f (asgn(πm )[scope(f )]).
D EFINITION 19 (weight of a solution tree) Given a weighted AND/OR graph of a graphical model
M, and given a solution tree t having the OR-to-AND set of arcs arcs(t), the weight of t is defined
by w(t) = ⊗e∈arcs(t) w(e).
Example 8 We start with the more straightforward case of constraint networks. Since functions
only take values 0 or 1, and the combination is by product (join of relations), it follows that any ORto-AND arc can only have a weight of 0 or 1. An example is given in Figure 8. Figure 8(a) shows
a constraint graph, 8(b) a pseudo tree for it, and 8(c) the four relations that define the constraint
problem. Figure 8(d) shows the AND/OR tree that can be traversed by a depth first search algorithm
that only checks the consistency of the input functions (i.e., no constraint propagation is used).
Similar to the OBDD representation, the OR-to-AND arcs with a weight of 0 are denoted by dotted
lines, and the tree is not unfolded below them, since it will not contain any solution. The arcs with
a weight of 1 are drawn with solid lines.
479

M ATEESCU , D ECHTER & M ARINESCU

A
B
C

A

D

F

B

E

(a) Constraint graph
A
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

B
0
0
0
0
1
1
1
1

C RABC
0
1
1
1
0
0
1
1
0
1
1
1
0
1
1
0

C
0
0
1
1
0
0
1
1

C

E

D

F

(b) Pseudo tree

D RBCD
0
1
1
1
0
1
1
0
0
1
1
0
0
1
1
1

A
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

E RABE
0
1
1
0
0
1
1
1
0
0
1
1
0
1
1
0

A
0
0
0
0
1
1
1
1

E
0
0
1
1
0
0
1
1

F RAEF
0
0
1
1
0
1
1
1
0
1
1
1
0
1
1
0

(c) Relations
A

1

1

0

1

B

B

1

1

1
1

0
C

C

E

1
1

0
C

E

C

E

E

1

1

1

0

0

1

1

1

1

1

0

1

1

0

1

0

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

D

D

D

F

1

1 1

0 0

1

0

1

1

1

0

0

1
0

F

D

F

1 0

1 1

1

1

1

1

1

0

0

0

D

D

F

F

1 1

0

1

0

1

0

1

1

0

1

0

1

0

1
0

1
1

(d) AND/OR tree

Figure 8: AND/OR search tree for constraint networks
Example 9 Figure 9 shows a weighted AND/OR tree for a belief network. Figure 9(a) shows the
directed acyclic graph, and the dotted arc BC added by moralization. Figure 9(b) shows the pseudo
tree, and 9(c) shows the conditional probability tables. Figure 9(d) shows the weighted AND/OR
tree.
As we did for constraint networks, we can move from weighted AND/OR search trees to
weighted AND/OR search graphs by merging unifiable nodes. In this case the arc labels should be
also considered when determining unifiable subgraphs. This can yield context-minimal weighted
AND/OR search graphs and minimal weighted AND/OR search graphs.

4. AND/OR Multi-Valued Decision Diagrams (AOMDDs)
In this section we begin describing the contributions of this paper. The context minimal AND/OR
graph (Definition 16) offers an effective way of identifying some unifiable nodes during the execution of the search algorithm. Namely, context unifiable nodes are discovered based only on their
paths from the root, without actually solving their corresponding subproblems. However, merging based on context is not complete, which means that there may still exist unifiable nodes in
the search graph that do not have identical contexts. Moreover, some of the nodes in the context
480

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

P(A)

A

A
0
1

A

P(B | A)

P(A)
.6
.4

A
0
1

P(C | A)
A
0
1

B=1
.6
.9

B=0
.4
.1

P(D | B,C)

B
B

B
0
0
1
1

C

E
E

C
D

D

(a) Belief network

C
0
1
0
1

P(E | A,B)
D=1
.8
.9
.7
.5

D=0
.2
.1
.3
.5

C=1
.8
.3

C=0
.2
.7

(b) Pseudo tree

A
0
0
1
1

B
0
1
0
1

E=0
.4
.5
.7
.2

E=1
.6
.5
.3
.8

(c) CPTs

A

.6

.4

0

1

B

B

.4
0

0

C

.6
1

E

.2

.8

.5

0

1

0

D

.2
0

1

D

.8
1

.1
0

.2

.8

.7

0

1

0

D

.9
1

.3
0

C

0

E

.3

.7

.3

1

0

1

D

D

.7 .5
1

1

E

C

.5

.9

0

1

E

.4

.1

.6

.2

.5

0

1

.2
0

C

.8

.7

.3

1

0

1

D

.8
1

D

.1
0

.9
1

.3
0

D

.7 .5
1

0

.5
1

(d) Weighted AND/OR tree

Figure 9: Weighted AND/OR search tree for belief networks
minimal AND/OR graph may be redundant, for example when the set of solutions rooted at variable Xi is not dependant on the specific value assigned to Xi (this situation is not detectable based
on context). This is sometimes termed as “interchangeable values” or “symmetrical values”. As
overviewed earlier, Dechter and Mateescu (2007, 2004a) defined the complete minimal AND/OR
graph which is an AND/OR graph whose unifiable nodes are all merged, and Dechter and Mateescu
(2007) also proved the canonicity for non-weighted graphical models.
In this paper we propose to augment the minimal AND/OR search graph with removing redundant variables as is common in OBDD representation as well as adopt notational conventions
common in this community. This yields a data structure that we call AND/OR BDD, that exploits
decomposition by using AND nodes. We present the extension over multi-valued variables yielding
AND/OR MDD or AOMDD and define them for general weighted graphical models. Subsequently
we present two algorithms for compiling the canonical AOMDD of a graphical model: the first is
search-based, and uses the memory intensive AND/OR graph search to generate the context minimal
AND/OR graph, and then reduces it bottom up by applying reduction rules; the second is inferencebased, and uses a Bucket Elimination schedule to combine the AOMDDs of initial functions by
APPLY operations (similar to the apply for OBDDs). As we will show, both approaches have the
same worst case complexity as the AND/OR graph search with context based caching, and also the
same complexity as Bucket Elimination, namely time and space exponential in the treewidth of the
∗
problem, O(n k w ). The benefit of each of these generation schemes will be discussed.

481

M ATEESCU , D ECHTER & M ARINESCU

A

A

1

(a) OBDD

2

…

k

(b) MDD

Figure 10: Decision diagram nodes (OR)
A

A

1

…

…

…

(a) AOBDD

2

k

…

…

…

(b) AOMDD

Figure 11: Decision diagram nodes (AND/OR)
4.1 From AND/OR Search Graphs to Decision Diagrams
An AND/OR search graph G of a graphical model M = hX, D, F, ⊗i represents the set of all
possible assignments to the problem variables (all solutions and their costs). In this sense, G can
be viewed as representing the function f = ⊗fi ∈F fi that defines the universal equivalent graphical
model u(M) (Definition 2). For each full assignment x = (x1 , . . . , xn ), if x is a solution expressed
by the tree tx , then f (x) = w(tx ) = ⊗e∈arcs(tx ) w(e) (Definition 19); otherwise f (x) = 0 (the
assignment is inconsistent). The solution tree tx of a consistent assignment x can be read from G
in linear time by following the assignments from the root. If x is inconsistent, then a dead-end is
encountered in G when attempting to read the solution tree tx , and f (x) = 0. Therefore, G can be
viewed as a decision diagram that determines the values of f for every complete assignment x.
We will now see how we can process an AND/OR search graph by reduction rules similar to
the case of OBDDs, in order to obtain a representation of minimal size. In the case of OBDDs,
a node is labeled with a variable name, for example A, and the low (dotted line) and high (solid
line) outgoing arcs capture the restriction of the function to the assignments A = 0 or A = 1. To
determine the value of the function, one needs to follow either one or the other (but not both) of the
outgoing arcs from A (see Figure 10(a)). The straightforward extension of OBDDs to multi-valued
variables (multi-valued decision diagrams, or MDDs) was presented by Srinivasan, Kam, Malik,
and Brayton (1990), and the node structure that they use is given in Figure 10(b). Each outgoing arc
is associated with one of the k values of variable A.
In this paper we generalize the OBDD and MDD representations demonstrated in Figures 10(a)
and 10(b) by allowing each outgoing arc to be an AND arc. An AND arc connects a node to a set of
nodes, and captures the decomposition of the problem into independent components. The number of
AND arcs emanating from a node is two in the case of AOBDDs (Figure 11(a)), or the domain size
of the variable in the general case (Figure 11(b)). For a given node A, each of its k AND arcs can
connect it to possibly different number of nodes, depending on how the problem decomposes based
on each particular assignment of A. The AND arcs are depicted by a shaded sector that connects
the outgoing lines corresponding to the independent components.

482

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

A
1

…

2

…

…k

…

…

(a) Nonterminal meta-node

0

1

(b) Terminal meta-node 0

(c) Terminal meta-node 1

Figure 12: Meta-nodes
We define the AND/OR Decision Diagram representation based on AND/OR search graphs. We
find that it is useful to maintain the semantics of Figure 11 especially when we need to express the
redundancy of nodes, and therefore we introduce the meta-node data structure, which defines small
portions of any AND/OR graph, based on an OR node and its AND children:
D EFINITION 20 (meta-node) A meta-node u in an AND/OR search graph can be either: (1) a
terminal node labeled with 0 or 1, or (2) a nonterminal node, that consists of an OR node labeled
X (therefore var(u) = X) and its k AND children labeled x1 , . . . , xk that correspond to the value
assignments of X. Each AND node labeled xi stores a list of pointers to child meta-nodes, denoted
by u.childreni . In the case of weighted graphical models, the AND node xi also stores the OR-toAND arc weight w(X, xi ).
The rectangle in Figure 12(a) is a meta-node for variable A, that has a domain of size k. Note
that this is very similar to Figure 11, with the small difference that the information about the value of
A that corresponds to each outgoing AND arc is now stored in the AND nodes of the meta-node. We
are not showing the weights in that figure. A larger example of an AND/OR graph with meta-nodes
appears later in Figure 16.
The terminal meta-nodes play the role of the terminal nodes in OBDDs. The terminal metanode 0, shown in Figure 12(b), indicates inconsistent assignments, while the terminal meta-node 1,
shown in figure 12(c) indicates consistent ones.
Any AND/OR search graph can now be viewed as a diagram of meta-nodes, simply by grouping
OR nodes with their AND children, and adding the terminal meta-nodes appropriately.
Once we have defined the meta-nodes, it is easier to see when a variable is redundant with respect to the outcome of the function based on the current partial assignment. A variable is redundant
if any of its assignments leads to the same set of solutions.
D EFINITION 21 (redundant meta-node) Given a weighted AND/OR search graph G represented
with meta-nodes, a meta-node u with var(u) = X and |D(X)| = k is redundant iff:
(a) u.children1 = . . . = u.childrenk and
(b) w(X, x1 ) = . . . = w(X, xk ).
An AND/OR graph G, that contains a redundant meta-node u, can be transformed into an equivalent graph G 0 by replacing any incoming arc into u with its common list of children u.children1 ,
absorbing the common weight w(X, x1 ) by combination into the weight of the parent meta-node
corresponding to the incoming arc, and then removing u and its outgoing arcs from G. The
value X = x1 is picked here arbitrarily, because they are all isomorphic. If u is the root of the
483

M ATEESCU , D ECHTER & M ARINESCU

Procedure RedundancyReduction
: AND/OR graph G; redundant meta-node u, with var(u) = X; List of meta-node parents of u,
denoted by P arents(u).
output : Reduced AND/OR graph G after the elimination of u.
1 if P arents(u) is empty then
2
return independent AND/OR graphs rooted by meta-nodes in u.children1 , and constant w(X, x1 )
input

3 forall v ∈ P arents(u) (assume var(v) == Y ) do
4
forall i ∈ {1, . . . , |D(Y )|} do
5
if u ∈ v.childreni then
6
v.childreni ← v.childreni \ {u}
7
v.childreni ← v.childreni ∪ u.children1
8
w(Y, yi ) ← w(Y, yi ) ⊗ w(X, x1 )
9 remove u
10 return reduced AND/OR graph G

Procedure IsomorphismReduction
: AND/OR graph G; isomorphic meta-nodes u and v; List of meta-node parents of u, denoted by
P arents(u).
output : Reduced AND/OR graph G after the merging of u and v.
forall p ∈ P arents(u) do
if u ∈ p.childreni then
p.childreni ← p.childreni \ {u}
p.childreni ← p.childreni ∪ {v}

input

1
2
3
4

5 remove u
6 return reduced AND/OR graph G

graph, then the common weight w(X, x1 ) has to be stored separately as a constant. Procedure
RedundancyReduction formalizes the redundancy elimination.
D EFINITION 22 (isomorphic meta-nodes) Given a weighted AND/OR search graph G represented
with meta-nodes, two meta-nodes u and v having var(u) = var(v) = X and |D(X)| = k are
isomorphic iff:
(a) u.childreni = v.childreni ∀i ∈ {1, . . . , k} and
(b) wu (X, xi ) = wv (X, xi ) ∀i ∈ {1, . . . , k}, (where wu , wv are the weights of u and v).
Procedure IsomorphismReduction formalizes the process of merging isomorphic metanodes. Naturally, the AND/OR graph obtained by merging isomorphic meta-nodes is equivalent to
the original one. We can now define the AND/OR Multi-Valued Decision Diagram:
D EFINITION 23 (AOMDD) An AND/OR Multi-Valued Decision Diagram (AOMDD) is a weighted
AND/OR search graph that is completely reduced by isomorphic merging and redundancy removal,
namely:
(1) it contains no isomorphic meta-nodes; and
(2) it contains no redundant meta-nodes.

484

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

A

A

2…k

1

B

c

2

d

2

…k

z

…
1

1

z

k

…

y

c

…

d

y

(b) After eliminating the B
meta-node

(a) Fragment of an AOMDD

Figure 13: Redundancy reduction
A
1

A

2…k

1

2

…k

B
1

C

2

d

2

1

C

…
1

B

…k

1

e

2

…

…k

C

…
k

2

…
k

1

y

d

(a) Fragment of an AOMDD

2

k

e

…

y

(b) After merging the isomorphic C meta-nodes

Figure 14: Isomorphism reduction
Example 10 Figure 13 shows an example of applying the redundancy reduction rule to a portion
of an AOMDD. On the left side, in Figure 13(a), the meta-node of variable B is redundant (we
don’t show the weights of the OR-to-AND arcs, to avoid cluttering the figure). Any of the values
{1, . . . , k} of B will lead to the same set of meta-nodes {c, d, . . . , y}, which are coupled in an AND
arc. Therefore, the meta-node of B can be eliminated. The result is shown in Figure 13(b), where
the meta-nodes {c, d, . . . , y} and z are coupled in an AND arc outgoing from A = 1.
In Figure 14 we show an example of applying the isomorphism reduction rule. In this case, the
meta-nodes labeled with C in Figure 14(a) are isomorphic (again, we omit the weights). The result
of merging them is shown in Figure 14(b).
Examples of AOMDDs appear in Figures 16, 17 and 18. Note that if the weight on an OR-toAND arc is zero, then the descendant is the terminal meta-node 0. Namely, the current path is a
dead-end, cannot be extended to a solution, and is therefore linked directly to 0.

5. Using AND/OR Search to Generate AOMDDs
In Section 4.1 we described how we can transform an AND/OR graph into an AOMDD by applying
reduction rules. In Section 5.1 we describe the explicit algorithm that takes as input a graphi485

M ATEESCU , D ECHTER & M ARINESCU

cal model, performs AND/OR search with context-based caching to obtain the context minimal
AND/OR graph, and in Section 5.2 we give the procedure that applies the reduction rules bottom
up to obtain the AOMDD.
5.1 Algorithm AND/OR-S EARCH -AOMDD
Algorithm 1, called AND/OR-S EARCH -AOMDD, compiles a graphical model into an AOMDD.
A memory intensive (with context-based caching) AND/OR search is used to create the context minimal AND/OR graph (see Definition 16). The input to AND/OR-S EARCH -AOMDD is a graphical
model M and a pseudo tree T , that also defines the OR-context of each variable.
Each variable Xi has an associated cache table, whose scope is the context of Xi in T . This
ensures that the trace of the search is the context minimal AND/OR graph. A list denoted by LXi
(see line 35), is used for each variable Xi to save pointers to meta-nodes labeled with Xi . These
lists are used by the procedure that performs the bottom up reduction, per layers of the AND/OR
graph (one layer contains all the nodes labeled with one given variable). The fringe of the search
is maintained on a stack called OPEN. The current node (either OR or AND node) is denoted by
n, its parent by p, and the current path by πn . The children of the current node are denoted by
successors(n). For each node n, the Boolean attribute consistent(n) indicates if the current path
can be extended to a solution. This information is useful for pruning the search space.
The algorithm is based on two mutually recursive steps: Forward (beginning at line 5) and
Backtrack (beginning at line 29), which call each other (or themselves) until the search terminates.
In the forward phase, the AND/OR graph is expanded top down. The two types of nodes, AND and
OR, are treated differently according to their semantics.
Before an OR node is expanded, the cache table of its variable is checked (line 8). If the entry
is not null, a link is created to the already existing OR node that roots the graph equivalent to the
current subproblem. Otherwise, the OR node is expanded by generating its AND descendants. The
OR-to-AND weight (see Definition 18) is computed in line 13. Each value xi of Xi is checked for
consistency (line 14). The least expensive check is to verify that the OR-to-AND weight is non-zero.
However, the deterministic (inconsistent) assignments in M can be extracted to form a constraint
network. Any level of constraint propagation can be performed in this step (e.g., look ahead, arc
consistency, path consistency, i-consistency etc.). The computational overhead can increase, in the
hope of pruning the search space more aggressively. We should note that constraint propagation is
not crucial for the algorithm, and the complexity guarantees are maintained even if only the simple
weight check is performed. The consistent AND nodes are added to the list of successors of n (line
16), while the inconsistent ones are linked to the terminal 0 meta-node (line 19).
An AND node n labeled with hXi , xi i is expanded (line 20) based on the structure of the pseudo
tree. If Xi is a leaf in T , then n is linked to the terminal 1 meta-node (line 22). Otherwise, an OR
node is created for each child of Xi in T (line 24).
The forward step continues as long as the current node is not a dead-end and still has unevaluated
successors. The backtrack phase is triggered when a node has an empty set of successors (line 29).
Note that, as each successor is processed, it is removed from the set of successors in line 42. When
the backtrack reaches the root (line 32), the search is complete, the context minimal AND/OR graph
is generated, and the Procedure B OTTOM U P R EDUCTION is called.
When the backtrack step processes an OR node (line 31), it saves a pointer to it in cache, and
also adds a pointer to the corresponding meta-node to the list LXi . The consistent attribute of

486

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Algorithm 1: AND/OR S EARCH - AOMDD
input : M = hX, D, Fi; pseudo tree T rooted at X1 ; parents pai (OR-context) for every variable Xi .
output : AOMDD of M.
1 forall Xi ∈ X do
Initialize context-based cache table CacheXi (pai ) with null entries
2
3 Create new OR node t, labeled with Xi ; consistent(t) ← true; push t on top of OPEN
4 while OPEN 6= φ do
5
n ← top(OPEN); remove n from OPEN
// Forward
6
successors(n) ← φ
7
if n is an OR node labeled with Xi then
// OR-expand
if CacheXi (asgn(πn )[pai ]) 6= null then
8
Connect parent of n to CacheXi (asgn(πn )[pai ])
9
// Use the cached pointer
10
11
12
13
14
15
16
17
18
19

else
forall xi ∈ Di do
Create new AN D node t, labeled with hXi , xi i
w(X, xi ) ←
⊗
f (asgn(πn )[pai ])
f ∈BT (Xi )

if hXi , xi i is consistent with πn then
consistent(t) ← true
add t to successors(n)
else
consistent(t) ← f alse
make terminal 0 the only child of t

20
21
22
23
24
25
26
27

if n is an AND node labeled with hXi , xi i then
if childrenT (Xi ) == φ then
make terminal 1 the only child of n
else
forall Y ∈ childrenT (Xi ) do
Create new OR node t, labeled with Y
consistent(t) ← f alse
add t to successors(n)

28
29
30
31
32
33

Add successors(n) to top of OPEN
while successors(n) == φ do
let p be the parent of n
if n is an OR node labeled with Xi then
if Xi == X1 then
Call BottomUpReduction procedure

34
35
36
37
38
39

// Constraint Propagation

// AND-expand

// Backtrack

// Search is complete
// begin reduction to AOMDD

Cache(asgn(πn )[pai ]) ← n
Add meta-node of n to the list LXi
consistent(p) ← consistent(p) ∧ consistent(n)
if consistent(p) == f alse then
remove successors(p) from OPEN
successors(p) ← φ

40
41

if n is an AND node labeled with hXi , xi i then
consistent(p) ← consistent(p) ∨ consistent(n);

42
43

remove n from successors(p)
n←p

487

// Save in cache

// Check if p is dead-end

M ATEESCU , D ECHTER & M ARINESCU

Procedure BottomUpReduction
: A graphical model M = hX, D, Fi; a pseudo tree T of the primal graph, rooted at X1 ; Context
minimal AND/OR graph, and lists LXi of meta-nodes for each level Xi .
output : AOMDD of M.
Let d = {X1 , . . . , Xn } be the depth first traversal ordering of T
for i ← n down to 1 do
Let H be a hash table, initially empty
forall meta-nodes n in LXi do
if H(Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )) returns a meta-node
p then
merge n with p in the AND/OR graph
input

1
2
3
4
5
6
7
8
9
10
11
12

else if n is redundant then
eliminate n from the AND/OR graph
combine its weight with that of the parent
else
hash n into the table H:
H(Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )) ← n

13 return reduced AND/OR graph

the AND parent p is updated by conjunction with consistent(n). If the AND parent p becomes
inconsistent, it is not necessary to check its remaining OR successors (line 38). When the backtrack
step processes an AND node (line 40), the consistent attribute of the OR parent p is updated by
disjunction with consistent(n).
The AND/OR search algorithm usually maintains a value for each node, corresponding to a task
that is solved. We did not include values in our description because an AOMDD is just an equivalent
representation of the original graphical model M. Any task over M can be solved by a traversal
of the AOMDD. It is however up to the user to include more information in the meta-nodes (e.g.,
number of solutions for a subproblem).
5.2 Reducing the Context Minimal AND/OR Graph to an AOMDD
Procedure BottomUpReduction processes the variables bottom up relative to the pseudo tree T .
We use the depth first traversal ordering of T (line 1), but any other bottom up ordering is as good.
The outer for loop (starting at line 2) goes through each level of the context minimal AND/OR graph
(where a level contains all the OR and AND nodes labeled with the same variable, in other words it
contains all the meta-nodes of that variable). For efficiency, and to ensure the complexity guarantees
that we will prove, a hash table, initially empty, is used for each level. The inner for loop (starting at
line 4) goes through all the metanodes of a level, that are also saved (or pointers to them are saved)
in the list LXi . For each new meta-node n in the list LXi , in line 5 the hash table H is checked to
verify if a node isomorphic with n already exists. If the hash table H already contains a node p corresponding to the hash key (Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )),
then p and n are isomorphic and should be merged. Otherwise, if the new meta-node n is redundant,
then it is eliminated from the AND/OR graph. If none of the previous two conditions is met, then
the new meta-node n is hashed into table H.

488

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

A
D

G

C

B

F

E

A

H

B
C
D

(a)

F
E

G

H

(b)

Figure 15: (a) Constraint graph for C = {C1 , . . . , C9 }, where C1 = F ∨ H, C2 = A ∨ ¬H,
C3 = A ⊕ B ⊕ G, C4 = F ∨ G, C5 = B ∨ F , C6 = A ∨ E, C7 = C ∨ E, C8 = C ⊕ D,
C9 = B ∨ C; (b) Pseudo tree (bucket tree) for ordering d = (A, B, C, D, E, F, G, H)

Proposition 1 The output of Procedure BottomUpReduction is the AOMDD of M along the
pseudo tree T , namely the resulting AND/OR graph is completely reduced.
Note that we explicated Procedure BottomUpReduction separately only for clarity. In practice, it can actually be included in Algorithm AND/OR-S EARCH -AOMDD, and the reduction rules
can be applied whenever the search backtracks. We can maintain a hash table for each variable, during the AND/OR search, to store pointers to meta-nodes. When the search backtracks out of an
OR node, it can already check the redundancy of that meta-node, and also look up in the hash table
to check for isomorphism. Therefore, the reduction of the AND/OR graph can be done during the
AND/OR search, and the output will be the AOMDD of M.
From Theorem 3 and Proposition 1 we can conclude:
T HEOREM 4 Given a graphical model M and a pseudo tree T of its primal graph G, the AOMDD
∗
of M corresponding to T has size bounded by O(n k wT (G) ) and it can be computed by Algorithm
∗
AND/OR-S EARCH -AOMDD in time O(n k wT (G) ), where wT∗ (G) is the induced width of G over
the depth first traversal of T , and k bounds the domain size.

6. Using Bucket Elimination to Generate AOMDDs
In this section we propose to use a Bucket Elimination (BE) type algorithm to guide the compilation
of a graphical model into an AOMDD. The idea is to express the graphical model functions as
AOMDDs, and then combine them with APPLY operations based on a BE schedule. The APPLY is
very similar to that from OBDDs (Bryant, 1986), but it is adapted to AND/OR search graphs. It
takes as input two functions represented as AOMDDs based on the same pseudo tree, and outputs
the combination of initial functions, also represented as an AOMDD based on the same pseudo tree.
We will describe it in detail in Section 6.2.
We will start with an example based on constraint networks. This is easier to understand because
the weights on the arcs are all 1 or 0, and therefore are depicted in the figures by solid and dashed
lines, respectively.
Example 11 Consider the network defined by X = {A, B, . . . , H}, DA = . . . = DH = {0, 1} and
the constraints (where ⊕ denotes XOR): C1 = F ∨H, C2 = A∨¬H, C3 = A⊕B⊕G, C4 = F ∨G,
489

M ATEESCU , D ECHTER & M ARINESCU

m7

A

m7
A

A
0

0

1

B
0

1

0

C
0

C
1

0

1

0

0

1

C
1

0

A

1

B

B

0

0

F

C
1

B
1

0

1

F
1

0

1

F
1

B

F

0

1

0

1

B

C
D
0

D

G

E
1

0

0

0

1

0

1

m6

G
1

0

H
1

0

0

1

D

E

1

m3

F

H
1

G

m3

m6

A
0

0

B

C

0

C
0

A

1

0

1

D
1

0

0

C

C
1

0

0

F

B

0

1

0

A

1

0

0

G

1

0

0

1

0

0

H
0

1

B

F
1

G
1

1

F

F

1

F
0

1

A

B
1

B
1

E

D
1

1

B

A

0

H

1

H
1

0

F
1

C

0 1

0

1

0

m5

C9

C

0

E

0

C

D
1

0

0

0

E

D

1

C
1

0

1

0

0

1

G

1

0

1

0

C

A

0 1

C6

C7

1

0

1

0

1

0

1

0

B

H

0 1

1

A
1

0

H

1

G

E

C3

0

1

A

1

G
0

G

F

F
0

B

G

H

m1

m1

1

B

0 1

C8

m2

A

A

1

E

E

1

0

C5

m2

A
1

D

D

D

m4

m5
0

0 1

1
m4

C4

0

H
1

0

F

1

F

0 1

0 1

G

C1

C2

H

Figure 16: Execution of BE with AOMDDs
A
0

A

1

B
0

B
1

0

B

1

B

C
C
0

C
1

0

C
1

0

C
1

0

F
1

0

F
1

0

F
1

0

C

1

0

D

1

D

E

D
0

D
1

0

E
1

0

G
1

0

G
1

0

H
1

0

C

C

F

0

D

D

E

F

H
1

D

E

F

F

F

1

G

G

G

G

H

0

D

1

H

1

(a)

G

0

(b)

Figure 17: (a) The final AOMDD; (b) The OBDD corresponding to d
C5 = B ∨ F , C6 = A ∨ E, C7 = C ∨ E, C8 = C ⊕ D, C9 = B ∨ C. The constraint graph is
shown in Figure 15(a). Consider the ordering d = (A, B, C, D, E, F, G, H). The pseudo tree (or
bucket tree) induced by d is given in Fig. 15(b). Figure 16 shows the execution of BE with AOMDDs
along ordering d. Initially, the constraints C1 through C9 are represented as AOMDDs and placed
in the bucket of their latest variable in d. The scope of any original constraint always appears on a

490

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Algorithm 2: BE-AOMDD
: Graphical model M = hX, D, Fi, where X = {X1 , . . . , Xn }, F = {f1 , . . . , fr } ; order
d = (X1 , . . . , Xn )
output : AOMDD representing ⊗i∈F fi
1 T = GeneratePseudoTree(G, d);
2 for i ← 1 to r do
// place functions in buckets
3
place Gfaomdd
in
the
bucket
of
its
latest
variable
in
d
i
input

4 for i ← n down to 1 do
message(Xi ) ← G1aomdd
5
6
while bucket(Xi ) 6= φ do
7
pick Gfaomdd from bucket(Xi );
8
9
10

// process buckets
// initialize with AOMDD of 1 ;
// combine AOMDDs in bucket of Xi

bucket(Xi ) ← bucket(Xi ) \ {Gfaomdd };
message(Xi ) ← APPLY(message(Xi ), Gfaomdd )
add message(Xi ) to the bucket of the parent of Xi in T

11 return message(X1 )

path from root to a leaf in the pseudo tree. Therefore, each original constraint is represented by an
AOMDD based on a chain (i.e., there is no branching into independent components at any point).
The chain is just the scope of the constraint, ordered according to d. For bi-valued variables, the
original constraints are represented by OBDDs, for multiple-valued variables they are MDDs. Note
that we depict meta-nodes: one OR node and its two AND children, that appear inside each gray
node. The dotted edge corresponds to the 0 value (the low edge in OBDDs), the solid edge to the
1 value (the high edge). We have some redundancy in our notation, keeping both AND value nodes
and arc-types (dotted arcs from “0” and solid arcs from “1”).
The BE scheduling is used to process the buckets in reverse order of d. A bucket is processed
by joining all the AOMDDs inside it, using the APPLY operator. However, the step of elimination
of the bucket variable is omitted because we want to generate the full AOMDD. In our example,
the messages m1 = C1 ./ C2 and m2 = C3 ./ C4 are still based on chains, therefore they are
OBDDs. Note that they contain the variables H and G, which have not been eliminated. However,
the message m3 = C5 ./ m1 ./ m2 is not an OBDD anymore. We can see that it follows the
structure of the pseudo tree, where F has two children, G and H. Some of the nodes corresponding
to F have two outgoing edges for value 1.
The processing continues in the same manner. The final output of the algorithm, which coincides
with m7 , is shown in Figure 17(a). The OBDD based on the same ordering d is shown in Fig.
17(b). Notice that the AOMDD has 18 nonterminal nodes and 47 edges, while the OBDD has 27
nonterminal nodes and 54 edges.
6.1 Algorithm BE-AOMDD
Algorithm 2, called BE-AOMDD, creates the AOMDD of a graphical model by using a BE schedule for APPLY operations. Given an order d of the variables, first a pseudo tree is created based on
,
the primal graph. Each initial function fi is then represented as an AOMDD, denoted by Gfaomdd
i
and placed in its bucket. To obtain the AOMDD of a function, the scope of the function is ordered
according to d, a search tree (based on a chain) that represents fi is generated, and then reduced
by Procedure BottomUpReduction. The algorithm proceeds exactly like BE, with the only difference that the combination of functions is realized by the APPLY algorithm, and variables are not
491

M ATEESCU , D ECHTER & M ARINESCU

eliminated but carried over to the destination bucket. The messages between buckets are initialized
with the dummy AOMDD of 1, denoted by G1aomdd , which is neutral for combination.
In order to create the compilation of a graphical model based on AND/OR graphs, it is necessary
to traverse the AND/OR graph top down and bottom up. This is similar to the inward and outward
message passing in a tree decomposition. Note that BE-AOMDD describes the bottom up traversal
explicitly, while the top down phase is actually performed by the APPLY operation. When two
AOMDDs are combined, after the top chain portion of their pseudo tree is processed, the remaining
independent branches are attached only if they participate in the newly restricted set of solutions.
This amounts to an exchange of information between the independent branches, which is equivalent
to the top down phase.
6.2 The AOMDD APPLY Operation
We will now describe how to combine two AOMDDs. The APPLY operator takes as input two
AOMDDs representing functions f1 and f2 and returns an AOMDD representing f1 ⊗ f2 .
In OBDDs the apply operator combines two input diagrams based on the same variable ordering.
Likewise, in order to combine two AOMDDs we assume that their pseudo trees are identical. This
condition is satisfied by any two AOMDDs in the same bucket of BE-AOMDD. However, we
present here a version of APPLY that is more general, by relaxing the previous condition from
identical to compatible pseudo trees. Namely, there should be a pseudo tree in which both can be
embedded. In general, a pseudo tree induces a strict partial order between the variables where a
parent node always precedes its child nodes.
D EFINITION 24 (compatible pseudo trees) A strict partial order d1 = (X, <1 ) over a set X is
consistent with a strict partial order d2 = (Y, <2 ) over a set Y, if for all x1 , x2 ∈ X ∩ Y, if
x1 <2 x2 then x1 <1 x2 . Two partial orders d1 and d2 are compatible iff there exists a partial
order d that is consistent with both. Two pseudo trees are compatible iff the partial orders induced
via the parent-child relationship, are compatible.
For simplicity, we focus on a more restricted notion of compatibility, which is sufficient when
using a BE like schedule for the APPLY operator to combine the input AOMDDs (as described in
Section 6). The APPLY algorithm that we will present can be extended to the more general notion
of compatibility.
D EFINITION 25 (strictly compatible pseudo trees) A pseudo tree T1 having the set of nodes X1
can be embedded in a pseudo tree T having the set of nodes X if X1 ⊆ X and T1 can be obtained
from T by deleting each node in X \ X1 and connecting its parent to each of its descendents. Two
pseudo trees T1 and T2 are strictly compatible if there exists T such that both T1 and T2 can be
embedded in T .
Algorithm APPLY (algorithm 3) takes as input one node from Gfaomdd and a list of nodes from
Ggaomdd . Initially, the node from Gfaomdd is its root node, and the list of nodes from Ggaomdd is in fact
also made of just one node, which is its root. We will sometimes identify an AOMDD by its root
node. The pseudo trees Tf and Tg are strictly compatible, having a target pseudo tree T .
The list of nodes from Ggaomdd always has a special property: there is no node in it that can be the
ancestor in T of another (we refer to the variable of the meta-node). Therefore, the list z1 , . . . , zm
492

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

APPLY (v1 ; z1 , . . . , zm )
input : AOMDDs Gfaomdd with nodes vi and Ggaomdd with nodes zj , based on strictly compatible pseudo
trees Tf , Tg that can be embedded in T .
var(v1 ) is an ancestor of all var(z1 ), . . . , var(zm ) in T .
var(zi ) and var(zj ) are not in ancestor-descendant relation in T , ∀i 6= j.
output : v1 ⊗ (z1 ∧ . . . ∧ zm ), based on T .
if H1 (v1 , z1 , . . . , zm ) 6= null then return H1 (v1 , z1 , . . . , zm );
// is in cache
if (any of v1 , z1 , . . . , zm is 0) then return 0
if (v1 = 1) then return 1
if (m = 0) then return v1
// nothing to combine
create new nonterminal meta-node u
var(u) ← var(v1 ) (call it Xi , with domain Di = {x1 , . . . , xki } )
for j ← 1 to ki do
u.childrenj ← φ
// children of the j-th AND node of u
// assign weight from v1
wu (Xi , xj ) ← wv1 (Xi , xj )
if ( (m = 1) and (var(v1 ) = var(z1 ) = Xi ) ) then
temp Children ← z1 .childrenj
// combine input weights
wu (Xi , xj ) ← wv1 (Xi , xj ) ⊗ wz1 (Xi , xj )

Algorithm 3:

1
2
3
4
5
6
7
8
9
10
11
12
13
14

else

15
16
17
18
19

group nodes from v1 .childrenj ∪ temp Children in several {v 1 ; z 1 , . . . , z r }
for each {v 1 ; z 1 , . . . , z r } do
y ← APPLY(v 1 ; z 1 , . . . , z r )
if (y = 0) then
u.childrenj ← 0; break

20
21

temp Children ← {z1 , . . . , zm }

else
u.childrenj ← u.childrenj ∪ {y}

22
23
24

if (u.children1 = . . . = u.childrenki ) and (wu (Xi , x1 ) = . . . = wu (Xi , xki )) then
promote wu (Xi , x1 ) to parent
return u.children1
// redundancy

25
26

if (H2 (Xi , u.children1 , . . . , u.childrenki , wu (Xi , x1 ), . . . , wu (Xki , xki )) 6= null) then
return H2 (Xi , u.children1 , . . . , u.childrenki , wu (Xi , x1 ), . . . , wu (Xki , xki ))
// isomorphism

27 Let H1 (v1 , z1 , . . . , zm ) = u
28 Let H2 (Xi , u.children1 , . . . , u.childrenki , w u (Xi , x1 ), . . . , w u (Xki , xki )) = u
29 return u

// add u to H1
// add u to H2

from g expresses a decomposition with respect to T , so all those nodes appear on different branches.
We will employ the usual techniques from OBDDs to make the operation efficient. First, if one of
the arguments is 0, then we can safely return 0. Second, a hash table H1 is used to store the nodes
that have already been processed, based on the nodes (v1 , z1 , . . . , zr ). Therefore, we never need
to make multiple recursive calls on the same arguments. Third, a hash table H2 is used to detect
isomorphic nodes. This is typically split in separate tables for each variable. If at the end of the
recursion, before returning a value, we discover that a meta-node with the same variable, the same
children and the same weights has already been created, then we don’t need to store it and we simply
return the existing node. And fourth, if at the end of the recursion we discover that we created a
redundant node (all the children are the same and all the weights are the same), then we don’t store
it, and return instead one of its identical lists of children, and promote the common weight.
493

M ATEESCU , D ECHTER & M ARINESCU

A
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C
0
1
0
1
0
1
0
1

f(ABC)
0
0
0
1
0
1
0
1

A
0
0
0
0
1
1
1
1

A
B
C

A

A1
0

0

C

A3

*

0

A4

B2

A5

B3

0

B

B

D

D

1

D
1

D

C

A
0

0

0

A

A1B1
B

1

B4

A

1

B
0

1

1

g(ABC)
0
0
0
1
0
1
1
0

A
0

1

0

D
0
1
0
1
0
1
0
1

B1
1

B

A2

B
0
0
1
1
0
0
1
1

0

B6

=

B

A2B2

B7

0

1

C
0

B5

0

A4B6

1

A4

1

1

D

B4
1

0

B
0

1

D

B7
1

0

1

1

Figure 18: Example of APPLY operation
Note that v1 is always an ancestor of all z1 , . . . , zm in T . We consider a variable in T to be an
ancestor of itself. A few self explaining checks are performed in lines 1-4. Line 2 is specific for
multiplication, and needs to be changed for other combination operations. The algorithm creates a
new meta-node u, whose variable is var(v1 ) = Xi – recall that var(v1 ) is highest (closest to root)
in T among v1 , z1 , . . . , zm . Then, for each possible value of Xi , line 7, it starts building its list of
children.
One of the important steps happens in line 15. There are two lists of meta-nodes, one from
each original AOMDD f and g, and we will refer only to their variables, as they appear in T . Each
of these lists has the important property mentioned above, that its nodes are not ancestors of each
other. The union of the two lists is grouped into maximal sets of nodes, such that the highest node
in each set is an ancestor of all the others. It follows that the root node in each set belongs to one of
the original AOMDD, say v 1 is from f , and the others, say z 1 , . . . , z r are from g. As an example,
suppose T is the pseudo tree from Fig. 15(b), and the two lists are {C, G, H} from f and {E, F }
from g. The grouping from line 15 will create {C; E} and {F ; G, H}. Sometimes, it may be the
case that a newly created group contains only one node. This means there is nothing more to join
in recursive calls, so the algorithm will return, via line 4, the single node. From there on, only one
of the input AOMDDs is traversed, and this is important for the complexity of APPLY, discussed
below.
Example 12 Figure 18 shows the result of combining two Boolean functions by an AND operation
(or product). The input functions f and g are represented by AOMDDs based on chain pseudo
trees, while the results is based on the pseudo tree that expresses the decomposition after variables
A and B are instantiated. The APPLY operator performs a depth first traversal of the two input
AOMDDs, and generates the resulting AOMDD based on the output pseudo tree. Similar to the
case of OBDDs, a function or an AOMDD can be identified by its root meta-node. In this example
the input meta-nodes have labels (A1 , A2 , B1 , B2 , etc.). The output meta-node labeled by A2 B2 is
494

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

the root of a diagram that represents the function obtained by combining the functions rooted by A2
and B2 .
6.3 Complexity of APPLY and BE-AOMDD
We now provide a characterization of the complexity of APPLY, based on different criteria. The
following propositions are inspired by the results that govern OBDD apply complexity, but are
adapted for pseudo tree orderings.
An AOMDD along a pseudo tree can be regarded as a union of regular MDDs, each restricted
to a full path from root to a leaf in the pseudo tree. Let πT be such a path in T . Based on the
definition of strictly compatible pseudo trees, πT has corresponding paths πTf in Tf and πTg in Tg .
The MDDs from f and g corresponding to πTf and πTg can be combined using the regular MDD
apply. This process can be repeated for every path πT . The resulting MDDs, one for each path in T
need to be synchronized on their common parts (on the intersection of the paths). The algorithm we
proposed does all this processing at once, in a depth first search traversal over the inputs. Based on
our construction, we can give a first characterization of the complexity of AOMDD APPLY as being
governed by the complexity of MDD apply.
Proposition 2 Let π1 , . . . , πl be the set of paths in T enumerated from left to right and let Gfi and
Ggi be the MDDs restricted to path πi , then the size of the output of AOMDD apply
by
P
P is bounded
i | · |G i | ≤ n · max |G i | · |G i |. The time complexity is also bounded by
i | · |G i | ≤
|G
|G
i
g
g
g
i f
i f
f
n · maxi |Gfi | · |Ggi |.
A second characterization of the complexity can be given, similar to the MDD case, in terms of
total number of nodes of the inputs:
Proposition 3 Given two AOMDDs Gfaomdd and Ggaomdd based on strictly compatible pseudo trees,
the size of the output of APPLY is at most O(| Gfaomdd | · | Ggaomdd |).
We can further detail the previous proposition as follows. Given AOMDDs Gfaomdd and Ggaomdd ,
based on compatible pseudo trees Tf and Tg and the common pseudo tree T , we define the intersection pseudo tree Tf ∩g as being obtained from T by the following two steps: (1) mark all the
subtrees whose nodes belong to either Tf or Tg but not to both (the leaves of each subtree should be
leaves in T ); (2) remove the subtrees marked in step (1) from T . Steps (1) and (2) are applied just
once (that is, not recursively). The part of AOMDD Gfaomdd corresponding to the variables in Tf ∩g
is denoted by Gff ∩g , and similarly for Ggaomdd it is denoted by Ggf ∩g .
Proposition 4 The time complexity of
|Gfaomdd | + |Ggaomdd |).

APPLY

and the size of the output are O(|Gff ∩g | · |Ggf ∩g | +

We now turn to the complexity of the BE-AOMDD algorithm. Each bucket has an associated
bucket pseudo tree. The top chain of the bucket pseudo tree for variable Xi contains all and only
the variables in context(Xi ). For any other variables that appear in the bucket pseudo tree, their
associated buckets have already been processed. The original functions that belong to the bucket
of Xi have their scope included in context(Xi ), and therefore their associated AOMDDs are based
495

M ATEESCU , D ECHTER & M ARINESCU

on chains. Any other functions that appear in bucket of Xi are messages received from independent branches below. Therefore, any two functions in the bucket of Xi only share variables in the
context(Xi ), which forms the top chain of the bucket pseudo tree. We can therefore characterize
the complexity of APPLY in terms of treewidth, or context size of a bucket variable.
Proposition 5 Given two AOMDDs in the same bucket of BE-AOMDD, the time and space complexity of the APPLY between them is at most exponential in the context size of the bucket variable
(namely the number of the variables in the top chain of the bucket pseudo tree).
We can now bound the complexity of BE-AOMDD and the output size:
T HEOREM 5 The space complexity of BE-AOMDD and the size of the output AOMDD are
∗
O(n k w ), where n is the number of variables, k is the maximum domain size and w∗ is the treewidth
∗
of the bucket tree. The time complexity is bounded by O(r k w ), where r is the number of initial
functions.

7. AOMDDs Are Canonical Representations
It is well known that OBDDs are canonical representations of Boolean functions given an ordering
of the variables (Bryant, 1986), namely a strict ordering of any CNF specification of the same
Boolean function will yield an identical OBDD, and this property extends to MDDs (Srinivasan
et al., 1990). The linear ordering of the variables defines a chain pseudo tree that captures the
structure of the OBDD or MDD. In the case of AOBDDs and AOMDDs, the canonicity is with
respect to a pseudo tree, transitioning from total orders (that correspond to a linear ordering) to
partial orders (that correspond to a pseudo tree ordering). On the one hand we gain the ability to have
a more compact compiled structure, but on the other hand canonicity is no longer with respect to
all equivalent graphical models, but only relative to those graphical models that are consistent with
the pseudo tree that is used. Specifically, if we start from a strict ordering we can generate a chain
AOMDD that will be canonical relative to all equivalent graphical models. If however we want to
exploit additional decomposition we can use a partial ordering captured by a pseudo-tree and create
a more compact AOMDD. This AOMDD however is canonical relative to those equivalent graphical
models that can accept the same pseudo tree that guided the AOMDD. In general, AOMDD can be
viewed as a more flexible framework for compilation that allows both partial and total orderings.
Canonicity is restricted to a subset of graphical models whose primal graph agrees with the partial
order but it is relevant to a larger set of orderings which are consistent with the pseudo-tree.
In the following subsection we discuss the canonicity of AOMDD for constraint networks. The
case of general weighted graphical models is discussed in Section 8.
7.1 AOMDDs for Constraint Networks Are Canonical Representations
The case of constraint networks is more straightforward, because the weights on the OR-to-AND
arcs can only be 0 or 1. We will show that any equivalent constraint networks, that admit the same
pseudo tree T , have the same AOMDD based on T . We start with a proposition that will help prove
the main theorem.
Proposition 6 Let f be a function, not always zero, defined by a constraint network over X. Given
a partition {X1 , . . . , Xm } of the set of variables X (namely, Xi ∩ Xj = φ, ∀ i 6= j, and X =
496

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

i
i
∪m
i=1 X ), if f = f1 ⊗ . . . ⊗ fm and f = g1 ⊗ . . . ⊗ gm , such that scope(fi ) = scope(gi ) = X for
all i ∈ {1, . . . , m}, then fi = gi for all i ∈ {1, . . . , m}. Namely, if f can be decomposed over the
given partition, then the decomposition is unique.

We are now ready to show that AOMDDs for constraint networks are canonical representations
given a pseudo tree.
T HEOREM 6 (AOMDDs are canonical for a given pseudo tree) Given a constraint network, and
a pseudo tree T of its constraint graph, there is a unique (up to isomorphism) AOMDD that represents it, and it has the minimal number of meta-nodes.
A constraint network is defined by its relations (or functions). There exist equivalent constraint
networks that are defined by different sets of functions, even having different scope signatures.
However, equivalent constraint networks define the same function, and we can ask if the AOMDD
of different equivalent constraint networks is the same. The following corollary can be derived
immediately from Theorem 6.
Corollary 1 Two equivalent constraint networks that admit the same pseudo tree T have the same
AOMDD based on T .

8. Canonical AOMDDs for Weighted Graphical Models
Theorem 6 ensures that the AOMDD is canonical for constraint networks, namely for functions that
can only take the values 0 or 1. The proof relied on the fact that the OR-to-AND weights can only
be 0 or 1, and on Proposition 6 that ensured the unique decomposition of a function defined by a
constraint network.
In this section we turn to general weighted graphical models. We can first observe that Proposition 6 is no longer valid for general functions. This is because the valid solutions (having strictly
positive weight) can have their weight decomposed in more than one way into a product of positive
weights.
Therefore we raise the issue of recognizing nodes that root AND/OR graphs that represent the
same universal function, even though the graphical representation is different. We will see that the
AOMDD for a weighted graphical model is not unique under the current definitions, but we can
slightly modify them to obtain canonicity again. We have to note that canonicity of AOMDDs for
weighted graphical models (e.g., belief networks) is far less crucial than in the case of OBDDs that
are used in formal verification. Even more than that, sometimes it may be useful not to eliminate
the redundant nodes, in order to maintain a simpler semantics of the AND/OR graph that represents
the model.
The loss of canonicity of AOMDD for weighted graphical models can happen because of the
weights on the OR-to-AND arcs, and we suggest a possible way of re-enforcing it if a more compact
and canonical representation is needed.
Example 13 Figure 19 shows a weighted graphical model, defined by two (cost) functions,
f (M, A, B) and g(M, B, C). Assuming the order (M,A,B,C), Figure 20 shows the AND/OR search
tree on the left. The arcs are labeled with function values, and the leaves show the value of the
corresponding full assignment (which is the product of numbers on the arcs of the path). We can
497

M ATEESCU , D ECHTER & M ARINESCU

A

M
0
0
0
0
1
1
1
1

M
A

M

B
B
C

C

A
0
0
1
1
0
0
1
1

B f(M,A,B)
0
12
1
5
0
18
1
2
0
4
1
10
0
6
1
4

M
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C g(M,B,C)
0
3
1
5
0
14
1
12
0
9
1
15
0
7
1
6

Figure 19: Weighted graphical model
M
0

1

0

1

A

A

A

A

0

1

B

0

B

5

18

2

0

1

0

1

C

C

5

0

1

36 60

14
0

C

3

5

1

0

1

70 60

54 90

14
0

0

B

4

10

0

C

12

1

B

12

3

M

C

B

6

1

0

C

C

9

15

7

6

9

15

7

1

0

1

0

1

0

1

0

36 60

70 60

54 90

0

B

12

5

18

2

1

0

1

0

1

C

6
1

28 24

5

0

1

14
0

B

4
0

C

3

1

B

4

C

12

28 24

1

10

6

4

1

0

1

C

C

12

9

15

7

6

1

0

1

0

1

36 60

Figure 20: AND/OR search tree and context minimal graph

see that either value of M (0 or 1) gives rise to the same function (because the leaves in the two
subtrees have the same values). However, the two subtrees can not be identified as representing the
same function by the usual reduction rules. The right part of the figure shows the context minimal
graph, which has a compact representation of each subtree, but does not share any of their parts.
What we would like in this case is to have a method of recognizing that the left and right subtrees
corresponding to M = 0 and M = 1 represent the same function. We can do this by normalizing
the values in each level, and processing bottom up. In Figure 21 left, the values on the OR-to-AND
arcs have been normalized, for each OR variable, and the normalization constant was promoted
up to the OR value. In Figure 21 right, the normalization constants are promoted upwards again
by multiplication. This process does not change the value of each full assignment, and therefore
produces equivalent graphs.
We can see already that some of the nodes labeled by C can now be merged, producing the graph
in Figure 22 on the left. Continuing the same process we obtain the AOMDD for the weighted graph,
shown in Figure 22 on the right.
We can define the AOMDD of a weighted graphical model as follows:
D EFINITION 26 (AOMDD of weighted graphical model) The AOMDD of a weighted graphical
model is an AND/OR graph, with meta-nodes, such that: (1) for each meta-node, its weights sum to
1; (2) the root meta-node has a constant associated with it; (3) it is completely reduced, namely it
has no isomorphic meta-nodes, and no redundant meta-nodes.

498

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

M
M

0

1

A

A

0

1

B

0

B

B

12

5

18

2

0

1

0

1

8
3/8
0

5/8

14/26

1

0

12/26

3/8

6

4

1

0

1

1

0

14/26

1

0

1

26*5

0

1

3/8

26*2

0

1

1

0

7/13

1

0

B

24*4

13*10

0

24*6

1

C

5/8

1

B

8*18

C

12/26

0

B

8*12

13 C
5/8

A

B

10

24 C

1

A
0

B

4
0

26 C

C

1

0

13*4

0

1

C

6/13

C

3/8

1

5/8

0

7/13

1

0

6/13
1

Figure 21: Normalizing values bottom up
844

M

1/2
0

M

1/2

1
0

A

1

A
A

0

1

B

96
0

0

B

130

144

1

0

1

B

52
1

96
0

B

130

144

1

0

C

3/8
0

1

7/13
0

196/422

0

1

B

52

B

96/226

1

130/226

0

1

C

5/8

226/422

144/196

52/196

0

1

C

6/13

3/8

1

0

C

5/8
1

7/13
0

6/13
1

Figure 22: AOMDD for the weighted graph
The procedure of transforming a weighted AND/OR graph into an AOMDD is very similar to
Procedure B OTTOM U P R EDUCTION from Section 5. The only difference is that when a new layer
is processed, first the meta-node weights are normalized and promoted to the parent, and then the
procedure continues as usual with the reduction rules.
T HEOREM 7 Given two equivalent weighted graphical models that accept a common pseudo tree
T , normalizing arc values together with exhaustive application of reduction rules yields the same
AND/OR graph, which is the AOMDD based on T .
Finite Precision Arithmetic The implementation of the algorithm described in this section may
prove to be challenging on machines that used finite precision arithmetic. Since the weights are
real-valued, the repeated normalization may lead to precision errors. One possible approach, which
we also used in our experiments, is to define some ε-tolerance, for some user defined sufficiently
small ε, and consider the weights to be equal if they are within ε of each other.

9. Semantic Treewidth
A graphical model M represents a universal function F = ⊗fi . The function F may be represented
by different graphical models. Given a particular pseudo tree T , that captures some of the structural
information of F , we are interested in all the graphical models that accept T as a pseudo tree, namely
their primal graphs only contain edges that are backarcs in T . Since the size of the AOMDD for F
based on T is bounded in the worst case by the induced width of the graphical model along T , we
define the semantic treewidth to be:
499

M ATEESCU , D ECHTER & M ARINESCU

1
A

2

3

B
C

C

o
B

o

1

2

A

3

4

o
o

C
D

A

o

D

B

4

o

A B
1 3
1 4
2 4
3 1
4 1
4 2

o
o

(a) The two solutions

A C
1 2
1 4
2 1
2 3
3 2
3 4
4 1
4 3

A D
1 2
1 3
2 1
2 3
2 4
3 1
3 2
3 4
4 2
4 3

D
B C
1 3
1 4
2 4
3 1
4 1
4 2

B D
1 2
1 4
2 1
2 3
3 2
3 4
4 1
4 3

C D
1 3
1 4
2 4
3 1
4 1
4 2

(b) First model

A

A B
2 4
3 1

B

C

B C
1 4
4 1

D

C D
1 3
4 2

(c) Second model

Figure 23: The 4-queen problem
D EFINITION 27 (semantic treewidth) The semantic treewidth of a graphical model M relative
to a pseudo tree T denoted by swT (M), is the smallest treewidth taken over all models R that
are equivalent to M, and accept the pseudo tree T . Formally, it is defined by swT (M) =
minR,u(R)=u(M) wT (R), where u(M) is the universal function of M, and wT (R) is the induced
width of R along T . The semantic treewidth of a graphical model, M, is the minimal semantic
treewidth over all the pseudo trees that can express its universal function.
Computing the semantic treewidth can be shown to be NP-hard.3
T HEOREM 8 Computing the semantic treewidth of a graphical model M is NP-hard.
Theorem 8 shows that computing the semantic treewidth is hard, and it is likely that the actual
complexity is even higher. However, the semantic treewidth can explain why sometimes the minimal
AND/OR graph or OBDD are much smaller than the exponential in treewidth or pathwidth upper
bounds. In many cases, there could be a huge disparity between the treewidth of M and the semantic
treewidth along T .
Example 14 Figure 23(a) shows the two solutions of the 4-queen problem. The problem is expressed by a complete graph of treewidth 3, given in Figure 23(b). Figure 23(c) shows an equivalent
problem (i.e., that has the same set of solutions), which has treewidth 1. The semantic treewidth of
the 4-queen problem is 1.
Based on the fact that an AOMDD is a canonical representation of the universal function of a
graphical model, we can conclude that the size of the AOMDD is bounded exponentially by the
semantic treewidth along the pseudo tree, rather than the treewidth of the given graphical model
representation.
Proposition 7 The size of the AOMDD of a graphical model M is bounded by O(n k swT (M )),
where n is the number of variables, k is the maximum domain size and swT (M) is the semantic
treewidth of M along the pseudo tree T .
3. We thank David Eppstein for the proof.

500

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

A
A

B

B

C

C

B

M

D

D

C

N

D

P

0

1

(a) OBDD representation

(b) Primal graph with hidden
variables M, N and P .

Figure 24: The parity function
Example 15 Consider a constraint network on n variables such that every two variables are constrained by equality (X = Y ). One graph representation is a complete graph, another is a chain
and another is a tree. If the problem is specified as a complete graph, and if we use a linear order,
the OBDD will have a linear size because there exists a representation having a pathwidth of 1
(rather than n).
While the semantic treewidth can yield a much better upper bound on the AOMDD, it can also
be a very bad bound. It is well known that the parity function on n variables has a very compact,
chain-like OBDD representation. Yet, the only constraint network representation of a parity function
is the function itself (namely a complete graph on all the variables), whose treewidth and semantic
treewidth is its number of variables, n. The OBDD representation of the parity function suggests
that the addition of hidden variables can simplify its presentation. We show an example in Figure
24. On the left side, in Figure 24(a) we have the OBDD representation of the parity function for
four binary variables. A graphical model would represent this function by a complete graph on the
four variables. However, we could add the extra variables M, N and P in Figure 24(b), sometimes
called “hidden” variables, that can help decompose the model. In this case M can form a constraint
together with A and B such that M represents the parity of A and B, namely M = 1 if A ⊕ B = 1,
where ⊕ is the parity (XOR) operator. Similarly, N would capture the parity of M and C, and P
would capture the parity of N and D, and would also give the parity of the initial four variables.
The two structures are surprisingly similar. It would be interesting to study further the connection
between hidden variables and compact AOBDDs, but we leave this for future work.

10. Experimental Evaluation
Our experimental evaluation is in preliminary stages, but the results we have are already encouraging. We ran the search-based compile algorithm, by recording the trace of the AND/OR search, and
then reducing the resulting AND/OR graph bottom up. In these results we only applied the reduction by isomorphism and still kept the redundant meta-nodes. We implemented our algorithms in
C++ and ran all experiments on a 2.2GHz Intel Core 2 Duo with 2GB of RAM, running Windows.

501

M ATEESCU , D ECHTER & M ARINESCU

10.1 Benchmarks
We tested the performance of the search-based compilation algorithm on random Bayesian networks, instances from the Bayesian Network Repository and a subset of networks from the UAI’06
Inference Evaluation Dataset.
Random Bayesian Networks The random Bayesian networks were generated using parameters
(n, k, c, p), where n is the number of variables, k is the domain size, c is the number of conditional
probability tables (CPTs) and p is the number of parents in each CPT. The structure of the network
was created by randomly picking c variables out of n and, for each, randomly picking p parents from
their preceding variables, relative to some ordering. The remaining n − c variables are called root
nodes. The entries of each probability table were generated randomly using a uniform distribution,
and the table was then normalized. It is also possible to control the amount of determinism in the
network by forcing a percentage det of the CPTs to have only 0 and 1 entries.
Bayesian Network Repository The Bayesian Network Repository4 contains a collection of belief
networks extracted from various real-life domains which are often used for benchmarking probabilistic inference algorithms.
UAI’06 Inference Evaluation Dataset The UAI 2006 Inference Evaluation Dataset5 contains a
collection of random as well as real-world belief networks that were used during the first UAI 2006
Inference Evaluation contest. For our purpose we selected a subset of networks which were derived
from the ISCAS’89 digital circuits benchmark.6 ISCAS’89 circuits are a common benchmark used
in formal verification and diagnosis. Each of these circuits was converted into a Bayesian network
by removing flip-flops and buffers in a standard way, creating a deterministic conditional probability
table for each gate, and putting uniform distributions on the input signals.
10.2 Algorithms
We consider two search-based compilation algorithms, denoted by AOMDD-BCP and AOMDDSAT, respectively, that reduce the context minimal AND/OR graph explored via isomorphism, while
exploiting the determinism (if any) present in the network. The approach we take for handling the
determinism is based on unit resolution over a CNF encoding (i.e., propositional clauses) of the zero
probability tuples of the CPTs. The idea of using unit resolution during search for Bayesian networks was first explored by Allen and Darwiche (2003). AOMDD-BCP is conservative and applies
only unit resolution at each node in the search graph, whereas AOMDD-SAT is more aggressive and
detects inconsistency by running a full SAT solver. We used the zChaff SAT solver (Moskewicz,
Madigan, Zhao, Zhang, & Malik, 2001) for both unit resolution as well as full satisfiability. For
comparison, we also ran an OR version of AOMDD-BCP, called MDD-BCP.
For reference we also report results obtained with the ACE7 compiler. ACE compiles a Bayesian
network into an Arithmetic Circuit (AC) and then uses the AC to answer multiple queries with respect to the network. An arithmetic circuit is a representation that is equivalent to AND/OR graphs
(Mateescu & Dechter, 2007). Each time ACE compiler is invoked, it uses one of two algorithms
as the basis for compilation. First, if an elimination order can be generated for the network having
4.
5.
6.
7.

http://www.cs.huji.ac.il/compbio/Repository/
http://ssli.ee.washington.edu/bilmes/uai06InferenceEvaluation
Available at: http://www.fm.vslib.cz/kes/asic/iscas/
Available at: http://reasoning.cs.ucla.edu/ace

502

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Network

(w*, h)

(n, k)

ACE
#nodes time

MDD w/ BCP
AOMDD w/ BCP
AOMDD w/ SAT
#meta #cm(OR) time
#meta #cm(OR)
time #meta #cm(OR)
time
Bayesian Network Repository
alarm
(4, 13) (37, 4)
1,511 0.01 208,837 682,195 73.35
320
459
0.05
320
459
0.22
cpcs54
(14, 23) (54, 2)
196,933 0.06
- 65,158 66,405
6.97 65,158 66,405
6.97
cpcs179
(8, 14) (179, 4)
67,919 0.05
9,990 32,185 46.56 9,990 32,185 46.56
cpcs360b (20, 27) (360, 2) 5,258,826 1.72
diabetes
(4, 77) (413, 21) 7,615,989 1.81
hailfinder (4, 16) (56, 11)
8,815 0.01
2,068
2,202
0.34 1,893
2,202
1.48
mildew
(4, 13) (35, 100) 823,913 0.39
- 73,666 110,284 1367.81 62,903 65,599 3776.82
mm
(20, 57) (1220, 2)
47,171 1.49
- 38,414 58,144
4.54 30,274 52,523 99.55
munin2
(9, 32) (1003, 21) 2,128,147 1.91
munin3
(9, 32) (1041, 21) 1,226,635 1.27
munin4
(9, 32) (1044, 21) 2,423,009 4.44
pathfinder (6, 11) (109, 63)
18,250 0.05 610,854 1,303,682 352.18
6,984 16,267 30.71 2,265 15,963 50.36
pigs
(11, 26) (441, 3) 636,684 0.19
- 261,920 294,101 174.29 198,284 294,101 1277.72
water
(10, 15) (32, 4)
59,642 0.52 707,283 1,138,096 95.14 18,744 20,926
2.02 18,503 19,225
7.45
UAI’06 Evaluation Dataset
BN 42
(21, 62) (851, 2)
4,860 1.35
- 107,025 341,428 53.50 42,445 43,280 57.36
BN 43
(26, 65) (851, 2)
10,373 1.62
- 1,343,923 1,679,013 1807.63 313,388 314,669 434.38
BN 44
(25, 56) (851, 2)
4,235 1.31
- 155,588 187,589 20.90 47,222 48,540 66.09
BN 45
(22, 54) (851, 2)
12,319 1.50
- 390,795 487,593 68.81 126,182 126,929 177.50
BN 46
(20, 46) (851, 2)
5,912 2.90 1,125,658 1,228,332 94.93 16,711 17,532
1.31 7,337
7,513
5.54
BN 47
(39, 57) (632, 2)
1,448 1.17 42,419 47,128 2.87
1,873
2,663
0.24 1,303
2,614
2.36
BN 49
(40, 60) (632, 2)
1,408 1.16 18,344 19,251 1.32
1,205
1,539
0.19
952
1,515
1.34
BN 51
(41, 68) (632, 2)
1,467 1.15 63,851 68,005 4.22
4,442
5,267
0.50 3,653
5,195
4.58
BN 53
(47, 87) (532, 2)
1,357 0.91 14,210 19,162 1.49
4,819
9,561
0.74 1,365
1,719
1.36
BN 55
(49, 92) (532, 2)
1,288 0.93
5,168
6,088 0.57
1,972
2,816
0.26
790
904
0.75
BN 57
(49, 85) (532, 2)
1,276 0.90 48,436 51,611 3.52
4,036
5,089
0.37
962
1,277
1.01
BN 59
(52, 87) (511, 2)
1,749 0.93 332,030 353,720 25.61 22,963 29,146
2.14 10,655 18,752 14.17
BN 61
(41, 64) (638, 2)
1,411 1.10 20,459 20,806 1.45
1,244
1,589
0.17 1,016
1,528
1.37
BN 63
(53, 95) (511, 2)
1,324 0.90 11,461 17,087 1.28
7,182 14,048
1.07 1,419
2,177
1.69
BN 65
(56, 86) (411, 2)
1,184 0.75
- 20,764 23,102
1.52 12,569 19,778 12.90
BN 67
(54, 88) (411, 2)
1,031 0.74
- 179,067 511,031 154.91
716
1,169
0.78
Positive Random Bayesian Networks (n=75, k=2, p=2, c=65)
r75-1
(12, 22) (75, 2)
67,737 0.31
- 21,619 21,619
2.59 21,619 21,619
2.59
r75-2
(12, 23) (75, 2)
46,703 0.29
- 18,083 18,083
1.88 18,083 18,083
1.88
r75-3
(11, 26) (75, 2)
53,245 0.30
- 18,419 18,419
1.86 18,419 18,419
1.86
r75-4
(11, 19) (75, 2)
28,507 0.29
8,363
8,363
1.16 8,363
8,363
1.16
r75-5
(13, 24) (75, 2)
149,707 0.36
- 42,459 42,459
4.61 42,459 42,459
4.61
r75-6
(14, 24) (75, 2)
132,107 1.19
- 62,621 62,621
6.95 62,621 62,621
6.95
r75-7
(12, 24) (75, 2)
89,913 0.36
- 21,583 21,583
2.42 21,583 21,583
2.42
r75-8
(14, 24) (75, 2)
86,183 0.36
- 49,001 49,001
6.23 49,001 49,001
6.23
r75-9
(11, 19) (75, 2)
29,025 0.30
7,681
7,681
0.81 7,681
7,681
0.81
r75-10
(10, 24) (75, 2)
20,291 0.28
5,905
5,905
0.63 5,905
5,905
0.63
Deterministic Random Bayesian Networks (n=100, k=2, p=2, c=90) and det = 25% of the CPTs containing only 0 and 1 entries
r100d25-1 (13, 31) (100, 2)
68,398 0.38
- 34,035 34,075
2.94 34,035 34,075 12.77
r100d25-2 (16, 28) (100, 2) 150,134 0.46
- 70,241 70,931
7.72 70,241 70,931 27.17
r100d25-3 (16, 29) (100, 2) 705,200 0.96
- 134,079 135,203 13.80 134,079 135,203 50.51
r100d25-4 (16, 31) (100, 2) 161,902 0.54
- 79,366 79,488
7.26 79,366 79,488 28.06
r100d25-5 (16, 29) (100, 2) 185,348 0.53
- 140,627 140,636 14.57 140,627 140,636 49.42
r100d25-6 (18, 28) (100, 2) 148,835 0.66
- 204,232 210,066 17.56 197,134 210,066 92.24
r100d25-7 (16, 29) (100, 2) 264,629 0.60
- 134,344 135,008 14.26 133,850 135,008 55.60
r100d25-8 (17, 27) (100, 2)
65,186 0.46
- 36,857 36,887
2.95 36,857 36,887 11.97
r100d25-9 (14, 27) (100, 2) 140,014 0.40
- 58,421 59,791
6.88 58,172 59,791 23.21
r100d25-10 (16, 27) (100, 2) 173,808 0.58
- 69,110 69,136
7.50 69,110 69,136 26.50

Table 1: Results for experiments with 50 Bayesian networks from 3 problem classes; w∗ =
treewidth, h = depth of pseudo tree, n = number of variables, k = domain size, time
given in seconds; bold types highlight the best results across rows.

503

M ATEESCU , D ECHTER & M ARINESCU

sufficiently small induced width, then tabular variable elimination will be used as the basis. This
algorithm is similar to the one discussed by Chavira and Darwiche (2007), but uses tables to represent factors rather than ADDs. If the induced width is large, then logical model counting will be
used as the basis. Tabular variable elimination is typically efficient when width is small but cannot
handle networks when the width is larger. Logical model counting, on the other hand, incurs more
overhead than tabular variable elimination, but can handle many networks having larger treewidth.
Both tabular variable elimination and logical model counting produce ACs that exploit local structure, leading to efficient online inference. When logical model counting is invoked, it proceeds
by encoding the Bayesian network into a CNF (Chavira & Darwiche, 2005; Chavira, Darwiche, &
Jaeger, 2006), simplifying the CNF, compiling the CNF into a d-DNNF, and then extracting the AC
from the compiled d-DNNF. A dtree over the CNF clauses drives the compilation step.
In all our experiments we report the compilation time in seconds (time), the number of OR
nodes in the context minimal graph explored (#cm), the number of meta-nodes of the resulting
AOMDD (#meta), as well as the size of the AC compiled by ACE (#nodes). For each network we
specify the number of variables (n), domain size (k), induced width (w∗ ) and pseudo tree depth (h).
A ’-’ stands for exceeding the 2GB memory limit by the respective algorithm. The best performance
points are highlighted.
10.3 Evaluation on Bayesian Networks
Table 1 reports the results obtained for experiments with 50 Bayesian networks. The AOMDD
compilers as well as ACE used the min-fill heuristic (Kjæaerulff, 1990) to construct the guiding
pseudo tree and dtree, respectively.
10.3.1 BAYESIAN N ETWORKS R EPOSITORY
We see that ACE is overall the fastest compiler on this domain, outperforming both AOMDD-BCP
and AOMDD-SAT with up to several orders of magnitude (e.g., mildew, pigs). However, the
diagrams compiled by ACE and AOMDD-BCP (resp. AOMDD-SAT) are comparable in size. In
some cases, AOMDD-BCP and AOMDD-SAT were able to compile much smaller diagrams than
ACE. For example, the diagram produced by AOMDD-BCP for the mildew network is 13 times
smaller than the one compiled by ACE. In principle the output produced by ACE and AOMDD
should be similar if both are guided by the same pseudo tree/dtree. Our scheme should be viewed
as a compilation alternative which (1) extends decision diagrams and (2) mimics traces of search
properties that may make this representation accessible. The OR compiler MDD-BCP was able
to compile only 3 out of the 14 test instances, but their sizes were far larger than those produced
by AOMDD-BCP. For instance, on the pathfinder network, AOMDD-BCP outputs a decision
diagram almost 2 orders of magnitude smaller than MDD-BCP.
10.3.2 UAI’06 DATASET
For each of the UAI’06 Dataset instances we picked randomly 30 variables and instantiated as
evidence. We see that ACE is the best performing compiler on this dataset. AOMDD-BCP is
competitive with ACE in terms of compile time only on 9 out the 16 test instances. AOMDD-SAT
is able to compile the smallest diagrams for 6 networks only (e.g., BN 47, BN 49, BN 55, BN 57,
BN 61, BN 67). As before, the difference in size between the compiled data-structures produces
by MDD-BCP and AOMDD-BCP is up to 2 orders of magnitude in favor of the latter.
504

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

10.3.3 R ANDOM N ETWORKS
The problem instances denoted by r75-1 through r75-10 were generated from a class of random
belief networks with parameters (n = 75, k = 2, p = 2, c = 65). Similarly, the instances denoted
by r100d25-1 through r100d25-10 belong to a class with parameters (n = 100, k = 2, p = 2, c =
90). In the latter case, det = 25% of the CPTs are deterministic, namely they contain only 0 and
1 probability tuples. These test instances were compiled without any evidence. We see that on this
domain AOMDD-BCP/AOMDD-SAT were able to compile the smallest diagrams, which were on
average about 2 times smaller than those produced by ACE. However, ACE was again the fastest
compiler. Notice that the OR compiler MDD-BCP ran out of memory in all test cases.
10.4 The Impact of Variable Ordering
As theory dictates, the AOMDD size is influenced by the quality of the guiding pseudo tree. In
addition to the min-fill heuristic we also considered the hypergraph heuristic which constructs the
pseudo tree by recursively decomposing the dual hypergraph associated with the graphical model.
This idea was also explored by Darwiche (2001) for constructing dtrees that guide ACE.
Since both the min-fill and hypergraph partitioning heuristics are randomized (namely ties are
broken randomly), the size of the AOMDD guided by the resulting pseudo tree may vary significantly from one run to the next. Figure 25 displays the AOMDD size using hypergraph and min-fill
based pseudo trees for 6 networks selected from Table 1, over 20 independent runs. We also record
the average induced width and depth obtained for the pseudo trees (see the header of each plot in
Figure 25). We see that the two heuristics do not dominate each other, namely the variance in output
size is quite significant in both cases.
10.5 Memory Usage
Table 2 shows the memory usage (in MBytes) of ACE, AOMDD-BCP and AOMDD-SAT, respectively, on the Bayesian networks from Table 1. We see that in some cases the AOMDD based compilers require far less memory than ACE. For example, on the “mildew” network, both AOMDDBCP and AOMDD-SAT use about 22 MB of memory to compile the AND/OR decision diagram,
while ACE requires as much as 218 MB of memory. Moreover, the compiled AOMDD has in this
case about one order of magnitude fewer nodes than that constructed by ACE. When comparing the
two AND/OR search-based compilers, we observe that on networks with a significant amount of
determinism, such as those from the UAI’06 Evaluation dataset, AOMDD-SAT uses on average two
times less memory than AOMDD-BCP. The most dramatic savings in memory usage due to the aggressive constraint propagation employed by AOMDD-SAT compared with AOMDD-BCP can be
seen on the “BN 67” network. In this case, the difference in memory usage between AOMDD-SAT
and AOMDD-BCP is about 2 orders of magnitude in favor of the former.

11. Related Work
The related work can be viewed along two directions: (1) the work related to the AND/OR search
idea for graphical models and (2) the work related to compilation for graphical models that exploits
problem structure.
An extensive discussion for (1) was provided in the previous work of Dechter and Mateescu
(2007). Since this is not the focus of the paper, we just mention that the AND/OR idea was origi505

M ATEESCU , D ECHTER & M ARINESCU

Figure 25: Effect of variable ordering.

506

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Network

ACE
AOMDD w/ BCP
AOMDD w/ SAT
#nodes memory (MB) #nodes memory (MB) #nodes memory (MB)
Bayesian Network Repository
alarm
1,511
0.00
320
0.0206
320
0.0206
cpcs54
196,933
4.00 65,158
3.4415 65,158
3.4415
cpcs179
67,919
5.00
9,990
1.9263 9,990
1.9263
cpcs360b 5,258,826
204.00
diabetes
7,615,989
449.00
hailfinder
8,815
0.00
2,068
0.1576 1,893
0.1740
mildew
823,913
218.00 73,666
22.5781 62,903
22.1467
mm
47,171
369.00 38,414
1.5719 30,274
1.3711
munin2
2,128,147
202.00
munin3
1,226,635
150.00
munin4
2,423,009
n/a
pathfinder
18,250
10.00
6,984
0.6009 2,265
0.3515
pigs
636,684
31.00 261,920
23.3761 198,284
17.7096
water
59,642
161.00 18,744
1.09578 18,503
1.3258
UAI’06 Evaluation Dataset
BN 42
4,860
n/a 107,025
4.5622 42,445
1.9323
BN 43
10,373
n/a 1,343,923
57.8422 313,388
14.2828
BN 44
4,235
n/a 155,588
6.5613 47,222
2.1628
BN 45
12,319
n/a 390,795
17.9325 126,182
5.7958
BN 46
5,912
n/a
16,711
0.6929 7,337
0.3401
BN 47
1,448
n/a
1,873
0.0720 1,303
0.0583
BN 49
1,408
n/a
1,205
0.0449
952
0.0409
BN 51
1,467
n/a
4,442
0.1689 3,653
0.1633
BN 53
1,357
n/a
4,819
0.1814 1,365
0.0587
BN 55
1,288
n/a
1,972
0.0723
790
0.0336
BN 57
1,276
n/a
4,036
0.1495
962
0.0411
BN 59
1,749
n/a
22,963
0.8501 10,655
0.4587
BN 61
1,411
n/a
1,244
0.0463 1,016
0.0445
BN 63
1,324
n/a
7,182
0.2728 1,419
0.0607
BN 65
1,184
n/a
20,764
0.7539 12,569
0.5384
BN 67
1,031
n/a 179,067
6.9603
716
0.0304
Positive Random Bayesian Networks with parameters (n=75, k=2, p=2, c=65)
r75-1
67,737
1.00 21,619
1.2503 21,619
1.2503
r75-2
46,703
1.00 18,083
0.9957 18,083
0.9957
r75-3
53,245
1.00 18,419
0.9955 18,419
0.9955
r75-4
28,507
1.00
8,363
0.5171 8,363
0.5171
r75-5
149,707
3.00 42,459
2.3299 42,459
2.3299
r75-6
132,107
3.00 62,621
3.4330 62,621
3.4330
r75-7
89,913
2.00 21,583
1.1942 21,583
1.1942
r75-8
86,183
2.00 49,001
2.8130 49,001
2.8130
r75-9
29,025
1.00
7,681
0.4124 7,681
0.4124
r75-10
20,291
1.00
5,905
0.3261 5,905
0.3261
Deterministic Random Bayesian Networks with parameters (n=100, k=2, p=2, c=90)
r100d25-1
68,398
5.00 34,035
1.6290 34,035
1.7149
r100d25-2 150,134
10.00 70,241
3.6129 70,241
3.7810
r100d25-3 705,200
40.00 134,079
6.6372 134,079
6.9873
r100d25-4 161,902
22.00 79,366
3.8113 79,366
4.0079
r100d25-5 185,348
15.00 140,627
7.0839 140,627
7.4660
r100d25-6 148,835
37.00 204,232
9.1757 197,134
9.6542
r100d25-7 264,629
19.00 134,344
6.9619 133,850
6.9961
r100d25-8
65,186
21.00 36,857
1.6872 36,857
1.8278
r100d25-9 140,014
6.00 58,421
3.1058 58,172
3.2055
r100d25-10 173,808
27.00 69,110
3.5578 69,110
3.6636

Table 2: Memory usage in MBytes of ACE, AOMDD-BCP and AOMDD-SAT on the 50 Bayesian
networks from Table 1. Bold types highlight the best performance across rows. The “n/a”
indicates that the respective memory usage statistic was not available from ACE’s output.

507

M ATEESCU , D ECHTER & M ARINESCU

nally developed for heuristic search (Nilsson, 1980). As mentioned in the introduction, the AND/OR
search for graphical models is based on a pseudo tree that spans the graph of the model, similar to
the tree rearrangement of Freuder and Quinn (1985, 1987). The idea was adapted for distributed
constraint satisfaction by Collin et al. (1991, 1999) and more recently by Modi et al. (2005), and was
also shown to be related to graph-based backjumping (Dechter, 1992). This work was extended by
Bayardo and Miranker (1996), Bayardo and Schrag (1997) and more recently applied to optimization tasks by Larrosa et al. (2002). Another version that can be viewed as exploring the AND/OR
graphs was presented recently for constraint satisfaction (Terrioux & Jégou, 2003b) and for optimization (Terrioux & Jégou, 2003a). Similar principles were introduced recently for probabilistic
inference, in algorithm Recursive Conditioning (Darwiche, 2001) as well as in Value Elimination
(Bacchus et al., 2003b, 2003a), and are currently at the core of the most advanced SAT solvers (Sang
et al., 2004).
For direction (2), there are various lines of related research. The formal verification literature,
beginning with the work of Bryant (1986) contains a very large number of papers dedicated to the
study of BDDs. However, BDDs are in fact OR structures (the underlying pseudo tree is a chain)
and do not take advantage of the problem decomposition in an explicit way. The complexity bounds
for OBDDs are based on pathwidth rather than treewidth.
As noted earlier, the work of Bertacco and Damiani (1997) on Disjoint Support Decomposition
(DSD) is related to AND/OR BDDs in various ways. The main common aspect is that both approaches show how structure decomposition can be exploited in a BDD-like representation. DSD
is focused on Boolean functions and can exploit more refined structural information that is inherent to Boolean functions. In contrast, AND/OR BDDs assume only the structure conveyed in the
constraint graph, and are therefore more broadly applicable to any constraint expression and also
to graphical models in general. They allow a simpler and higher level exposition that yields graphbased bounds on the overall size of the generated AOMDD. The full relationship between these two
formalisms should be studied further.
McMillan (1994) introduced the BDD trees, along with the operations for combining them. For
2w
circuits of bounded tree width, BDD trees have a linear space upper bound of O(|g|2w2 ), where
|g| is the size of the circuit g (typically linear in the number of variables) and w is the treewidth. This
bound hides some very large constants to claim the linear dependence on |g| when w is bounded.
However, McMillan maintains that when the input function is a CNF expression BDD-trees have
the same bounds as AND/OR BDDs, namely they are exponential in the treewidth only.
To sketch just a short comparison between McMillan’s BDD trees and AOMMDs, consider an
example where we have a simple pseudo tree with root α, left child β and right child γ. Each of
these nodes may stand for a set of variables. In BDD trees, the assignments to β are grouped into
equivalence classes according to the cofactors generated by them on the remaining α and γ. For
example assignments β1 and β2 are equivalent if they generate the same function on α and γ. The
node β can be represented by a BDD whose leaves are the cofactors. The same is done for γ. The
node α is then represented by a matrix of BDDs, where each column corresponds to a cofactor of β
and each line to a cofactor of γ. By contrast, an AOMDD represents the node α as a BDD whose
leaves are the cofactors (the number of distinct functions on β and γ) and then each cofactor is the
root of a decomposition (an AND node) between β and γ. Moreover, the representations of β (as
descendants of different cofactor of α) are shared as much as possible and the same goes for γ. This
is only a high level description, that becomes slightly more complicated when redundant nodes are
eliminated, but the idea remains the same.
508

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

The AND/OR structure restricted to propositional theories is very similar to deterministic decomposable negation normal form (d-DNNF) (Darwiche & Marquis, 2002; Darwiche, 2002). More
recently, Huang and Darwiche (2005b) used the trace of the DPLL algorithm to generate an OBDD,
and compared with the typical formal verification approach of combining the OBDDs of the input
function according to some schedule. The structures that were investigated in that case are still OR.
This idea is extended in our present work by the AND/OR search compilation algorithm.
McAllester, Collins, and Pereira (2004) introduced the case factor diagrams (CFD), which subsume Markov random fields of bounded tree width and probabilistic context free grammars (PCFG).
CFDs are very much related to the AND/OR graphs. The CFDs target the minimal representation,
by exploiting decomposition (similar to AND nodes) but also by exploiting context sensitive information and allowing dynamic ordering of variables based on context. CFDs do not eliminate the
redundant nodes, and part of the cause is that they use zero suppression. There is no claim about
CFDs being canonical forms, and also no description of how to combine two CFDs.
There are numerous variants of decision diagrams that are designed to represent integer-valued
or real-valued functions. For a comprehensive view we refer the reader to the survey of Drechsler
and Sieling (2001). Algebraic decision diagrams (ADDs) (Bahar et al., 1993) provide a compilation for general real-valued rather than Boolean functions. Their main drawback is that their
size increases very fast if the number of terminals becomes large. There are several approaches
that try to alleviate this problem. However the structure that they capture is still OR, and they
do not exploit decomposition. Some alternatives introduce edge values (or weights) that enable
more subgraph sharing. Edge-valued binary decision diagrams (EVBDDs) (Lai & Sastry, 1992)
use additive weights, and when multiplicative weights are also allowed they are called factored
EVBDDs (FEVBDDs) (Tafertshofer & Pedram, 1997). Another type of BDDs called K*BMDs
(Drechsler, Becker, & Ruppertz, 1996) also use integer weights, both additive and multiplicative
in parallel. ADDs have also been extended to affine ADDs (Sanner & McAllester, 2005), through
affine transformations that can achieve more compression. The result was shown to be beneficial
for probabilistic inference algorithms, such as tree clustering, but they still do not exploit the AND
structure.
More recently, independently and in parallel to our work on AND/OR graphs (Dechter & Mateescu, 2004a, 2004b), Fargier and Vilarem (2004) and Fargier and Marquis (2006, 2007) proposed the compilation of CSPs into tree-driven automata, which have many similarities to our work.
Their main focus is the transition from linear automata to tree automata (similar to that from OR
to AND/OR), and the possible savings for tree-structured networks and hyper-trees of constraints
due to decomposition. Their compilation approach is guided by a tree-decomposition while ours is
guided by a variable-elimination based algorithms. And it is well known that Bucket Elimination
and cluster-tree decomposition are in principle the same (Dechter & Pearl, 1989).
Wilson (2005) extended OBDDs to semi-ring BDDs. The semi-ring treatment is restricted to
the OR search spaces, but allows dynamic variable ordering. It is otherwise very similar in aim and
scope to our AOMDD. When restricting the AOMDD to OR graphs only, the two are closely related,
except that we express BDDs using the Shenoy-Shafer axiomatization that is centered on the two
operation of combination and marginalization rather then on the semi-ring formulation. Minimality
in the formulation of Wilson (2005) is more general allowing merging nodes having different values
and therefore it can capture symmetries (called interchangeability).
Another framework very similar to AOMDDs, that we became aware of only recently, is Probabilistic Decision Graphs (PDG) of Jaeger (2004). This work preceded most of the relevant work
509

M ATEESCU , D ECHTER & M ARINESCU

we discussed above (Fargier & Vilarem, 2004; Wilson, 2005) and went somewhat unnoticed, perhaps due to notational and cultural differences. It is however similar in motivation, framework and
proposed algorithms. We believe our AND/OR framework is more accessible. We define the framework over multi-valued domains, provide greater details in algorithms and complexity analysis,
make an explicit connection with search frameworks, fully address the issues of canonicity as well
as provide an empirical demonstration. In particular, the claim of canonicity for PDGs is similar to
the one we make for AOMDDs of weighted models, in that it is relative to the trees (or forests) that
can represent the given probability distribution.
There is another line of research by Drechsler and his group (e.g. Zuzek, Drechsler, & Thornton,
2000), who use AND/OR graphs for Boolean function representation, that may seem similar to our
approach. However, the semantics and purpose of their AND/OR graphs are different. They are
constructed based on the technique of recursive learning and are used to perform Boolean reasoning,
i.e. to explore the logic consequences of a given assumption based on the structure of the circuit,
especially to derive sets of implicants. The meaning of AND and OR in their case is related to
the meaning of the gates/functions, while in our case the meaning is not related to the semantic of
the functions. The AND/OR enumeration tree that results from a circuit according to Zuzek et al.
(2000) is not related to the AND/OR decomposition that we discuss.

12. Conclusion
We propose the AND/OR multi-valued decision diagram (AOMDD), which emerges from the study
of AND/OR search spaces for graphical models (Dechter & Mateescu, 2004a, 2004b; Mateescu &
Dechter, 2005; Dechter & Mateescu, 2007) and ordered binary decision diagrams (OBDDs) (Bryant,
1986). This data-structure can be used to compile any graphical model.
Graphical models algorithms that are search-based and compiled data-structures such as BDDs
differ primarily by their choices of time vs. memory. When we move from regular OR search
space to an AND/OR search space the spectrum of algorithms available is improved for all time
vs. memory decisions. We believe that the AND/OR search space clarifies the available choices
and helps guide the user into making an informed selection of the algorithm that would fit best the
particular query asked, the specific input function and the available computational resources.
The contribution of our work is: (1) We formally describe the AOMDD and prove that it is a
canonical representation of a constraint network. (2) We extend the AOMDD to general weighted
graphical models. (3) We give a compilation algorithm based on AND/OR search, that saves the
trace of a memory intensive search (the context minimal AND/OR graph), and then reduces it
in one bottom up pass. (4) We describe the APPLY operator that combines two AOMDDs by an
operation and show that its complexity is quadratic in the input, but never worse than exponential
in the treewidth. (5) We give a scheduling order for building the AOMDD of a graphical model
starting with the AOMDDs of its functions which is based on a Variable Elimination algorithm.
This guarantees that the complexity is at most exponential in the induced width (treewidth) along the
ordering. (6) We show how AOMDDs relate to various earlier and recent compilation frameworks,
providing a unifying perspective for all these methods. (7) We introduce the semantic treewidth,
which helps explain why compiled decision diagrams are often much smaller than the worst case
bound. Finally, (8) we provide a preliminary empirical demonstration of the power of the current
scheme.

510

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

Acknowledgments
This work was done while Robert Mateescu and Radu Marinescu were at the University of California, Irvine. The authors would like to thank the anonymous reviewers for their constructive
suggestions to improve the paper, David Eppstein for a useful discussion of complexity issues, and
Lars Otten and Natasha Flerova for comments on the final version of the manuscript. This work was
supported by the NSF grants IIS-0412854 and IIS-0713118, and the initial part by the Radcliffe fellowship 2005-2006 (through the partner program), with Harvard undergraduate student John Cobb.

Appendix
Proof of Proposition 1
Consider the level of variable Xi , and the meta-nodes in the list LXi . After one pass through the
meta-nodes in LXi (the inner for loop), there can be no two meta-nodes at the level of Xi in the
AND/OR graph that are isomorphic, because they would have been merged in line 6. Also, during
the same pass through the meta-nodes in LXi all the redundant meta-nodes in LXi are eliminated
in line 8. Processing the meta-nodes in the level of Xi will not create new redundant or isomorphic
meta-nodes in the levels that have been processed before. It follows that the resulting AND/OR
graph is completely reduced. 2
Proof of Theorem 4
The bound on the size follows directly from Theorem 3. The AOMDD size can only be smaller than
∗
the size of the context minimal AND/OR graph, which is bounded by O(n k wT (G) ). To prove the
time bound, we have to rely on the use of the hash table, and the assumption that an efficient implementation allows an access time that is constant. The time bound of AND/OR-S EARCH -AOMDD
∗
is O(n k wT (G) ), from Theorem 3, because it takes time linear in the output (we assume here that
no constraint propagation is performed during search). Procedure B OTTOM U P R EDUCTION (procedure 1) takes time linear in the size of the context minimal AND/OR graph. Therefore, the AOMDD
∗
can be computed in time O(n k wT (G) ), and the result is the same for the algorithm that performs
the reduction during the search. 2
Proof of Proposition 2
The complexity of OBDD (and MDD) apply is known to be quadratic in the input. Namely, the
number of nodes in the output is at most the product of number of nodes in the input. Therefore, the
number of nodes that can appear along one path in the output AOMDD can be at most the product
of the number of nodes in each input, along the same path, |Gfi | · |Ggi |. Summing over all the paths
in T gives the result. 2
Proof of Proposition 3
The argument is identical to the case of MDDs. The recursive calls in APPLY lead to combinations
of one node from Gfaomdd and one node from Ggaomdd (rather than a list of nodes). The number of
total possible such combinations is O(| Gfaomdd | · | Ggaomdd |). 2
Proof of Proposition 4
The recursive calls of APPLY can generate one meta-node in the output for each combination of
511

M ATEESCU , D ECHTER & M ARINESCU

nodes from Gff ∩g and Ggf ∩g . Let’s look at combinations of nodes from Gff ∩g and Ggaomdd \ Ggf ∩g .
The meta-nodes from Ggaomdd \ Ggf ∩g that can participate in such combinations (let’s call this set A)
are only those from levels (of variables) right below Tf ∩g . This is because of the mechanics of the
recursive calls in APPLY. Whenever a node from f that belongs to Gff ∩g is combined with a node
from g that belongs to A, line 15 of APPLY expands the node from f , and the node (or nodes) from
A remain the same. This will happen until there are no more nodes from f that can be combined
with the node (or nodes) from A, and at that point APPLY will simply copy the remaining portion of
its output from Ggaomdd . The size of A is therefore proportional to | Ggf ∩g | (because it is the layer
of metanodes immediately below Ggf ∩g ). A similar argument is valid for the symmetrical case. And
there are no combinations between nodes in Ggaomdd \ Ggf ∩g and Ggaomdd \ Ggf ∩g . The bound follows
from all these arguments. 2
Proof of Proposition 5
The APPLY operation works by constructing the output AOMDD from root to leaves. It first creates a
meta-node for the root variable, and then recursively creates its children metanodes by using APPLY
on the corresponding children of the input. The worst case that can happen is when the output is
not reduced at all, and a recursive call is made for each possible descendant. This corresponds to an
unfolding of the full AND/OR search tree based on the context variables, which is exponential in
the context size. When the APPLY finishes the context variables, and arrives at the first branching in
the bucket pseudo tree, the remaining branches are independent. Similar to the case of OBDDs,
where one function occupies a single place in memory, the APPLY can simply create a link to
the corresponding branches of the inputs (this is what happens in line 4 in the APPLY algorithm).
Therefore, the time and space complexity is at most exponential in the context size. 2
Proof of Theorem 5
The space complexity is governed by that of BE. Since an AOMDD never requires more space than
∗
that of a full exponential table (or a tree), it follows that BE-AOMDD only needs space O(n k w ).
The size of the output AOMDD is also bounded, per layers, by the number of assignments to the
context of that layer (namely, by the size of the context minimal AND/OR graph). Therefore,
∗
because context size is bounded by treewidth, it follows that the output has size O(n k w ). The
time complexity follows from Proposition 5, and from the fact that the number of functions in a
bucket cannot exceed r, the original number of functions.
2
Proof of Proposition 6
It suffices to prove the proposition for m = 2. The general result can then be obtained by induction.
It is essential that the function is defined by a constraint network (i.e., the values are only 0 or 1),
and that the function takes value 1 at least for one assignment. The value 1 denotes consistent assignments (solutions), while 0 denotes inconsistent assignments. Suppose f = f1 ⊗f2 . Let’s denote
by x a full assignment to X, and by x1 and x2 the projection of x over X1 and X2 , respectively. We
can write x = x1 x2 (concatenation of partial assignments). It follows that f (x) = f1 (x1 ) ∗ f2 (x2 ).
Therefore, if f (x) = 1, it must be that f1 (x1 ) = 1 and f2 (x2 ) = 1. We claim that for any x1 ,
f1 (x1 ) = 1 only if there exists some x2 such that f (x1 x2 ) = 1. Suppose by contradiction that there
exist some x1 such that f1 (x1 ) = 1 and f (x1 x2 ) = 0 for any other x2 . Since f is not always zero,

512

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

it follows that f2 is not always zero, and therefore there must be some x2 for which f2 (x2 ) = 1.
This leads to a contradiction, and therefore the functions f1 and f2 are uniquely defined by f . 2
Proof of Theorem 6
The proof is by structural induction over the depth of the pseudo tree T . It follows the canonicity
proofs for OBDDs (Bryant, 1986) and MDDs (Srinivasan et al., 1990), but extends them from linear
orderings to tree orderings that capture function decomposition according to the pseudo tree T . The
depth of T , along each of its paths from root to a leaf, is actually the size of the dependency set, or
the set of variables on which the value of the function depends. Remember that the AOMDD is an
AND/OR graph that is completely reduced. We will use the word function, denoted by f , to refer
to the universal relation, or its characteristic function, defined by the constraint network.
Assume the depth of T is 0. This means that the function does not depend on any variable,
and must be one of the constants 0 or 1. Suppose the function is the constant 0. Then, it must be
that the AOMDD does not contain the terminal meta-node 1, since all the nodes must be reachable
along some path, and it would mean that the function can also evaluate to 1. Suppose the AOMDD
contains a nonterminal meta-node, say labeled with X, where X can take k different values. It must
be that all the k children meta-nodes of X are the terminal meta-node 0. If there are more than one
terminal 0, then the AOMDD is not completely reduced. If there is only one 0, it follows that the
meta-node labeled with X is redundant. Therefore, from all the above, it follows that the AOMDD
representing the constant 0 is made of only the terminal 0. This is unique, and contains the smallest
number of nodes. A similar argument applies for the constant 1.
Now, suppose that the statement of the theorem holds for any constraint network that admits a
pseudo tree of depth strictly smaller than p, and that we have a constraint network with a pseudo
tree of depth equal to p, where p > 0. Let X be the root of T , having domain {x1 , . . . , xk }. We
denote by fi , where i ∈ {1, . . . , k}, the functions defined by the restricted constraint network for
X = xi , namely fi = f |X=xi . Let Y1 , . . . , Ym be the children of X in T . Suppose we have two
AOMDDs of f , denoted by G and G 0 . We will show that these two AND/OR graphs are isomorphic.
The functions fi can be decomposed according to the pseudo tree T when the root X is removed.
This can in fact be a forest of independent pseudo trees (they do not share any variables), rooted by
Y1 , . . . , Ym . Based on Proposition 6, there is a unique decomposition fi = fiY1 ∗ . . . ∗ fiYm , for all
Y
i ∈ {1, . . . , k}. Based on the induction hypothesis, each of the function fi j has a unique AOMDD.
In the AND/OR graphs G and G 0 , if we look at the subgraphs descending from X = xi , they both are
completely reduced and define the same function, fi , therefore there exists an isomorphic mapping
σi between them. Let v be the root metanode of G and v 0 the root of G 0 . We claim that G and G 0 are
isomorphic according to the following mapping:
 0
v,
if u = v;
σ(u) =
σi (u), if u is in the subgraph rooted by hX, xi i.
To prove this, we have to show that σ is well defined, and that it is an isomorphic mapping.
If a meta-node u in G is contained in both subgraphs rooted by hX, xi i and hX, xj i, Then the
AND/OR graphs rooted by σi (u) and σj (u) are isomorphic to the one rooted at u, and therefore to
each other. Since G 0 is completely reduced, it does not contain isomorphic subgraphs, and therefore
σi (u) = σj (u). Therefore σ is well defined.
We can now show that σ is a bijection. To show that it is one-to-one, assume two distinct metanodes u1 and u2 in G, with σ(u1 ) = σ(u2 ). Then, the subgraphs rooted by u1 and u2 are isomorphic
513

M ATEESCU , D ECHTER & M ARINESCU

to the subgraph rooted by σ(u1 ), and therefore to each other. Since G is completely reduced, it must
be that u1 = u2 . The fact that σ is onto and is an isomorphic mapping follows from its definition and
from the fact that each σi is onto and the only new node is the root meta-node. Since the AOMDDs
only contain one root meta-node (more than one root would lead to the conclusion that the root
meta-nodes are isomorphic and should be merged), we conclude that G and G 0 are isomorphic.
Finally, we can show that among all the AND/OR graphs representing f , the AOMDD has
minimal number of meta-nodes. Suppose G is an AND/OR graph that represents f , with minimal
number of meta-nodes, but without being an AOMDD. Namely, it is not completely reduced. Any
reduction rule would transform G into an AND/OR graph with smaller number of meta-nodes,
leading to a contradiction. Therefore, G must be the unique AOMDD that represents f . 2
Proof of Corollary 1
The proof of Theorem 6 did not rely on the scopes that define the constraint network. As long as the
network admits the decomposition induced by the pseudo tree T , the universal function defined by
the constraint network will always have the same AOMDD, and therefore any constraint network
equivalent to it that admits T will also have the same AOMDD. 2
Proof of Theorem 7
The constant that is associated with the root is actually the sum of the weights of all solutions. This
can be derived from the definition of the weighted AOMDD. The weights of each meta-node are
normalized (they sum to 1), therefore the values computed for each OR node by AND/OR search
is always 1 (when the task is computing
P the sum of all solution weights). Therefore, the constant
of the weighted AOMDD is always x w(x) regardless of the graphical model. We will prove that
weighted AOMDDs are canonical for functions that are normalized.
Assume we have two different weighted AOMDDs, denoted by G 1 and G 2 , for the same normalized function f . Let the root variable be A, with the domain {a1 , . . . , ak }. Let x denote a full
assignment to all the variables. Similar to the above argument for the root constant,
P because all
the meta-nodes have normalized weights, it follows that w1 (A, a1 ) = w2 (A, a1 ) = x|A=a1 f (x).
The superscript of w1 and w2 indicates the AOMDD, and the summation is over all possible assignments restricted to A = a1 . It follows that the root meta-nodes are identical. For each value of the
root variable, the restricted functions represented in G 1 and G 2 are identical, and we will recursively
apply the same argument as above.
However, for the proof to be complete, we have to discuss the case when a restricted function
is decomposed into independent functions, according to the pseudo tree. Suppose there are two
independent components, rooted by B and C. If one of them is the 0 function, it follows that the
entire function is 0. We will prove that the meta-nodes of B in G 1 and G 2 are identical. If B has only
one value b1 extendable to a solution, its weight must be 1 in both meta-nodes, so the meta-nodes
are identical. If B has more than one value, suppose without loss of generality that the weights are
different for the first value b1 , and
w1 (B, b1 ) > w2 (B, b1 ).

(1)

Since f 6= 0, there must be a value C = c1 such that B = b1 , C = c1 can be extended to a full
solution. The sum of the weights of all these possible extensions is
X
f (x) = w1 (B, b1 ) ∗ w1 (C, c1 ) = w2 (B, b1 ) ∗ w2 (C, c1 ).
(2)
x|B=b1 ,C=c1

514

AND/OR M ULTI -VALUED D ECISION D IAGRAMS (AOMDD S ) FOR G RAPHICAL M ODELS

From Equations 1 and 2 and the fact that the weight are non-zero, it follows that
w1 (C, c1 ) < w2 (C, c1 ).

(3)

From Equation 1, the fact that B has more than one value and the fact that the weights of B are
normalized, it follows that there should be a value b2 such that
w1 (B, b2 ) < w2 (B, b2 ).

(4)

From Equations 3 and 4, it follows that
w1 (B, b2 ) ∗ w1 (C, c1 ) < w2 (B, b2 ) ∗ w2 (C, c1 ).

(5)

However, both sides of
P the Equation 5 represent the sum of weights of all solutions when B =
b2 , C = c1 , namely x|B=b2 ,C=c1 f (x), leading to a contradiction. Therefore, it must be that
Equation 1 is false. Continuing the same argument for all values of B, it follows that the metanodes of B are identical, and similarly the meta-nodes of C are identical.
If the decomposition has more than two components, the same argument applies, when B is the
first component and C is a meta-variable that combines all the other components.
2
Proof of Theorem 8
Consider the well known NP-complete problem of 3- COLORING: Given a graph G, is there a
3-coloring of G? Namely, can we color its vertices using only three colors, such that any two
adjacent vertices have different colors? We will reduce 3- COLORING to the problem of computing
the semantic treewidth of a graphical model. Let H be a graph that is 3-colorable, and has a nontrivial semantic treewidth. It is easy to build examples for H. If G is 3-colorable, then G ∪ H is
also 3-colorable and will have a non-trivial semantic treewidth, because adding G will not simplify
the task of describing the colorings of H. However, if G is not 3-colorable, then G ∪ H is also not
3-colorable, and will have a semantic treewidth of zero. 2
Proof of Proposition 7
Since AOMDDs are canonical representations of graphical models, it follows that the graphical
model for which the actual semantic treewidth is realized will have the same AOMDD as M, and
therefore the AOMDD is bounded exponentially in the semantic treewidth. 2



The paper evaluates the power of best-first search
over AND/OR search spaces for solving the Most
Probable Explanation (MPE) task in Bayesian
networks. The main virtue of the AND/OR
representation of the search space is its sensitivity to the structure of the problem, which
can translate into significant time savings. In
recent years depth-first AND/OR Branch-andBound algorithms were shown to be very effective when exploring such search spaces, especially when using caching. Since best-first strategies are known to be superior to depth-first when
memory is utilized, exploring the best-first control strategy is called for. The main contribution
of this paper is in showing that a recent extension
of AND/OR search algorithms from depth-first
Branch-and-Bound to best-first is indeed very effective for computing the MPE in Bayesian networks. We demonstrate empirically the superiority of the best-first search approach on various
probabilistic networks.

1

INTRODUCTION

Belief networks [1] are a class of graphical models that provide a formalism for reasoning about partial beliefs under
conditions of uncertainty. They are defined by a directed
acyclic graph over nodes representing random variables of
interest. The arcs signify the existence of direct causal influences between linked variables quantified by conditional
probabilities that are attached to each cluster of parentschild nodes in the network. The Most Probable Explanation
(MPE) task in belief networks calls for finding a complete
assignment to the variables having maximum probability,
given the evidence. It is typically tackled with either inference or search algorithms [1, 2, 3].
The AND/OR search space for graphical models [4] is a
framework for search that is sensitive to the independencies

in the model, often resulting in reduced search spaces. The
impact of the AND/OR search to optimization in graphical
models and in particular to the MPE task was explored in
recent years focusing exclusively on depth-first search.
The AND/OR Branch-and-Bound first introduced by [3]
traverses the AND/OR search tree in a depth-first manner.
The memory intensive Branch-and-Bound algorithm [5]
explores an AND/OR search graph, rather than a tree, by
caching previously computed results and retrieving them
when the same subproblems are encountered again. The
depth-first AND/OR search algorithms were shown to outperform dramatically state-of-the-art Branch-and-Bound
algorithms searching the traditional OR space.
In a recent paper [6] we introduced best-first AND/OR
search algorithms for solving 0-1 Integer Programming
problems, and demonstrated that, given enough memory,
they are superior to Branch-and-Bound algorithms we developed earlier [7]. Subsequently, in [8] we extended this
approach for Weighted CSP (WCSP) problems when using
best-first AND/OR search guided by bounded mini-bucket
heuristics. We demonstrated, again, that the best-first algorithms are more efficient than their Branch-and-Bound
counterparts for various hard WCSP benchmarks.
In this paper we shift our attention to probabilistic networks, focusing on the MPE tasks. The extension of bestfirst AND/OR search from WCSP to Bayesian networks is
straightforward. Hence, the main contribution of the current paper is in its empirical evaluation of the scheme over
a wide range of probabilistic networks, including random
networks, coding networks as well as hard instances from
genetic linkage analysis. We show that this class of algorithms improves on the most competitive complete MPE
solvers, thus it can potentially push the landmark of computation further, assuming memory is available.
The paper is organized as follows. Section 2 gives background on belief networks and AND/OR search spaces.
Section 3 describes the best-first AND/OR search algorithm. Section 4 presents an extensive empirical evaluation
and Section 5 concludes.

260

MARINESCU & DECHTER
A

OR

A

OR

0

AND

A

[A]

B

OR

C

A

F

[CB] C

AND

F

AND

OR

D

B

E

(a) Network

[D] D

[F]

(b) Pseudo-tree

1

C

OR

E [EA]

B

0

AND

B [AB]

1

1

C

E

0

1

OR

B

B

C

OR

C

E

E

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

D

D

F

F

D

D

F

F

D

D

F

F

D

D

F

F

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

1

0

AND

0

C

E

AND

E

1

0

C

E

C

E

C

E

AND

0

1

0

1

0

1

0

1

OR

D

D

F

F

D

D

F

F

AND

(c) AND/OR search tree

0 1

0 1

(d) AND/OR search graph

Figure 1: AND/OR search spaces for belief networks.

2
2.1

BACKGROUND
Belief Networks

D EFINITION 1 (belief network) A belief (or Bayesian)
network is a quadruple P = hX, D, F i, where X =
{X1 , ..., Xn } is a set of variables over multi-valued domains D = {D1 , ..., Dn }. Given a directed acyclic
graph DAG over X as nodes, F = {Pi }, where Pi =
{P (Xi |pa(Xi ))} are conditional probability tables (CPTs
for short) associated with each variable Xi , and pa(Xi )
are the parents of Xi in the acyclic graph DAG. A belief
network representsQa joint probability distribution over X,
n
P (x1 , ..., xn ) = i=1 P (xi |xpa(Xi ) ). An evidence set e
is an instantiated subset of variables. The moral graph (or
primal graph) of a belief network is the undirected graph
obtained by connecting the parent nodes of each variable
and eliminating direction.
A common optimization query over belief networks is finding the Most Probable Explanation (MPE), namely, finding
a complete assignment to all variables having maximum
probability, given the evidence. A generalization of the
MPE query is Maximum a Posteriori Hypothesis (MAP),
which calls for finding the most likely assignment to a subset of hypothesis variables, given the evidence.
D EFINITION 2 (most probable explanation) Given a belief network and evidence e, the Most Probable Explanation
o
o
(MPE) task is to find an assignment
Qn (x1 , ..., xn ) such that:
o
o
P (x1 , ..., xn ) = maxX1 ,...,Xn k=1 P (Xk |pa(Xk ), e).
The MPE task appears in applications such as diagnosis,
abduction and explanation. For example, given data on
clinical findings, MPE can postulate on a patient’s probable afflictions. In decoding, the task is to identify the most
likely message transmitted over a noisy channel given the
observed output.
2.2

AND/OR Search Spaces for Graphical Models

The common way to solve the MPE task in belief networks
is by search, namely to instantiate variables, following a
static or dynamic variable ordering. In the simplest case,
this process defines an OR search tree, whose nodes repre-

sent partial assignments. This search space does not capture the structure of the underlying graphical model. However, to remedy this problem, AND/OR search spaces for
graphical models were recently introduced by [4]. They are
defined using a backbone pseudo-tree [9].
D EFINITION 3 (pseudo-tree) Given an undirected graph
G = (V, E), a directed rooted tree T = (V, E 0 ) defined
on all its nodes is called pseudo-tree if any arc of G which
is not included in E 0 is a back-arc, namely it connects a
node to an ancestor in T .
AND/OR Search Trees Given a belief network P =
hX, D, F i, its primal graph G and a pseudo-tree T of G,
the associated AND/OR search tree, denoted ST , has alternating levels of OR nodes and AND nodes. The OR
nodes are labeled Xi and correspond to the variables. The
AND nodes are labeled hXi , xi i and correspond to value
assignments in the domains of the variables. The root of
the AND/OR search tree is an OR node, labeled with the
root of the pseudo-tree T .
The children of an OR node Xi are AND nodes labeled
with assignments hXi , xi i, consistent along the path from
the root, path(Xi , xi ) = (hX1 , x1 i, ..., hXi−1 , xi−1 i).
The children of an AND node hXi , xi i are OR nodes labeled with the children of variable Xi in T . Semantically,
the OR states represent alternative solutions, whereas the
AND states represent problem decomposition into independent subproblems, all of which need be solved. When the
pseudo-tree is a chain, the AND/OR search tree coincides
with the regular OR search tree.
A solution tree SolST of ST is an AND/OR subtree such
that: (i) it contains the root of ST ; (ii) if a nonterminal
AND node n ∈ ST is in SolST then all its children are in
SolST ; (iii) if a nonterminal OR node n ∈ ST is in SolST
then exactly one of its children is in SolST .
E XAMPLE 1 Figures 1(a) and 1(b) show a belief network
and its pseudo-tree together with the back-arcs (dotted
lines). Figure 1(c) shows the AND/OR search tree based
on the pseudo-tree, for bi-valued variables.
Weighted AND/OR Search Trees The arcs from OR
nodes Xi to AND nodes hXi , xi i in the AND/OR search

MARINESCU & DECHTER

261

tree ST are annotated by weights derived from the conditional probability tables in F .

O(exp(w∗ )), where w∗ is the induced width of the underlying pseudo-tree [4].

D EFINITION 4 (weight) The weight w(n, m) of the arc
from the OR node n = Xi to the AND node m = hXi , xi i
is the product of all the CPTs whose scope includes Xi and
is fully assigned along path(Xi , xi ), evaluated at the values along the path.

E XAMPLE 2 Consider the context-minimal AND/OR
search graph in Figure 1(d) of the pseudo-tree from
Figure 1(b) (the square brackets indicate the context of the
variables). Its size is far smaller than that of the AND/OR
tree from Figure 1(c) (16 nodes vs. 36 nodes).

Given a weighted AND/OR search tree, each node can be
associated with a value [4].

2.3

D EFINITION 5 (value) The value v(n) of a node n ∈ ST
is defined recursively as follows: (i) if n = hXi , xi i is a
terminal AND node then v(n) = 1; (ii)
Q if n = hXi , xi i
is an internal AND node then v(n) = m∈succ(n) v(m);
(iii) if n = Xi is an internal OR node then v(n) =
maxm∈succ(n) (w(n, m) · v(m)), where succ(n) are the
children of n in ST .
It easy to see that the value v(n) of a node in the AND/OR
search tree ST is the most probable explanation of the subproblem rooted at n, subject to the current variable instantiation along the path from the root to n. If n is the root of
ST , then v(n) is the most probable explanation value of the
initial problem (see [3, 4] for more details).
AND/OR Search Graphs The AND/OR search tree may
contain nodes that root identical subtrees (in particular,
subproblems with identical optimal solutions) which can
be unified. When unifiable nodes are merged, the search
tree becomes a graph and its size becomes smaller. Some
unifiable nodes can be identified based on their contexts.
D EFINITION 6 (context) Given a belief network and the
corresponding AND/OR search tree ST relative to a
pseudo-tree T , the context of any AND node hXi , xi i ∈
ST , denoted by context(Xi ), is defined as the set of ancestors of Xi in T , including Xi , that are connected to descendants of Xi .
It is easy to verify that any two nodes having the same
context represent the same subproblem. Therefore, we can
solve PhXi ,xi i , the subproblem rooted at hXi , xi i, once and
use its optimal solution whenever the same subproblem is
encountered again.
The context-minimal AND/OR search graph based on a
pseudo-tree T , denoted GT , is obtained from the AND/OR
search tree by merging all the AND nodes that have the
same context. It can be shown [4] that the size of the largest
context is bounded by the induced width w∗ of the problem’s primal graph.
T HEOREM 2.1 (complexity) The complexity of any search
algorithm traversing a context-minimal AND/OR search
graph (by context-based caching) is time and space

Searching the AND/OR Search Space

Recently, depth-first AND/OR Branch-and-Bound (AOBB)
search algorithms that explore the context-minimal
AND/OR search graph via full caching were shown to be
highly effective for solving the MPE task in belief networks [3, 5]. The efficiency of these algorithms also depends on the accuracy of a static heuristic function which
can be either pre-compiled or generated during search for
each node in the search space. Furthermore, we showed
[3] that AOBB can improve its guiding heuristic function
dynamically, by learning from portions of the search space
that were already explored. This updated dynamic heuristic evaluation function is guaranteed to be tighter than the
static one [3], and therefore it can prune the search space
more effectively. The primary static heuristic function we
experimented with, especially in the context of the MPE
task was the mini-bucket heuristic [2].
The Mini-bucket Heuristics is a general scheme for generating heuristic estimates for search that has been investigated in recent years, especially in the context of belief
networks [2, 3, 5]. The scheme is parameterized by the
mini-bucket i-bound which controls the trade-off between
heuristic strength and its computational overhead. The
heuristics can be pre-compiled from the augmented bucket
structure processed by the Mini-Bucket algorithm. When
compiled before search they are referred to as static minibuckets (hereafter denoted by SMB) and they were shown
to be very powerful, especially for relatively large values
of the i-bound. When the mini-bucket heuristics are computed dynamically during search, referred to as dynamic
mini-buckets (DMB) they are generally more accurate than
the static ones. However, due to their computational overhead, they were shown to be cost effective only for relatively small i-bounds.

3

BEST-FIRST AND/OR SEARCH

In this section we direct our attention to a best-first rather
than depth-first control strategy for traversing the contextminimal AND/OR graph and describe a best-first AND/OR
search algorithm for solving the MPE task in belief networks. The algorithm uses similar amounts of memory
as the depth-first AND/OR Branch-and-Bound with full
caching and therefore the comparison is warranted.

262

MARINESCU & DECHTER

Algorithm 1: AOBF
Data: A belief network P = hX, D, F i, pseudo-tree T , root s.
Result: Most Probable Explanation of P.
1. Create explicit graph G0T , consisting solely of the start node
s. Set v(s) = h(s).
2. until s is labeled SOLVED, do:
(a) Compute a partial solution tree by tracing down the
marked arcs in G0T from s and select any nonterminal tip
node n.
(b) Expand node n and add any new successor node ni to
G0T . For each new node ni set v(ni ) = h(ni ). Label
SOLVED any of these successors that are terminal nodes.
(c) Create a set S containing node n.
(d) until S is empty, do:
i. Remove from S a node m such that m has no
descendants in G0T still in S.
ii. Revise the value v(m) as follows:
A. if m isQ
an AND node then
v(m) = m ∈succ(m) v(mj ). If all the successor
j
nodes are labeled SOLVED, then label node m
SOLVED.
B. if m is an OR node then
v(m) = maxmj ∈succ(m) (w(m, mj ) · v(mj )) and
mark the arc through which this maximum is achieved.
If the marked successor is labeled SOLVED, then label
m SOLVED.
iii. If m has been marked SOLVED or if the revised value
v(m) is different than the previous one, then add to S all
those parents of m such that m is one of their successors
through a marked arc.
3. return v(s).

to its successors (step 2.b). The successors of an AND
node n = hXj , xj i are Xj ’s children in the pseudo-tree,
while the successors of an OR node n = Xj correspond to
Xj ’s domain values. Notice that when expanding an OR
node, the algorithm does not generate AND children that
are already present in the explicit search graph G0T . All
these identical AND nodes in G0T are easily recognized
based on their contexts, so only pointers to the existing
nodes are created.
The second operation in AOBF is a bottom-up, cost revision, arc marking, SOLVE-labeling procedure (step
2.c). Starting with the node just expanded n, the procedure revises its value v(n) (using the newly computed values of its successors) and marks the outgoing arcs on the
estimated best path to terminal nodes. This revised value
is then propagated upwards in the graph. The revised cost
v(n) is an updated estimate of the most probable explanation probability of the subproblem rooted at n. If we
assume the monotone restriction on h, the algorithm considers only those ancestors that root best partial solution
subtrees containing descendants with revised values. The
most probable explanation value of the initial problem is
obtained when the root node s is solved.
AOBF versus AOBB We describe next the main differences between AOBF and AOBB search.
1 AOBF with the same heuristic function as AOBB is
likely to expand the smallest number of nodes [10],
but empirically this depends on how quickly AOBB
will find an optimal solution.

Best-First Search Best-first search is a search algorithm
which optimizes breath-first search by expanding the node
whose heuristic evaluation function is the best among all
nodes encountered so far. Its main virtue is that it never
expands nodes whose cost is beyond the optimal one, unlike depth-first search algorithms, and therefore is superior
among memory intensive algorithms employing the same
heuristic evaluation function [10].
Best-First AND/OR Graph Search
Our best-first
AND/OR graph search algorithm, denoted by AOBF, that
traverses the context-minimal AND/OR search graph is described in Algorithm 1. It specializes Nilsson’s AO∗ algorithm [11] to AND/OR spaces in graphical models, in
particular to finding the MPE in belief networks.
The algorithm maintains a frontier of partial solution trees
found so far, and interleaves forward expansion of the best
partial solution tree with a cost revision step that updates
estimated node values. First, a top-down, graph-growing
operation (step 2.a) finds the best partial solution tree
by tracing down through the marked arcs of the explicit
AND/OR search graph G0T . These previously computed
marks indicate the current best partial solution tree from
each node in G0T . One of the nonterminal leaf nodes n of
this best partial solution tree is then expanded, and a static
heuristic estimate h(ni ), overestimating v(ni ), is assigned

2 AOBB is able to improve its heuristic function dynamically during search [3] based on the explicated portion of the search space, while AOBF may not because
it uses only the static function h(n), which can be precomputed or generated during search.
3 AOBB can use far less memory avoiding dead-caches
for example (e.g., when the search graph is a tree),
while AOBF has to keep the explicated search graph
in memory prior to termination.
All the above points show that the relative merit of best-first
vs depth-first over context-minimal AND/OR search spaces
cannot be determined by the theory in [10] and empirical
evaluation is essential.

4

EXPERIMENTS

We evaluate the performance of the best-first AND/OR
search algorithm on the task of finding the Most Probable
Explanation in belief networks [1]. We implemented our
algorithms in C++ and ran all experiments on a 2.4GHz
Pentium IV with 2GB of RAM.
We consider a class of best-first AND/OR search algorithms guided by the static and dynamic mini-bucket

MARINESCU & DECHTER

263

heuristics. They are denoted by AOBF+SMB(i) and
AOBF+DMB(i), respectively. We compare them against
the depth-first AND/OR Branch-and-Bound algorithms
with static/dynamic mini-bucket heuristics and full caching
introduced in [5] and denoted by AOBB+SMB(i) and
AOBB+DMB(i) respectively. The parameter i represents
the mini-bucket i-bound and controls the accuracy of the
heuristic. All algorithms traverse the context-minimal
AND/OR search graph and are restricted to a static variable ordering determined by the pseudo-tree. In our current implementation the AND/OR search algorithms do not
exploit the determinism present in the networks by using
any form of constraint propagation such as generalized arcconsistency or unit propagation.
For reference, we include results obtained with the
S AM I AM 2.3.2 software package1 . S AM I AM is a public
implementation of Recursive Conditioning [13] which can
also be viewed as an AND/OR search algorithm.
We report the average CPU time in seconds (t) and number of nodes visited (#), required for proving optimality of
the solution. We also record the number of variables (n),
number of evidence variables (e), the depth of the pseudotrees (h) and the induced width of the graphs (w∗ ) obtained
for the test instances. The pseudo-trees were generated
using the min-fill heuristic, as described in [3]. All competing algorithms were alloted a 2GB memory limit. The
best performance points are highlighted. In each table, ”/out” denotes that the respective algorithm exceeded the
time/memory limit.
Random Belief Networks We have generated a class
of random belief networks using the parametric model
(n, d, c, p) proposed in [2]. Figure 2 reports the average
time results in seconds and number of nodes visited for 20
random instances of a network with n = 120 variables, domain size d = 2, c = 110 probability tables (CPTs) and
p = 2 parents per CPT. The average induced width and
pseudo-tree depth were 20 and 32, respectively. The minibucket i-bound ranged between 2 and 16.
When comparing the best-first versus the depth-first algorithms using static mini-bucket heuristics, we observe
that AOBF+SMB(i) is better than AOBB+SMB(i) only
for relatively small i-bounds (i.e., i ∈ {2, 3, 4}) which
generate relatively weak heuristic estimates. As the ibound increases and the heuristics become strong enough
to cut the search space substantially, the difference between
Branch-and-Bound and best-first search decreases, because
Branch-and-Bound finds close to optimal solutions fast,
and therefore will not explore solutions whose cost is below
the optimum, like best-first search.
When looking at the algorithms using dynamic mini-bucket
heuristics, we notice that AOBF+DMB(i) is slightly bet1
Available at http://reasoning.cs.ucla.edu/samiam. We used
the batchtool 1.5 provided with the package.

Figure 2: CPU time in seconds and number of nodes visited
for solving random belief networks with 120 nodes. Time
limit 180 seconds, average induced width w∗ = 20.

ter than AOBB+DMB(i) only for the smallest reported ibound, namely i = 2. This is because these heuristics are
more accurate compared to the static ones, and the savings
in number of nodes caused by best-first search do not transform into time savings as well. When comparing the static
versus dynamic mini-bucket heuristic we observe that the
latter is competitive only for relatively small i-bounds (i.e.,
i ∈ {2, 3, 4, 5, 6}). At higher levels of the i-bound, the
accuracy of the dynamic heuristic does not outweigh its
computational overhead. For this reason, in the remaining experiments we only consider the algorithms guided by
pre-compiled mini-bucket heuristics.
Coding Networks For this domain we experimented with
random coding networks from the class of linear block
codes. They can be represented as 4-layer belief networks
with n nodes in each layer (i.e., the number of input bits).
The second and third layers correspond to input information bits and parity check bits respectively. Each parity
check bit represents an XOR function of the input bits. The
first and last layers correspond to transmitted information
and parity check bits respectively. Input information and
parity check nodes are binary, while the output nodes are
real-valued. Given a number of input bits n, number of
parents p for each XOR bit, and channel noise variance σ 2 ,
a coding network structure is generated by randomly picking parents for each XOR node. Then we simulate an input
signal by assuming a uniform random distribution of information bits, compute the corresponding values of the parity

264

MARINESCU & DECHTER

Figure 3: CPU time in seconds for solving coding networks with channel noise variance σ 2 ∈ {0.22, 0.28, 0.32, 0.36}.
Time limit 300 seconds, average induced width w∗ = 54.
check bits, and generate an assignment to the output nodes
by adding Gaussian noise to each information and parity
check bit.
Figure 3 displays the average time results in seconds for
20 random coding instances with n = 128 input bits,
p = 4 parents for each XOR bit and channel noise variance
σ 2 ∈ {0.22, 0.28, 0.32, 0.36} (we omitted the number of
nodes due to space limitations). The average induced width
and depth of the pseudo-tree was 54 and 71, respectively.
The mini-bucket i-bound varied between 10 and 20. We observe that AOBF+SMB(i) is far better than AOBB+SMB(i)
for this domain. The difference in CPU time between the
best-first and depth-first search approaches is more prominent on the hardest problem instances having higher channel noise variance (i.e., σ 2 ∈ {0.32, 0.36}), across all reported i-bounds. S AM I AM was not able to solve any of
these problems due to exceeding the memory limit.
Grid Networks In grid networks, the nodes are arranged
in an n × n square and each CPT is generated uniformly
randomly. We experimented with problem instances developed by [14] for which n ranged between 10 and 38, and
90% of the CPTs were deterministic (i.e., constraints).
Table 1 shows detailed results for experiments with 8 grid
networks of increasing difficulty. For each network e
nodes were picked randomly and instantiated as evidence.
We notice again the superiority of AOBF+SMB(i) over
AOBB+SMB(i), especially for relatively weak heuristic estimates which are generated at relatively small i-bounds.

For example, on 90-34-1, one of the hardest instances,
best-first search with the smallest reported i-bound (i =
12) finds the most probable explanation in about 8 minutes (495 seconds) while the depth-first Branch-and-Bound
with the same heuristics exceeds the 1 hour time limit. The
best performance point on this test instance is achieved for
i = 18, where AOBF+SMB(18) is 9 times faster than
AOBB+SMB(18) and explores a search space 23 times
smaller. Notice that S AM I AM is able to solve relatively efficiently only the first 3 test instances and runs out of memory on the remaining ones.
Genetic Linkage Analysis The maximum likelihood haplotype problem in genetic linkage analysis is the task of
finding a joint haplotype configuration for all members of
the pedigree which maximizes the probability of data. It
is equivalent to finding the most probable explanation of a
belief network which represents the pedigree data [15].
Table 2 displays the results obtained for 12 hard linkage
analysis networks2 . For comparison, we include results obtained with S UPERLINK 1.6. S UPERLINK is currently one
the most efficient solvers for genetic linkage analysis, is
dedicated to this domain, uses a combination of variable
elimination and conditioning, and takes advantage of the
determinism in the network.
We observe again that AOBF+SMB(i) is the best performing algorithm. For instance, on the p42 linkage instance,
AOBF+SMB(14) is 18 times faster than AOBB+SMB(14)
2

http://bioinfo.cs.technion.ac.il/superlink/

MARINESCU & DECHTER
grid
90-10-1
90-14-1
90-16-1

90-24-1
90-26-1
90-30-1
90-34-1
90-38-1

n
e

w*
h

SamIam
v. 2.3.2

100
0
196
0
256
0

16
26
23
37
26
42

t
#
t
#
t
#

576
20
676
40
900
60
1154
80
1444
120

36
61
35
64
38
68
43
79
47
86

t
#
t
#
t
#
t
#
t
#

0.13
11.97
147.19

i=8

i=10

0.23
4,396
19.95
215,723
1223.55
13,511,366

0.19
3,681
12.52
156,387
130.47
1,469,593

AOBB+SMB(i)
i=12
0.08
1,231
8.83
112,962
11.09
135,746

265

i=14

i=16

i=8

i=10

0.11
760
1.22
14,842
11.25
123,841

0.19
101
0.78
4,209
2.38
18,230

0.22
1,788
8.24
46,153
133.19
673,238

0.14
1,046
5.97
35,537
47.72
250,098

AOBF+SMB(i)
i=12

i=14

i=16

0.08
517
2.20
13,990
9.91
55,112

0.09
312
1.02
5,137
10.53
52,644

0.19
100
0.70
1,163
2.97
11,854

i=12

i=14

i=16

i=18

i=20

i=12

i=14

i=16

i=18

i=20

out

1237.19
6,922,516
-

285.63
2,051,503
-

out

out

out

-

-

out

-

81.27
259,405

20.78
15,400
49.97
169,942
37.39
32,637
522.05
2,430,599
133.06
161,156

38.35
149,445
out

-

22.83
110,144
85.11
455,404
145.86
936,463
534.10
2,647,012
734.46
1,478,903

34.21
125,962
out

out

75.02
547,401
634.59
4,254,454
365.69
2,837,671
974.65
5,555,182
657.91
1,505,849

494.69
705,922
478.02
580,623

175.85
303,782
22.80
38,376

13.49
49,261
57.66
190,527
40.80
136,576
88.24
189,340
47.14
80,177

9.08
14,390
29.08
66,429
40.67
121,561
59.39
112,955
43.74
52,209

21.00
8,155
32.95
24,487
36.00
13,217
90.19
115,553
78.05
35,294

out

Table 1: CPU time in seconds and number of nodes visited for solving grid networks. Time limit 1 hour.

ped

n

w*
h

p1

299

p38

582

p50

479

p23

310

p37

1032

p18

1184

p20

388

p25

994

p30

1016

p33

581

p39

1272

p42

448

SamIam
v. 2.3.2

Superlink
v. 1.6

i=6

i=8

4.19
69,751
5946.44
34,828,046
4140.29
28,201,843

2.17
33,908
1554.65
8,986,648
2493.75
15,729,294

i=10
53.70
486,991
39.16
222,747

AOBB+SMB(i)
i=10

i=12

i=14

i=6

i=8

0.39
4,576
2046.95
11,868,672
66.66
403,234

0.65
6,306
272.69
1,412,976
52.11
110,302

1.36
4,494

1.30
7,314
out

2.17
13,784
134.41
348,723
36.03
104,289

i=12

i=14

i=16

i=18

i=10

49.33
437,688
488.34
4,925,737

8.77
85,721
301.78
2,798,044

2.73
14,019
67.83
82,239

3.04
7,089

35.49
185,761
29.16
72,868

AOBF+SMB(i)
i=10

i=12

i=14

0.26
1,177
216.94
583,401
12.75
25,507

0.87
4,016
103.17
242,429
38.52
5,766

1.54
3,119

i=12

i=14

i=16

i=18

29.29
150,214
38.41
102,011

10.59
52,710
95.27
223,398

3.59
11,414
62.97
12,296

3.48
5,790

15
61
17
59
18
58

t
#
t
#
t
#

5.44

54.73

out

28.36

out

-

23
37
21
61

t
#
t
#

out

9146.19

out

64.17

i=12

i=14

i=16

i=18

i=20

i=12

i=14

i=16

i=18

i=20

21
119
23
42
29
53
25
51
26
48
23
94
25
76

t
#
t
#
t
#
t
#
t
#
t
#
t
#

157.05

139.06

-

out

-

7243.43
63,530,037
-

127.41
542,156
out

out

out

42.19
171,039
33.33
144,212
out

19.85
53,961
121.91
466,817
out

19.91
2,027

14.72

out

13095.83

597.88
5,580,555
370.41
4,032,864
-

186.77
692,870
out
out

58.38
253,465
194.78
975,617
out

out

out

85.53
350,497
24.16
102,888
68.52
218,925
133.19
93,831

49.38
179,790
32.55
101,862
41.69
79,356

-

1023.90
10,458,174
26.31
229,856
968.03
7,880,928
2364.67
22,595,247

23.83
118,869
95.13
554,623
2041.64
6,117,320
151.96
1,179,236
33.11
219,047
61.20
313,496

out

out

52.91
397,934
37.28
279,804
-

20.60
2,972

out

406.88
3,567,729
5560.63
46,858,127
-

out

-

out

322.14

1440.26
11,694,534
886.05
8,426,659
-

out

561.31

-

78.53
204,886

693.74
1,925,152
43.83
146,896
54.89
83,360
93.19
83,714

198.49
468,723
33.03
37,705
58.52
57,593
87.63
14,479

Table 2: CPU time in seconds and number of nodes visited for genetic linkage analysis. Time limit 3 hours.

bn

n

BN 031

1153

BN 033

1441

BN 035

1441

BN 037

1441

BN 039

1441

BN 041

1441

BN 127

512

BN 129

512

BN 131

512

BN 134

512

w*
h
46
160
43
163
41
168
45
169
48
162
49
164
57
74
52
68
48
72
52
70

SamIam
v. 2.3.2
t
#
t
#
t
#
t
#
t
#
t
#
t
#
t
#
t
#
t
#

out
-

i=18

1183.49
3,990,212
1717.53
2,156,432
67.74
174,370
34.77
69,326
-

541.82
2,131,977
157.17
210,552
133.28
243,533
21.28
33,475
1727.89
3,448,072
56.66
77,653
-

217.80
889,782
190.77
256,191
58.81
65,657
45.20
8,815
475.26
1,043,378
54.36
38,467
-

-

1439.32
13,437,762
51.16
303,818
-

out

257.96
354,822
1798.57
17,583,748
640.29
6,150,175
-

out

-

out
out

AOBB+SMB(i)
i=20

i=16

43.06
396,234
-

i=21

i=22

i=16

i=18

83.08
94,507
129.74
89,308
80.64
58,973
90.35
16,400
246.60
518,011
78.74
31,763
128.55
860,026
222.17
1,747,613
-

145.55
97,721
154.16
46,312
157.83
45,758
144.60
12,507
653.83
3,045,139
130.94
38,088
113.06
93,543
155.63
671,931
156.11
759,649
234.38
1,438,986

187.95
427,788
80.58
124,453
27.25
31,460
12.80
16,304
out

125.94
292,293
41.25
41,865
36.75
34,987
19.25
11,046
254.25
725,738
22.20
20,485
58.84
251,134
200.47
922,831
50.58
209,748
86.80
373,081

-

36.22
94,220
54.03
235,416
out
19.67
82,780
out

AOBF+SMB(i)
i=20
83.89
114,046
73.70
49,760
51.20
15,953
45.88
4,315
113.97
213,676
43.56
16,549
64.53
166,741
135.60
537,371
36.66
73,163
96.21
377,064

i=21

i=22

71.53
25,392
94.52
22,256
75.53
18,048
90.30
5,610
112.69
127,872
69.91
11,648
66.34
84,007
out

132.55
30,067
143.58
14,894
158.17
18,461
146.61
4,798
211.84
239,838
121.24
16,533
121.53
70,351
231.95
622,449
99.20
46,662
112.63
102,530

65.75
120,153
97.28
214,591

Table 3: CPU time in seconds and number of nodes visited for solving UAI’06. Time limit 30 minutes.

266

MARINESCU & DECHTER

and explores a search space 240 times smaller. On some instances (e.g., p1, p23, p30) the best-first search algorithm
AOBF+SMB(i) is several orders of magnitude faster than
S UPERLINK. The performance of S AM I AM was very poor
on this dataset and it was able to solve only 2 instances.
UAI’06 Evaluation Dataset We also experimented with
10 belief networks from the UAI’06 Evaluation Dataset3 .
We were not able to obtain the code from the other competitors (i.e., Teams 1 and 2) in the MPE evaluation, and
therefore we only compare against AOBB and SAMIAM.
Table 3 displays a summary of the results. We observe that
AOBF+SMB(i) is the best performing algorithm on this
dataset. While on the first 6 instances AOBF+SMB(i) improves only slightly causing on average a 2.5 speed-up over
AOBB+SMB(i), on the remaining 4 instances, the difference between best-first and depth-first search is more dramatic. For example, AOBF+SMB(18) solves the BN 134
instance in less than 2 minutes, while AOBB+SMB(18) exceeds the 30 minute time limit. We notice that in some
cases (e.g. BN 127, BN 129), especially for large minibucket i-bounds (e.g. i = 22) which generate very accurate
heuristic estimates, the savings in number of nodes caused
by AOBF+SMB(i) do not outweigh its overhead.
Summary of experiments.
In summary, best-first
AND/OR search with static/dynamic mini-bucket heuristics improves dramatically over depth-first AND/OR
Branch-and-Bound search, especially for relatively weak
heuristic estimates which are generated for relatively small
mini-bucket i-bounds. This is significant because it allows
the best-first search algorithms to push the landmark of
computation further as the induced width of the problems
increases.

5

CONCLUSION

In this paper we evaluated a best-first AND/OR search
algorithm which extends the classic AO∗ algorithm and
traverses a context-minimal AND/OR search graph for
solving the MPE task in belief networks. The algorithm is guided by mini-bucket heuristics which can be either pre-compiled or assembled dynamically during search.
The efficiency of the best-first AND/OR search approach
compared to the depth-first AND/OR Branch-and-Bound
search is demonstrated empirically on various random and
real-world benchmarks, including the very challenging
ones that arise in the field of genetic linkage analysis.
Our approach leaves room for further improvements. The
space required by AOBF can be enormous, due to the fact
that all the nodes generated by the algorithm have to be
saved prior to termination. Therefore, AOBF can be extended to incorporate a memory bounding scheme similar
to the one suggested in [16].
3

http://ssli.ee.washington.edu/bilmes/uai06InferenceEvaluation

Acknowledgments
This work was supported by the NSF grant IIS-0412854.



In this paper, we develop a qualitative theory of
influence diagrams that can be used to model
and solve sequential decision making tasks when
only qualitative (or imprecise) information is
available. Our approach is based on an orderof-magnitude approximation of both probabilities and utilities and allows for specifying partially ordered preferences via sets of utility values. We also propose a dedicated variable elimination algorithm that can be applied for solving
order-of-magnitude influence diagrams.

1

INTRODUCTION

Influence diagrams have been widely used for the past three
decades as a graphical model to formulate and solve decision problems under uncertainty. The standard formulation
of an influence diagram consists of two types of information: qualitative information that defines the structure of
the problem eg, the set of (discrete) chance variables describing the set of possible world configurations, the set of
available decisions, as well as the dependencies between
the variables, and quantitative information (also known as
the parametric structure) that, together with the qualitative
information, defines the model. The parametric structure
is composed of the conditional probability distributions as
well as the utility functions describing the decision maker’s
preferences. In general, the solution to an influence diagram depends on both types of information. Quite often,
however, we may have precise knowledge of the qualitative
information but only very rough (or imprecise) estimates
of the quantitative parameters. In such cases, the standard
solution techniques cannot be applied directly, unless the
missing information is accounted for.
In this paper, we propose a qualitative theory for influence
∗
This work was supported in part by the Science Foundation
Ireland under grant no. 08/PI/I1912

Nic Wilson
Cork Constraint Computation Centre
University College Cork, Ireland
n.wilson@4c.ucc.ie

diagrams in which such partially specified sequential decision problems can be modeled and solved. In particular, we
introduce the order-of-magnitude influence diagram model
that uses an order-of-magnitude representation of the probabilities and utilities. The model allows the decision maker
to specify partially ordered preferences via finite sets of
utility values. In this case, there will typically not be a
unique maximal value of the expected utility, but rather a
set of them. To compute this set and also the corresponding
decision policy we propose a dedicated variable elimination algorithm that performs efficient operations on sets of
utility values. Numerical experiments on selected classes
of influence diagrams show that as the quantitative information becomes more precise, the qualitative decision process becomes closer to the standard one.
The paper is organized as follows. Section 2 gives background on influence diagrams. In Section 3 we present
the order-of-magnitude calculus as a representation framework for imprecise probabilities and utilities. Sections 4
and 5 describe the main operations over sets of order-ofmagnitude values and introduce the order-of-magnitude influence diagram model. In Section 6 we present the results
of our empirical evaluation. Section 7 overviews related
work, while Section 8 provides concluding remarks.

2

INFLUENCE DIAGRAMS

An influence diagram is defined by a tuple hX, D, U, Gi,
where X = {X1 , . . . , Xn } is a set of oval-shaped nodes
labeled by the chance variables which specify the uncertain decision environment, D = {D1 , . . . , Dm } is a set of
rectangle-shaped nodes labeled by the decision variables
which specify the possible decisions to be made in the domain, U = {U1 , . . . , Ur } are diamond-shaped nodes labeled by the utility functions which represent the preferences of the decision maker, and G is a directed acyclic
graph containing all the nodes X ∪ D ∪ U. As in belief
networks, each chance variable Xi ∈ X is associated with
a conditional probability table (CPT) Pi = P (Xi |pa(Xi )),
where pa(Xi ) ⊆ X ∪ D \ {Xi } are the parents of Xi in

The wildcatter could do a seismic test that will help determine the geological structure of the site. The test results can
show a closed reflection pattern (indication of significant
oil), an open pattern (indication of some oil), or a diffuse
pattern (almost no hope of oil). The probabilistic knowledge consists of the CPTs P (O) and P (S|O, T ), while the
utility function is the sum of U1 (T ) and U2 (D, O). The optimal policy is to perform the seismic test and to drill only
if the test results show an open or a closed pattern. The
maximum expected utility of this policy is 42.75.

Figure 1: The oil wildcatter influence diagram.
G. Similarly, each decision variable Dk ∈ D has a parent
set pa(Dk ) ⊆ X ∪ D \ {Dk } in G, denoting the variables
whose values will be known at the time of the decision and
may affect directly the decision. Non-forgetting is typically
assumed for an influence diagram, meaning that a decision
node and its parents are parents to all subsequent decisions.
Finally, each utility node Uj ∈ U is associated with a utility function that depends only on the parents pa(Uj ) of Uj .
The decision variables in an influence diagram are typically
assumed to be temporally ordered. Let D1 , D2 , ..., Dm be
the order in which the decisions are to be made. The chance
variables can be partitioned into a collection of disjoint sets
I0 , I1 , . . . , Im . For each k, where 0 < k < m, Ik is the
set of chance variables that are observed between Dk and
Dk+1 . I0 is the set of initial evidence variables that are
observed before the first D1 . Im is the set of chance variables left unobserved when the last decision Dm is made.
This induces a partial order ≺ over X ∪ D, as follows:
I0 ≺ D1 ≺ I1 ≺ · · · ≺ Dm ≺ Im [5].
A decision policy (or strategy) for an influence diagram is
a list of decision rules ∆ = (δ1 , . . . , δm ) consisting of one
rule for each decision variable. A decision rule for the decision Dk ∈ D is a mapping δk : Ωpa(Dk ) → ΩDk , where
for a set S ⊆ X ∪ D, ΩS is the Cartesian product of the
individual domains of the variables in S. Solving an influence diagram is to find the optimal decision policy that
maximizes the expected utility. The maximum expected
utility (MEU) is equal to:


r
n
X
X
X
X Y
 Pi ×
max · · ·
Uj  (1)
max
I0

D1

Im−1

Dm

Im

i=1

j=1

Example 1 For illustration, consider the influence diagram displayed in Figure 1 which is based on the classic
oil wildcatter decision problem [9]. An oil wildcatter must
decide either to drill or not to drill for oil at a specific site.

Variable Elimination Several exact methods have been
proposed over the past decades for solving influence diagrams using local computations [10, 13, 11, 5, 3, 8]. These
methods adapted classical variable elimination techniques,
which compute a type of marginalization over a combination of local functions, in order to handle the multiple types
ofPinformation (probabilities and utilities), marginalization
( and max) and combination (× for probabilities, + for
utilities)
Pinvolved in influence diagrams. Since the alternation of and max in Eq. 1 does not commute in general, it
prevents the solution technique from eliminating variables
in any ordering. Therefore, the computation dictated by
Eq. 1 must be performed along a legal elimination ordering that respects ≺, namely the reverse of the elimination
ordering is some extension of ≺ to a total order [5, 3].

3

FOUNDATIONS

Our approach towards a qualitative theory for influence
diagrams is based on the qualitative decision theory proposed by Wilson [14]. Wilson’s theory defines a set of abstract quantities called extended reals, denoted by R∗ , that
are used to represent qualitative probabilities and utilities.
Each extended real is a rational function p/q where p and
q are polynomials in ǫ with coefficients in the rationals,
where ǫ is a very small but unknown quantity so that the
extended reals can be used to represent information up to ǫ
precision. For example, quantities such as 1−ǫ and ǫ might
be used for qualitative probabilities likely and unlikely respectively, and ǫ−1 for a high utility. These quantities can
then be combined using standard arithmetic operations between polynomials for computing expected qualitative utilities. The resulting utilities are then compared among each
other by means of a total order on R∗ that is defined in [14].
3.1

ORDER-OF-MAGNITUDE CALCULUS

Rather than using extended reals explicitly, we adopt a simpler calculus that allows us to reason about the “order of
magnitude” of the extended reals [14]. We start with the
definition of an order-of-magnitude value that represents a
qualitative probability or utility value.
D EFINITION 1 An order-of-magnitude value is a pair

hσ, ni, where σ ∈ {+, −, ±} is called the sign and n ∈ Z
is called the order of magnitude, respectively.
Intuitively, for each integer n we have an element h+, ni
meaning “of order ǫn ”, and an element h−, ni meaning “of
order −ǫn ”. Moreover, if we add something of order ǫn
to something of order −ǫn then the result can be of order
±ǫm , for any m ≥ n. To ensure closure of the calculus
under addition, we therefore add the element h±, ni representing this set of possibilities. In the following, we also
define O = {hσ, ni | n ∈ Z, σ ∈ {+, −, ±}} ∪ {h±, ∞i},
O± = {h±, ni | n ∈ Z ∪ {∞}} and O+ = {h+, ni | n ∈
Z ∪ {∞}}. The element h±, ∞i will sometimes be written
as 0, element h+, 0i as 1, and element h−, 0i as -1.
Standard arithmetic operations such as multiplication (×)
and addition (+) follow from the semantics of the order-ofmagnitude values [14] and are defined next.
D EFINITION 2 (multiplication) Let a, b ∈ O be such that
a = hσ, mi and b = hτ, ni. We define a × b = hσ ⊗
τ, m + ni, where ∞ + n = n + ∞ = ∞ for n ∈ Z ∪ {∞}
and ⊗ is the natural multiplication of signs, namely it is the
commutative operation on {+, −, ±} such that +⊗− = −,
+ ⊗ + = − ⊗ − = +, and ∀σ ∈ {+, −, ±}, σ ⊗ ± = ±.
This multiplication is associative and commutative, and
∀a ∈ O, a × 0 = 0 and a × 1 = a, respectively. Furthermore, for b ∈ O \ O± , we define b−1 to be the multiplicative inverse of b, namely hσ, mi−1 = hσ, −mi for
σ ∈ {+, −}. Given a ∈ O, we define a/b = a × b−1 .
D EFINITION 3 (addition) Let a, b ∈ O be such that a =
hσ, mi and b = hτ, ni. We define a + b to be: (1) hσ, mi
if m < n; (2) hτ, ni if m > n; (3) hσ ⊕ τ, mi if m = n,
where + ⊕ + = +, − ⊕ − = −, and otherwise, σ ⊕ τ = ±.
Addition is associative and commutative, and a + 0 = a,
∀a ∈ O. For a, b ∈ O, let −b = −1 × b and a − b =
a+(−b). Clearly, we can write −hσ, mi = h−σ, mi, where
−(+) = −, −(−) = + and −(±) = ±. We also have the
distributivity: ∀a, b, c ∈ O, (a + b) × c = a × c + b × c.
3.2

ORDERING ON SETS OF
ORDER-OF-MAGNITUDE VALUES

We will use the following ordering over the elements of O,
which is slightly stronger than that defined in [14].
D EFINITION 4 (ordering) Let a, b ∈ O be such that a =
hσ, mi and b = hτ, ni. We define the binary relation < on
O by a < b if and only if either: (1) σ = + and τ = +
and m ≤ n; or (2) σ = + and τ = ± and m ≤ n; or (3)
σ = + and τ = −; or (4) σ = ± and τ = − and m ≥ n;
or (5) σ = − and τ = − and m ≥ n.
Given a, b ∈ O, if a < b then we say that a dominates b.
For A, B ⊆ O, we say that A < B if every element of

B is dominated by some element of A (so that A contains
as least as large elements as B), namely if for all b ∈ B
there exists a ∈ A with a < b. As usual, we write a ≻ b
if and only if a < b and it is not the case that b < a. It is
easy to see that < is a partial order on O and the following
monotonicity property holds:
P ROPOSITION 1 Let a, b, c ∈ O. If a < b then a + c <
b + c, and if a < b and c ∈ O+ then a × c < b × c.
Any finite set of order-of-magnitude values can therefore
be represented by its maximal elements with respect to <.
D EFINITION 5 (maximal set) Given a finite set A ⊆ O,
we define the maximal set of A, denoted by max< (A), to be
the set consisting of the undominated elements in A, namely
max< (A) = {a ∈ A | ∄b ∈ A such that b ≻ a}.

4

OPERATIONS ON SETS OF
ORDER-OF-MAGNITUDE VALUES

We introduce now the main operations that can be performed over partially ordered finite sets of order-ofmagnitude values. In particular, we extend the addition (+)
and multiplication (×) operations from singleton to sets of
order-of-magnitude values as well as define a maximization
operation over such sets.
4.1

ADDITION, MULTIPLICATION AND
MAXIMIZATION

Given two finite sets A, B ⊆ O and q ∈ O+ , we define
the summation and multiplication operations as A + B =
{a + b | a ∈ A, b ∈ B} and q × A = {q × a | a ∈
A}, respectively. The maximization operation is defined
by max(A, B) = max< (A ∪ B).
In order to use the order-of-magnitude calculus to define
a qualitative version of influence diagrams we need to be
sure that each of +, × and max is commutative and associative, and also to give sufficient conditions such that the
following distributivity properties hold:
∀q, q1 , q2 ∈ O+ and ∀A, B, C ⊆ O
D1 q × (A + B) = (q × A) + (q × B)
D2 (q1 + q2 ) × A = (q1 × A) + (q2 × A)
D3 max(A, B) + C = max(A, C) + max(B, C)
It is easy to see that +, × and max are commutative and
associative, and the distributivity properties (D1) and (D3)
hold as well. Unfortunately, the distributivity property (D2)
does not always hold for sets of order-of-magnitude values.
To give a simple example, let q1 = h+, 2i, q2 = h+, 3i and
let A = {h±, 1i, h±, 4i}. Then, (q1 + q2 ) × A yields the set

{h±, 3i, h±, 6i}, whereas (q1 × A) + (q2 × A) is equal to
{h±, 3i, h±, 4i, h±, 6i}. This property does however hold
for convex sets, as we will show next.

We can show now that any finite subset of O is in fact ≡equivalent with a set of order-of-magnitude values containing one or two elements, namely:

4.2

T HEOREM 1 Let A be any finite subset of O. Then either
A ≡ {a} for some a ∈ O, or ∃ m, n ∈ Z with m < n and
σ ∈ {+, −, ±} such that A ≡ {h±, mi, hσ, ni}.

CONVEX SETS AND CONVEX CLOSURE

Based on Definition 5, every element of a finite set A ⊆
O is dominated by some maximal element in A. We can
therefore define an equivalence relation between finite sets
of order-of-magnitude values, as follows.
D EFINITION 6 (relation ≈) Given two finite sets A, B ⊆
O, we say that A is ≈-equivalent with B, denoted by A ≈
B, if and only if A < B and B < A.
Clearly, ≈ is an equivalence relation, namely it is reflexive,
symmetric and transitive. We then have that:
P ROPOSITION 2 Let A, B, C ⊆ O be finite sets and let
q ∈ O+ . The following properties hold: (1) A ≈ B if
and only if max< (A) = max< (B); (2) if A ≈ B then
A + C ≈ B + C and q × A ≈ q × B.
We introduce next the notions of convex sets and convex
closure of sets of order-of-magnitude values.
D EFINITION 7 A set A ⊆ O is said to be convex if
∀q1 , q2 ∈ O+ with q1 + q2 = 1, and ∀a, b ∈ A, we have
that (q1 × a) + (q2 × b) ∈ A. The convex closure C(A)
of a set AP⊆ O is defined to consist of every element of
k
the form i=1 (qi × ai ), where k is an arbitrary natural
Pk
number, each ai ∈ A, each qi ∈ O+ and i=1 qi = 1.
Consider two elements hσ, mi and hτ, ni in O, where we
can assume without loss of generality that m ≤ n. Any
convex combination of these two elements is of the form
hθ, li where l ∈ [m, n] and if l < n then θ = σ; if l = n
then θ = σ ⊕τ or θ = τ . This implies that the convex combination of a finite number of non-zero elements is finite
(since every element a in the convex combination has its
order restricted to be within a finite range), and so, in particular can be represented by its maximal set. In fact, this
property holds even if we allow the zero element h±, ∞i.
We can define now the following equivalence relation:
D EFINITION 8 (relation ≡) Given the finite sets A, B ⊆
O, we say that A is ≡-equivalent with B, denoted by A ≡
B, if and only if C(A) ≈ C(B).
Therefore, two sets of order-of-magnitude values are considered equivalent if, for every convex combination of elements of one, there is a convex combination of elements of
the other which is at least as good.
P ROPOSITION 3 Let A, B, C ⊆ O be finite sets and let
q ∈ O+ . The following properties hold: (1) A ≡ B if and
only if max< (C(A)) = max< (C(B)); (2) if A ≡ B then
A + C ≡ B + C, q × A ≡ q × B, and A ∪ C ≡ B ∪ C.

4.3

OPERATIONS ON EQUIVALENT SETS OF
ORDER-OF-MAGNITUDE VALUES

Theorem 1 allows us to efficiently perform the required
operations (ie, summation, multiplication and maximization) on sets of order-of-magnitude values. We assume that
the subsets O are either singleton sets or are of the form
{h±, mi, hσ, ni}, where m < n. We need to ensure that
the outputs are of this form as well. For a given a ∈ O, we
use the notation σ(a) and â to denote the sign and the order
of magnitude of a, respectively,
Multiplication Given A ⊆ O of the required form, and
q ∈ O+ , we need to generate a set A′ that is ≡-equivalent
with q × A. Write q as h+, li. If A = {hσ, mi} then q × A
is just equal to the singleton set {hσ, l + mi}. Otherwise, A
is of the form {h±, mi, hσ, ni}, where m < n. Then q × A
equals {h±, l + mi, hσ, l + ni}, which is of the required
form, since l + m < l + n.
Maximization Given the sets A1 , A2 , . . . , Ak ⊆ O, each
of them having the required form, we want to compute
a set A′ that is ≡-equivalent to max(A1 , . . . , Ak ). Let
A = A1 ∪ · · · ∪ Ak and, for σ ∈ {+, −, ±}, we define
mσ and nσ as follows: if there exists no element a ∈ A
with σ(a) = σ then we say that mσ and nσ are both undefined; otherwise we have that mσ = min{l : hσ, li ∈ A}
and nσ = max{l : hσ, li ∈ A}, respectively. The set A′ is
computed as follows: (1) if m+ and m± are both undefined
(there are only negative elements) then A′ = {h−, n− i};
(2) if m+ is defined and either m+ ≤ m± or m± is undefined then A′ = {h+, m+ i}; (3) if m+ > m± (and both
are defined) then A′ = {h±, m± i, h+, m+ i}; (4) if m+
is undefined (no positive elements) and either n± ≥ n−
or n− is undefined then A′ = {h±, m± i, h±, n± i} ; and
(5) if m+ is undefined (there are no positive elements) and
n± < n− then A′ = {h±, m± i, h−, n− i}.
Summation Given the sets A1 , A2 , . . . , Ak ⊆ O of required form as before, we want to compute a set A′ that
is ≡-equivalent to (A1 + · · · + Ak ). We can write Ai as
{ai , bi } where if ai 6= bi then σ(ai ) = ± and âi < b̂i .
Then, (A1 + · · · + Ak ) ≡ {a, b} where a = a1 + · · · + ak
and b = b1 + · · · + bk . We can write b more explicitly
as hσ(b), b̂i where b̂ = min(b̂1 , . . . , b̂k ), and σ(b) = + if
and only if all bi with minimum b̂i have σ(bi ) = +; else
σ(b) = − if all bi with minimum b̂i have σ(bi ) = −; else
σ(b) = ±. Similarly for a. If σ(a) 6= ± then {a, b} reduces
to a singleton because a = b.

Example 2 Consider the sets A1 = {h±, 3i, h±, 4i} and
A2 = {h±, 3i, h±, 6i}. To generate A′ ≡ max(A1 , A2 ),
we first compute m± = 3 and n± = 6, and then we have
that A′ = {h±, 3i, h±, 6i} which corresponds to the extreme points of the input sets. Similarly, we can compute
the set A′′ ≡ (A1 + A2 ) as {h±, 3i, h±, 4i}.
4.4

DISTRIBUTIVITY PROPERTIES REVISITED

In summary, we can show now that all three distributivity
properties hold with respect to the ≡-equivalence relation
between finite sets of order-of-magnitude values.
T HEOREM 2 ∀q, q1 , q2 ∈ O+ and ∀A, B, C ⊆ O finite
sets we have that: (D1) q × (A + B) ≡ (q × A) + (q × B);
and (D2) (q1 + q2 ) × A ≡ (q1 × A) + (q2 × A); and (D3)
max(A, B) + C ≡ max(A, C) + max(B, C).

5

ORDER-OF-MAGNITUDE INFLUENCE
DIAGRAMS

In this section, we introduce a new qualitative version of the
influence diagram model based on an order-of-magnitude
representation of the probabilities and utilities.
5.1

Table 1: Optimal policies sets for order-of-magnitude influence diagrams corresponding to the oil wildcatter problem.
decision rule
Test?
Drill?

S=closed, T=yes
S=open, T=yes
S=diffuse, T=yes
S=closed, T=no
S=open, T=no
S=diffuse, T=no
order-of-magnitude MEU

ǫ = 0.1
{yes,no}
yes
yes
no
yes
yes
yes
h+, −1i

OOM-ID
ǫ = 0.01
ǫ = 0.001
{yes, no}
{yes, no}
yes
{yes, no}
yes
{yes, no}
{yes, no}
{yes, no}
yes
{yes, no}
yes
{yes, no}
yes
{yes, no}
h+, 0i
{h±, 0i, h+, ∞i}

THE QUALITATIVE DECISION MODEL

An order-of-magnitude influence diagram (OOM-ID) is a
qualitative counterpart of the standard influence diagram
graphical model. The graphical structure of an OOM-ID
is identical to that of a standard ID, namely it is a directed
acyclic graph containing chance nodes (circles) for the random discrete variables X, decision nodes (rectangles) for
the decision variables D, and utility nodes (diamonds) for
the local utility functions U of the decision maker. The
directed arcs in the OOM-ID represent the same dependencies between the variables as in the standard model. Each
chance node Xi ∈ X is associated with a conditional probability distribution Pio that maps every configuration of its
scope to a positive order-of-magnitude probability value,
namely Pio : ΩXi ∪pa(Xi ) → O+ . The utility functions
Ujo ∈ U represent partially ordered preferences which
are expressed by finite sets of order-of-magnitude values,
namely Ujo : ΩQj → 2O , where Qj is the scope of Uj .
Solving an order-of-magnitude influence diagram is to find
the optimal policy ∆ = (δ1 , . . . , δmQ) that maximizes
Pr the
n
order-of-magnitude expected utility i=1 Pio × j=1 Ujo .
We define the optimal policies set of an order-of-magnitude
influence diagram to be the set of all policies having the
same maximum order-of-magnitude expected utility.
5.2

Figure 2: Order-of-magnitude probability and utility functions corresponding to the oil wildcatter influence diagram.

AN EXAMPLE

Figure 2 displays the order-of-magnitude probability and
utility functions of an OOM-ID corresponding to the oil

wildcatter decision problem from Example 1. For our
purpose, we used an extension of Spohn’s mapping from
the original probability distributions and utility functions
to their corresponding order-of-magnitude approximation
[12, 2]. Specifically, given a small positive ǫ < 1, the
order-of-magnitude approximation of a probability value
p ∈ (0, 1] is h+, ki such that k ∈ Z and ǫk+1 < p ≤ ǫk ,
while the order-of-magnitude approximation of a positive
utility value u > 0 is h+, −ki such that ǫ−k ≤ u <
ǫ−(k+1) (the case of negative utilities is symmetric). For
example, if we consider ǫ = 0.1 then the probability
P (S = closed|O = dry, T = yes) = 0.01 is mapped to
h+, 2i, while the utilities U2 (O = dry, D = yes) = −70
and U2 (O = soaking, D = yes) = 200 are mapped to
h−, −1i and h+, −2i, respectively.
Table 1 shows the optimal policies sets (including the maximum order-of-magnitude expected utility) obtained for
the order-of-magnitude influence diagrams corresponding
to ǫ ∈ {0.1, 0.01, 0.001}. When ǫ = 0.1, we can see
that there are two optimal policies having the same maximum order-of-magnitude expected utility, namely ∆1 (for
T = yes) and ∆2 (for T = no). Therefore, if the seismic
test is performed (T = yes) then drilling is to be done only
if the test results show an open or closed pattern. Otherwise
(T = no), the wildcatter will drill regardless of the test results. Ties like these at the decision variables are expected
given that the order-of-magnitude probabilities and utilities
represent abstractions of the real values. The expected utilities of ∆1 and ∆2 in the original influence diagram are

42.75 and 20.00, respectively.

Algorithm 1: ELIM-OOM-ID

When ǫ = 0.01, we also see that both drilling options are
equally possible if the seismic test is performed and the
test results show a diffuse pattern. In this case, there are
four optimal policies having the same maximum order-ofmagnitude expected utility. Finally, when ǫ = 0.001, we
can see that all decision options are possible and the corresponding optimal policies set contains 128 policies. The
explanation is that the order-of-magnitude influence diagram contains in this case only trivial order-of-magnitude
values such as h+, 0i, h−, 0i and h+, ∞i, respectively.

Data: An OOM-ID hX, D, U, Gi, bucket structure along a legal
elimination ordering of the variables o
Result: An optimal policy ∆
// top-down phase
for p = t downto 1 do
let Λp = {λ1 , ..., λj } and Θp = {θ1 , ..., θk } be the
probability and utility components in buckets[p]
if Yp is a chance variable then
P Q
λp ← Yp ji=1 λi
Q
P
P
θp ← (λp )−1 × Yp (( ji=1 λi ) × ( kj=1 θj ))

1
2
3
4
5

else if Yp is a decision variable then
P
if Λp = ∅ then θp ← maxYp kj=1 θj
else
Q
λp ← maxYp ji=1 λi
Q
P
p
θ ← maxYp (( ji=1 λi ) × ( kj=1 θj ))

6
7
8

5.3

VARIABLE ELIMINATION

9
10

Theorem 2 ensures the soundness and correctness of a variable elimination procedure using the summation (+), multiplication (×) and maximization (max) operations over
partially ordered sets of order-of-magnitude values, for
solving order-of-magnitude influence diagrams.
Therefore, a variable elimination algorithm that computes
the optimal policy of an order-of-magnitude influence diagram (and also the maximum order-of-magnitude expected
utility) is described by Algorithm 1. The algorithm, called
ELIM-OOM-ID, is based on Dechter’s bucket elimination
framework for standard influence diagrams [3] and uses a
bucket structure constructed along a legal elimination ordering o = Y1 , . . . Yt of the variables in X ∪ D. The bucket
data-structure, called buckets, associates each bucket with
a single variable. The bucket of Yp contains all input probability and utility functions whose highest variable is Yp .
The algorithm processes each bucket, top-down from the
last to the first, by a variable elimination procedure that
computes new probability (denoted by λ) and utility (denoted by θ) components which are then placed in corresponding lower buckets (lines 1–11). The λp of a chance
bucket is generated by multiplying all probability components and eliminating by summation the bucket variable.
The θp of a chance bucket is computed as the average utility of the bucket, normalized by the bucket’s compiled λp .
For a decision variable, we compute the λp and θp components in a similar manner and eliminate the bucket variable
by maximization. In this case, the product of the probability components in the bucket is a constant when viewed
as a function of the bucket’s decision variable [5, 15] and
therefore, the compiled λp is a constant as well.
In the second, bottom-up phase, the algorithm computes an
optimal policy. The decision buckets are processed in reverse order, from the first variable to the last. Each decision
rule is generated by taking the argument of the maximization operator applied over the combination of the probability and utility components in the respective bucket, for each
configuration of the variables in the bucket’s scope (ie, the
union of the scopes of all functions in that bucket minus the

15

place each λp and θp in the bucket of the highest-index
variable in its scope
// bottom-up phase
for p = 1 to t do
if Yp is a decision variable then
P
Q
δp ← arg maxYp (( ji=1 λi ) × ( kj=1 θj ))
∆ ← ∆ ∪ δp

16

return ∆

11

12
13
14

bucket variable Yp ).
T HEOREM 3 (complexity) Given an OOM-ID with n variables, algorithm ELIM-OOM-ID is time and space O(n ·
∗
k wo ), where wo∗ is the treewidth of the legal elimination
ordering o and k bounds the domain size of the variables.

6

EXPERIMENTS

In this section, we evaluate empirically the quality of the
decision policies obtained for order-of-magnitude influence
diagrams. All experiments were carried out on a 2.4GHz
quad-core processor with 8GB of RAM.
Methodology We experimented with random influence
diagrams described by the parameters hnc , nd , k, p, r, ai,
where nc is the number of chance variables, nd is the number of decision variables, k is the maximum domain size,
p is the number of parents in the graph for each variable, r
is the number of root nodes and a is the arity of the utility
functions. The structure of the influence diagram is created
by randomly picking nc + nd − r variables out of nc + nd
and, for each, selecting p parents from their preceding variables, relative to some ordering, whilst ensuring that the
decision variables are connected by a directed path. A single utility node with a parents picked randomly from the
chance and decision nodes is then added to the graph.
We generated two classes of random problems with parameters hn, 5, 2, 2, 5, 5i and having either positive utilities
only or mixed (positive and negative) utilities. They are

denoted by P : hn, 5, 2, 2, 5, 5i and M : hn, 5, 2, 2, 5, 5i,
respectively. In each case, 75% of the chance nodes were
assigned extreme CPTs which were populated with numbers drawn uniformly at random between 10−5 and 10−4 ,
whilst ensuring that the table is normalized. The remaining
CPTs were randomly filled using a uniform distribution between 0 and 1. For class P , the utilities are of the form 10u ,
where u is an integer uniformly distributed between 0 and
5. For class M , the utilities are of the form +10u or −10u ,
where u is between 0 and 5, as before, and we have an
equal number of positive and negative utility values. Each
influence diagram instance was then converted into a corresponding order-of-magnitude influence diagram using the
mapping of the probabilities and utilities described in Section 5.2, for some ǫ < 1. Intuitively, the smaller ǫ is, the
coarser the order-of-magnitude approximation of the exact
probability and utility values (ie, more information is lost).

Results Figure 3 displays the distribution of the relative
errors ηmed (top) and ηmax (bottom) obtained on orderof-magnitude influence diagrams derived from class P (ie,
positive utilities), as a function of the problem size (given
by the number of variables), for ǫ ∈ {0.5, 0.05, 0.005}.
Each data point and corresponding error bar represents the
25th , median and 75th percentiles obtained over 30 random problem instances generated for the respective problem size. We can see that ηmed is the smallest (less than
10%) for ǫ = 0.5. However, as ǫ decreases, the loss of
information due to the order-of-magnitude abstraction increases and the corresponding relative errors ηmed increase
significantly. Notice that the best policy ∆max derived
from the order-of-magnitude influence diagram was almost
identical to that of the corresponding standard influence diagram, for all ǫ (ie, the error ηmax is virtually zero).
Figure 4 shows the distribution of ηmed (top) and ηmax
(bottom) obtained on order-of-magnitude influence diagrams from class M (ie, mixed utilities). The pattern of
the results is similar to that from the previous case. However, in this case, the errors span over two or three orders of

relative error of OOM median policy (%)

ε=0.5
ε=0.05
ε=0.005

80

60

40

20

0

10

20

30

40
variables

50

60

30

40
variables

50

60

70

100
relative error of OOM best policy (%)

Measures of Performance To measure how close the decision policies derived from the optimal policy set of an
order-of-magnitude influence diagram are to the optimal
policy of the corresponding standard influence diagram, we
use two relative errors, defined as follows. Let I be an influence diagram and let Iǫ be the corresponding order-ofmagnitude approximation, for some ǫ value. We sample s
different policies, uniformly at random, from the optimal
policies set of Iǫ , and for each sampled policy we compute
its expected utility in I. Let ∆med be a policy corresponding to the median expected utility vmed amongst the samples. We define the relative error ηmed = |(v − vmed )/v|,
where v is the maximum expected utility of the optimal
policy in I. Similarly, we define ηmax = |(v − vmax )/v|,
where ∆max is the best policy having the highest expected
utility vmax amongst the samples.

100

ε=0.5
ε=0.05
ε=0.005
80

60

40

20

0

10

20

70

Figure 3: Results for class P influence diagrams. We show
the distribution of the relative errors ηmed (top) and ηmax
(bottom) for ǫ ∈ {0.5, 0.05, 0.005}. # of samples s = 100.
magnitude, especially for ǫ = 0.05 and 0.005. This is because the sampled policy space includes policies which are
quite different from each other and, although they have the
same maximum order-of-magnitude expected utility, their
expected utility in the corresponding standard influence diagram is significantly different. For this reason, we looked
in more detail at the distribution of the expected utility values of 100 policies sampled uniformly at random from the
optimal policies set of a class M OOM-ID instance with
45 variables, for ǫ ∈ {0.5, 0.05, 0.005}. As expected, we
observed that the smallest sample variance is obtained for
ǫ = 0.5. For ǫ = 0.05 and ǫ = 0.005, the samples are
spread out even more from the mean, and the variance of
the expected utility is significantly larger. This explains the
large variations of the relative errors ηmed and ηmax , especially for smaller ǫ values (eg, ǫ = 0.05 and ǫ = 0.005).

7

RELATED WORK

Several extensions of the standard influence diagram model
have been proposed in recent years to deal with imprecise
probabilistic and utility information. Garcia and Sabbadin
[4] introduced possibilistic influence diagrams to model
and solve decision making problems under qualitative uncertainty in the framework of possibilistic theory. Pralet et
al [8] considered a generalized influence diagram system

attribute utility allowing trade-offs.

relative error of OOM median policy (%)

104
103


