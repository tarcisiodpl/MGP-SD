
In a multiparty message-passing model of communication, there are k players. Each player has a
private input, and they communicate by sending messages to one another over private channels. While
this model has been used extensively in distributed computing and in multiparty computation, lower
bounds on communication complexity in this model and related models have been somewhat scarce. In
recent work [40, 46, 47], strong lower bounds of the form Ω(n · k) were obtained for several functions in
the message-passing model; however, a lower bound on the classical Set Disjointness problem remained
elusive.
In this paper, we prove tight lower bounds of the form Ω(n · k) for the Set Disjointness problem in
the message passing model. Our bounds are obtained by developing information complexity tools in the
message-passing model, and then proving an information complexity lower bound for Set Disjointness.
As a corollary, we show a tight lower bound for the task allocation problem [19] via a reduction from
Set Disjointness.

∗

Department of Computer Science, Princeton University, mbraverm@cs.princeton.edu, Research supported in part by
an Alfred P. Sloan Fellowship, an NSF CAREER award (CCF-1149888), and a Turing Centenary Fellowship.
†
Department of Computer Science, University of Toronto, faith@cs.toronto.edu, Research supported in part by
NSERC.
‡
Department of Computer Science, University of Toronto, rotem@cs.toronto.edu, Research supported in part by
NSERC.
§
Department of Computer Science, University of Toronto, toni@cs.toronto.edu, Research supported in part by NSERC.
¶
Department of Computer Science, University of Toronto, vinodv@cs.toronto.edu, Research supported in part by
NSERC, DARPA award FA8750-11-2-0225 and an Alfred P. Sloan Fellowship.

1

1 Introduction
One of the most natural application domains for communication complexity is distributed computing: When
we wish to study the cost of computing in a network spanning multiple cores or physical machines, it is very
useful to understand how much communication is necessary, since communication between machines often
dominates the cost of the computation. Accordingly, lower bounds in communication complexity have
been used to obtain many negative results in distributed computing, from the round complexity of finding
a minimum-weight spanning tree [42] to computing functions of distributed data [37, 29] and distributed
computation and verification of network graph structures and properties [42, 23].
To the best of our knowledge, however, all applications of communication complexity lower bounds
in distributed computing to date have used only two-player lower bounds. The reason for this appears
to be twofold: First, the models of multi-party communication favored by the communication complexity
community, the number-on-forehead model and the number-in-hand broadcast model, do not correspond to
most natural models of distributed computing. Second, two-party lower bounds are surprisingly powerful,
even for networks with many players. A typical reduction from a two-player communication complexity
problem to a distributed problem T finds a sparse cut in the network, and shows that, to solve T , the two
sides of the cut must implicitly solve, say, Set Disjointness [30]. However, there are problems that cannot be
addressed by reduction from a two-player problem, because such reductions must reveal almost the entire
structure of the network to one of the two players. (One such example is described in [29].)
In this paper, we study communication complexity in message-passing models, where each party has a
private input, and the parties communicate by sending messages to each other over private channels. These
models have been used extensively in distributed computing, for example, to study gossiping protocols [27],
to compute various functions of distributed data [28], and to understand fundamental problems, such as
achieving consensus in the presence of failures [22]. Message passing models are also used to study privacy
and security in multi-party computation.
In this paper, we choose to focus on the Set Disjointness problem [14]. In Set Disjointness, denoted
D ISJ n,k , k players each receive a set Xi ⊆ [n], and their goal is to determine whether the intersection
Tk
i=1 Xi is empty or not. An Ω(n) lower bound on the two-player version of Set Disjointness, due to
Kalyanasundaram, Schnitger and Razborov [26, 41], is one of the most widely applied lower bounds in
communication complexity. The lower bound was recently re-proven as an information complexity lower
bound [5], showing that any protocol for two-party set disjointness must “leak” a total of Ω(n) bits about
the input.
Our main result is a tight lower bound on the communication complexity of the set disjointness problem
in a multiparty message-passing model, namely the coordinator model of Dolev and Feder [18]. This lower
bound implies a corresponding bound in the “truly distributed” message-passing model, where there is no
coordinator. Our main technical tool in this paper is information complexity, which has its origins in the
work of Chakrabarthi, Shi, Wirth and Yao [12], and which has recently played a pivotal role in several
communication complexity lower bounds.
Our main theorem is an Ω(nk) lower bound following lower bound on the informaiton complexity (and
hence also the communication complexity) of the set disjointness function in the multi-party coordinator
model.
Theorem 1.1. For every δ > 0, n ≥ 1 and k = Ω(log n), there is a distribution ζ such that the information complexity of Set Disjointness is ICζ,δ (DISJn,k ) = Ω(nk) and its communication complexity is
CCδ (DISJn,k ) = Ω(nk).
We then apply this lower bound to obtain a lower bound of Ω(nk) on the Task Allocation problem,
2

TASK A LLOC n,k . In this recently proposed problem [19], k players must partition n tasks among themselves.
Task Allocation is a useful primitive for distributed systems, where a number of tasks must be performed by
the participants in the computation, but not every participant is able to carry out every task. We describe this
problem more formally below.
Information complexity and communication complexity. Our main technical tool in this paper is information complexity. The main technical result of the present paper concerns the problem of set disjointness.
Variants of set disjointness are perhaps the most studied problems in communication complexity. In the twoparty case, it is not hard to see that evaluating the disjointness of two subsets of [n] deterministically requires
at least n + 1 bits of communication, for example, using a fooling set argument [31]. In the randomized
model, when error is allowed, an Ω(n) lower bound is also known, although it is considerably more difficult
to prove [26, 41]. This result was later improved using information-theoretic techniques by Bar-Yossef et
al. [5]. Further advances in information complexity allow one to calculate the two-party communication
complexity of disjointness precisely, up to additive o(n) terms [9].
In the multi-party case, there are three main models to consider, all with interesting applications. The
first model is the number on forehead (NOF) model, where each player is given all inputs except for one.
The NOF model has important connections to circuit lower bounds for the ACC0 class [6]. Since the disjointness problem has small AC0 circuits, this means that for k > log n, the communication complexity of
NOF disjointness is polylogarithmic. Also notice that since the entire calculation in this case can be carried
out by two participants, yielding a trivial O(n) upper bound. The exact dependence of the communication
complexity on n and k has been the subject of considerable investigation [13, 34, 43], with the currently
√
strongest lower bound being Ω( n/2k k) [44]. The second model is the number in hand blackboard model.
In this model each party is only given her input, and the communication is carried out via a blackboard,
so each message transmitted by a player is received by all other players. In this case, the communication
complexity of disjointness might be as high as Θ(n log k) (note that an Ω(n) lower bound is trivial). Due to
applications in streaming computation lower bounds, the version where the sets are either fully disjoint or
have a single element in common has been studied. A lower bound of Ω(n/k) has been shown in this case
[11, 24, 25] using information-theoretic techniques. The information complexity approach usually proceeds
in two steps: first, a direct-sum result shows that the amount of information the players convey about the
problem is additive about the coordinates of the problem (i.e. scales with n in the case of disjointness);
second, it is shown that to solve the one-coordinate version of the problem one needs to convey a non-trivial
amount of information (Ω(1/k) in the case of the blackboard model).
In this paper, we consider message-passing models of communication complexity. In all of the multiparty models discussed so far, messages are broadcast to a centralized blackboard, so that the entire communication transcript is seen by all players. In message passing models (also known as private channel
models), the players communicate to one another by sending and receiving messages through private pairwise channels. Unlike the other models, it is possible to achieve Ω(n · k) lower bounds on problems in
message passing models [38]. We will focus on the coordinator message passing model because it is most
similar to standard communication complexity models, and lower bounds in this model imply similar lower
bounds for other message passing models. In the coordinator model [18], the players communicate with a
coordinator by sending and receiving messages on private channels.
A recent paper [40] developed a new technique, called symmetrization, for obtaining lower bounds of
the form Ω(n · k) via a reduction to the two party case. The symmetrization technique works for coordinatewise problems such as Set Intersection, where the parties need to compute the intersection of their sets;
this amounts to coordinate-wise AND on the players’ inputs. However, symmetrization seems to fall short
of yielding results for the multiparty Set Disjointness problem, and the development of new information3

theoretic machinery seems necessary.
Another recent line of work dealing with communication complexity in the message-passing setting
appears in [46, 47]. In these papers, the main interest is in distributed streaming or distributed data aggregation: each of k machines holds some data set or receives an input stream, and we wish to compute or
approximate some function of the joint input, either through a central coordinator [46] or in a decentralized
manner [47]. In [46], a lower bound of Ω(n · k) is proven for the Gap-Majority(2-DISJ) problem: here
the coordinator holds a set S, each player i ∈ [k] holds a set Ti , and the goal is to distinguish the case
where a “large majority” of the intersections {D ISJ n,2 (S, Ti )}ki=1 are empty from the case where only a
“small minority” are empty. (The precise values of “large majority” and “small minority” are parameters
to the problem.) To obtain this lower bound, [46] first proves a direct-sum like result showing that, in order to compute the Gap-Majority of k bits Z1 , . . . , Zk in the message-passing model, a protocol must leak
Ω(k) bits of information about Z1 , . . . , Zk . The known Ω(n) lower bound on the information complexity
of D ISJ n,2 [5] is then applied to “lift” the Ω(k) one-bit lower bound on Gap-Majority to an Ω(nk) lower
bound on Gap-Majority(2-DISJ). In [47], similar techniques are used to obtain optimal Ω(nk) lower bounds
on a variety of problems in the decentralized message-passing model, including computing the number of
distinct elements in the joint input, and checking various graph properties when the input is interpreted as a
graph.
The message-passing model and its history in distributed computing. The message-passing model
is one of the fundamental models in the theory of distributed computing, and many variations of it have
been studied. The famous consensus impossibility result [22] was originally proven for message-passing
systems with faulty processors, and it is also a common setting for other forms of consensus (e.g., Byzantine
consensus [39] and randomized consensus [7], among many others). Lamport’s seminal paper introducing
the causal order of events in a distributed system [32] and his later Paxos protocol for consensus [33] are
also situated in the message-passing model. There is also much work on achieving data consistency through
replication in message-passing systems (e.g., [4]). More recently, gossip protocols [20, 27, 28, 17, 2] have
received considerable attention. In gossip (also called rumor-spreading), the goal is to quickly disseminate
information throughout the network or compute some aggregate function of the information; this is achieved
by having every node contact a small number of other nodes (typically, but not always, selected at random)
to exchange information with them. Gossip protocols often use very large messages; for instance, a node
might forward all the rumors it has collected so far in every round.
These problems and others are sometimes studied in fully-connected networks, and sometimes in networks with an arbitrary graph topology, where communication is more restricted. Lower bounds for the
model that we focus on in this paper, the coordinator model, implies lower bounds for the basic message
passing model where every node can directly communicate with every other node. It remains interesting future work to extend and apply our techniques in settings where communication is governed by an underlying
network topology which is not fully connected.
Finally, we point out that the coordinator model is interesting in itself: although it does not model a fullydecentralized distributed system, it is appropriate for data centers or for sensor networks with centralized
control. There is a growing body of work on streaming and sketching algorithms set in the coordinator
model [15, 35, 36].
Connection to secure multiparty computation. Our results also have applications to showing lower
bounds on the “amount of privacy” that one can achieve in the context of secure multiparty computation.
In the field of secure multiparty computation, the goal is for k players to communicate over a network
to compute a joint function f on their inputs x1 , . . . , xk while ensuring that no coalition of t players learn
any information about the remaining players’ inputs (other than what is already implied by their own inputs
4

and outputs). In the 1980s, the work of Ben-Or, Goldwasser and Wigderson [8] showed multiparty protocols in the message-passing model for computing any function in an information-theoretically private way,
assuming that the corruption threshold t < k/2.1 In addition, we know that information-theoretic perfect
privacy is impossible to achieve if t ≥ k/2. That is, the adversary must learn some information about the
honest players’ inputs in this setting. An important question that remains is: how much information must
the parties reveal about their inputs in order to compute a function f ?
Recently, a number of works investigated this quantitative question in the two-party setting from the
framework of information complexity [21, 1]. We believe that the information complexity tools developed
here will lead to a better quantitative understanding of privacy in multiparty computation. For example, our
information complexity lower bound already shows that in any k-party protocol for set disjointness there
is a constant fraction of players i for which either (a) player i learns Ω(n) bits of information about the
collective inputs of the players in [k] \ {i}, or (b) player i ends up revealing Ω(n) bits of information about
its own input to the other players. We leave a more thorough investigation of this connection as future work.
Organization of the Paper. The remainder of the paper is organized as follows. We begin by giving some
intuition about our approach for obtaining an Ω(kn) lower bound on the communication complexity of set
disjointness. In Section 3, we present necessary definitions and facts about information theory, Hellinger
distance, and information complexity. The next two sections present our lower bound, first proving that the
information cost of solving D ISJ n,k is at least n times the information cost of solving D ISJ 1,k = A NDk , and
then proving that it is at least Ω(k). Finally, in Section 7, we reduce set disjointness to the task allocation
problem, to obtain an Ω(kn) lower bound on its communication complexity.

2 Overview: Why is Set Disjointness Hard?
Before diving into the technical details, let us explain the motivation behind our definition of information
cost and the hard distribution we use in the lower bound.
Choosing the “right” notion of information complexity. There are several possible ways to quantify the
amount of information leaked by a protocol that solves D ISJ n,k , which might at first glance seem natural:
• External information cost, I(X; Π(X)): how much information an external observer gains about the
input X by observing the transcript of all the players and the coordinator. External information cost
was used to prove the optimal Ω(n/k) lower bound on Promise Set Disjointness in the broadcast
model [24].
The external information cost can also be viewed as the coordinator’s information cost, because the
coordinator observes the entire transcript and does not initially know any of the inputs.
P
• The players’ information cost, i I(X−i ; Πi (X) | Xi ): how much the players together learn about
the input X from their interactions with the coordinator, given their private input.
Unfortunately, neither of these is high enough to yield an Ω(kn) lower bound on Set Disjointness. It is easy
to see that the players’ information cost is not always high: In the trivial protocol where all players send
their inputs to the coordinator, the players do not learn anything. Of course, in this protocol, the coordinator
learns the entire input.
1

While our description focuses on the notion of semi-honest corruptions where the adversary corrupts t players who run the
protocol as prescribed, but try to learn information about the other players’ inputs from the transcript of the protocol execution.
These results have also been extended to provide strong notions of security against malicious corruptions, sometimes at the expense
of a smaller corruption threshold t.

5

Likewise, the coordinator’s information cost is not always high. To see why, consider the following
protocol: For each coordinate j, the coordinator searches for the smallest index i such that Xji = 0, by
contacting the players in order i = 1, . . . , k and asking them to send Xji . If Xji = 0 for some i, then
T
j 6∈ ki=1 X i , and the coordinator moves on to coordinate j + 1 without asking the remaining players
ℓ > i for Xjℓ . Otherwise, all players i ∈ [k] have Xji = 1) and the coordinator halts with output “no”, as
T
j ∈ ki=1 X i .
The transcript of the protocol can be losslessly compressed into O(n log k) bits by simply writing,
for each coordinate j, the index of the first player i that has Xji = 0, or writing 0 if there is no such
player. Therefore the coordinator cannot learn more than O(n log k) bits about the input by observing the
transcript. On the other hand, in this protocol the players gain a significant amount of information: each
player i from which the coordinator requests Xji learns that Xjℓ = 0 for all ℓ < i. This is not necessarily
a lot of information. In fact, in the distribution we design below, it will correspond to roughly one bit of
information, However, it is learned by many players. Because each message is sent to only one player,
and we are interested in the total amount of communication between the coordinator and the players, we
can separately charge each player that learns this bit of information, as this requires the coordinator to
communicate separately with each of them.
As we have seen, there is a protocol where the players learn nothing, but the coordinator learns a lot, and
there is a protocol where the coordinator learns very little, but the players learn a lot. We will show that this
trade-off is inherent, by bounding from below the sum of the information learned by the coordinator about
the players’ inputs and the information learned by each player from the coordinator (about the inputs of the
other players).
Designing a hard distribution. From the example above, we see that a hard distribution should make it
hard for the coordinator to find the players that have zeroes, forcing it to communicate with Ω(k) players
about each coordinate j ∈ [n]. This means that with reasonably large probability, in each coordinate j
there should only a few players that have Xji = 0. On the other hand, our distribution should have high
entropy, because, otherwise, the players can use Slepian-Wolf coding [45] to convey their joint input X to
the coordinator using roughly O(H(X)) bits. In order to balance these two concerns, we follow [5], and
use a mixture of product distributions.
Our hard distribution is a product η = ξ n , where ξ is a hard distribution for a single coordinate j ∈ [n].
Informally, ξ has two “modes”, selected by a “switch” Mj ∈ {0, 1}:
• An “easy” mode, Mj = 0, where each Xij = 0 with probability 1/2 independently.
• A “hard” mode, Mj = 1, where there is exactly one player i with Xij = 0, and the remaining players
ℓ 6= i have Xℓj = 1. The identity of the player that receives a zero is a random variable Z ∈U [k].
More formally, for each j ∈ [n], there is an independent distribution ξ over triples (Xj , Mj , Zj ), where
Xj ∈ {0, 1}k , Mj ∈ {0, 1}, and Zj ∈ [k], such that the components X1j , . . . , Xkj of Xj are independent
given Mj and Zj . Each player i is given the input Xi1 , . . . , Xin .
It may seem surprising that, under our distribution T
η, the answer to Set Disjointness is almost always
“yes”: The probability that we get some coordinate j ∈ ni=1 Xi is roughly n/2k , which is negligible when
n is significantly larger than 2k . This is necessary for our direct sum theorem (see below). However, it might
seem to make η an easy distribution, rather than a hard one. The key to η’s hardness lies in the fact that the
protocol must succeed with high probability on any input, even inputs that are very unlikely under η. This
means that for hard coordinates, the protocol must “convince itself” that there really is some player that had
a zero. This is hard because it is difficult to find such a player.
6

Ruling out Slepian-Wolf coding. As observed in [40] and as mentioned above, any lower bound for Set
Disjointness (or in the case of [40], bitwise-OR and other bitwise functions) must implicitly rule out an
approach where the players use Slepian-Wolf or other clever coding techniques to convey their inputs to the
coordinator efficiently. Our lower bound does this quite explicitly.
Under the distribution η = ξ n , we think of the players as jointly “owning” the input X, because they
are the only ones that initially know it. On the other hand, we think of the coordinator as “owning” the
switches, M = M1 , . . . , Mn : the coordinator can easily determine if a given coordinate is “easy” or “hard”
by sampling O(log n) players’ inputs—if it finds no zeroes, it can conclude that the coordinate is “hard”
with very high probability (in n). Since we are aiming for an Ω(nk) lower bound and the coordinator can
determine M using O(n log n) bits, we may as well give this information to the coordinator for free.
Given that a coordinate j is hard, its entropy is only 1/k. If the coordinator could convey the set of hard
coordinates (or enough information about this set) to the players, they could then use Slepian-Wolf coding
to send this part of the input to the coordinator in roughly O(n) total bits (one bit per hard coordinate).
However, the entropy of the set of hard coordinates is n/2, so conveying it (or sufficient information about
it) to the players requires the coordinator to send Ω(n) bits to each player, for a total of Ω(nk) bits. In the
absence of this information, the overall entropy of the input is Ω(nk), ruling out this type of approach.
We will formalize this intuition by showing that any protocol for Set Disjointness is “bad” in one (or
both) of the following ways.
(1) The players convey to the coordinator “useless” information about their inputs: in the easy case when
Mj = 0, the coordinator learns Ω(k) bits about coordinate j, X1j , . . . , Xkj . This information is “useless”
for the coordinator because when Mj = 0 it can safely ignore coordinate j: with overwhelming high
probability the sets do not intersect there.
One example of this approach is the naive protocol where players send their entire input to the coordinator.
(2) If the players do not convey to the coordinator a lot of information when M = 0, then we will show that
the coordinator conveys to the players “useless” information about the set of hard coordinates: Ω(k)
players must learn whether coordinate j is easy (more formally, they learn Ω(1) bits of information
about coordinate j) even when their input is Xij = 1, i.e., they are not the special player that the
coordinator is searching for.
An example of this approach is the protocol where the coordinator first samples a few inputs to determine
which coordinates are hard, then sends the set of hard coordinates to all the players; each player responds
by sending the coordinator a list of the hard coordinates where its input is zero.
In our lower bound proof, we explicitly bound from below the sum of the information costs described above.

3 Preliminaries
Notation. We use boldface letters to denote random variables, and capital letters to denote vectors or sets.
For a set A ⊆ [k], we let ēA denote the complement of A’s characteristic vector; that is, ēA has 1 in exactly
those coordinates that are not elements of A. For convenience we drop the curly brackets, so that, for
example, ēi,j = ē{i,j} .
If X ∈ {0, 1}k·n is a k-tuple of n-bit inputs, then X i ∈ {0, 1}n denotes the input to the i-th player, and
i
Xj ∈ {0, 1} denotes the j-th coordinate of X i . For an n-tuple Y ∈ {0, 1}n , we use
Y−i = Y1 , . . . , Yi−1 , Yi+1 , . . . , Yn
7

to denote the tuple obtained from Y by dropping the i-th coordinate. We also let Y[i,j] := Yi , . . . , Yj . Finally,
embed(X, i, x) denotes the vector obtained from X by inserting x in coordinate i: embed(X, i, x) =
(X 1 , . . . , X i−1 , x, X i , . . . , X m ) where |m| = |X|.
Models of computation. As mentioned in the Introduction, we will work in the asynchronous coordinator
message passing model introduced in [18]. In this model, there is one additional participant, called the
coordinator, which receives no input, and there is a private channel between every player and the coordinator.
However, there are no channels between the players, so they cannot communicate directly with one another.
The coordinator also has a private source of randomness. On each channel, the messages alternate between
the coordinator and the player. Messages are required to be self-delimiting, so both the coordinator and the
player know when one message (from coordinator to the player or vice-versa) has been completely sent.
Each player i knows whether or not it is his/her turn to speak by looking at the transcript Πi between player
i and the coordinator. If the last message sent in this transcript was from the coordinator, then it is player
i’s turn to speak. The coordinator can communicate whenever he is no longer waiting for anyone to speak.
This happens when in each transcript Πj , j ≤ k, the last message sent in this transcript was from the player.
When it is the coordinator’s turn to speak, he can send messages to as many players as he wishes. At the end
of a protocol, the coordinator outputs the answer. Our complexity measure is the total number of bits sent
on all channels. Since our complexity measure is the total number of bits, we can assume without loss of
generality that the model is sequential and round based: in the first round, the coordinator speaks to exactly
one player, and in the next round, this player responds, and so on.
For any protocol Π and any input X ∈ {0, 1}k·n , we let Π(X) denote the distribution of Π’s transcript
(as seen by the coordinator) when run with input X, and, for each player i ∈ [k], we let Πi (X) denote the
transcript of messages sent between player i and the coordinator (in both directions).
Communication complexity.

Let Π be a protocol for solving a problem P. The error of Π is given by
max Pr [player 1 outputs an incorrect answer] ,
X

where the probability is taken over the private randomness of the coordinator and the players.
The communication complexity of a protocol Π is the maximum over all inputs X of the maximum
number of bits exchanged between the players and the coordinators when Π is executed with input X. The
δ-error randomized communication complexity of a problem P in the coordinator model, which we denote
by CCδ (P), is the minimum communication complexity of any randomized protocol Π that solves P with
error at most δ.
Useful classes of distributions. Let us define the class of distributions we use for our direct sum theorem
and the lower bound for 1-bit AND. Fix an input domain X = X1 × . . . × Xk , and let X = (X 1 , . . . , X k ) be
a random variable denoting the input. Our hard distribution uses an auxiliary “switch” M, which determines
if a coordinate is hard or easy, and another auxiliary variable Z, which selects the player that receives zero
in the hard case. Conditioned on M and Z, the players’ inputs are independent from each other. The value
of M is assumed known to the coordinator, but the value of Z is hidden from all participants.
The following definition captures distributions that behave like our hard distribution. It is a special case
of a mixture of product distributions [5].
Definition 1 (Switched distributions). We say that the joint distribution η of (X, M, Z) is switched by M
and Z if X1 , . . . , Xk are conditionally independent given M and Z, and M is independent from Z.
Our hard distribution for a single coordinate also has the property that with very high probability, it
produces a Set Disjointness instance on which the answer is “yes”. This is important for our direct sum
8

reduction. Adapting the definition of a collapsing distribution from [5], we capture this notion as follows.
(The following definition is specifically for 1-bit AND; it is easy to generalize to arbitrary functions along
the same lines as [5].)
Definition 2 (ǫ-collapsing distributions). We say that a distribution µ : {0, 1}k → [0, 1] is ǫ-collapsing for
AND if
#
" k
^
Xk = 1 ≤ ǫ.
Pr
X∼µ

i=1

Information theory and Hellinger distance. Let µ be a distribution on a finite set D and let X, Y, Z be
random variables. The entropy of X is defined by
H(X) =

X

µ(ω) log

ω∈D

1
µ(ω)

The conditional entropy of X given Y is
H(X|Y ) =

X

H(X|Y = y)P r[Y = y],

y

where H(X|Y = y) is the entropy of the conditional distribution of X given the event {Y = y}.
The joint entropy of X and Y is the entropy of their joint distribution and is denoted by H(X, Y ).
The mutual information between X and Y is
I(X; Y ) = H(X) − H(X|Y ) = H(Y ) − H(Y |X).
The conditional mutual information between X and Y conditioned on X is
I(X; Y |Z) = H(X|Z) − H(X|Y, Z).
The Hellinger distance between probability distributions P and Q on a domain D is defined by
sX p
p
1
| P (ω) − Q(ω)|2 .
h(P, Q) = √
2 ω∈D
The square of the Hellinger distance is:
h2 (P, Q) = 1 −

Xp

P (ω)Q(ω).

ω∈D

Hellinger distance is a metric and, in particular, it satisfies the triangle inequality. Another useful property
of the Hellinger distance is the following:
Lemma 3.1 ([5]). Let P be a problem, and let Π be a√δ-error protocol for P. If X and Y are inputs such
that P(X) 6= P(Y ), then h(Π(X), Π(Y )) ≥ (1 − δ)/ 2.
Essentially, the lemma asserts that since the protocol must distinguish between the two inputs X and Y ,
the Hellinger distance of the respective distributions on the transcript must be large.
The following facts will be useful to us in the sequel:
9

Fact 3.2 (Chain rule for mutual information [16]). For any A1 , . . . , An , B and C we have
I(A1 . . . An ; B | C) =

n
X
i=1

I(Ai ; B | A1 . . . Ai−1 C).

(1)

Lemma 3.3 (“Simplified chain rule”). If A and B are independent given D, then I(A; BC|D) = I(A; C|B, D).
Proof. By the chain rule, I(A; BC | D) = I(A; B | D) + I(A; C | B, D). Since A and B are independent
conditioned on D, we have I(A; B | D) = 0, and the claim follows.
Lemma 3.4 ([10]). If A, B are independent given D, then I(A; C | B, D) ≥ I(A; C | D).
Lemma 3.5 ([5]). Let µ0 , µ1 be two distributions. Suppose that Y is generated as follows: we first select
S ∈U {0, 1}, and then sample Y from µS . Then I(S; Y) ≥ h2 (µ0 , µ1 ).
Information cost.

In general, we define the internal information cost of a protocol as follows.

Definition 3. Let X ∼ ζ be a distribution. The internal information cost of a protocol Π with k parties
communicating through a coordinator with respect to ζ is given by

X
−i
i
i
IC(Π) := I (X; Π(X)) +
I (X ; Π (X) | X ) .
ζ

X∼ζ

i∈[k]

X∼ζ

If P is a problem (formally, a Boolean predicate on k × n-bit inputs and outputs from some domain), then
we define the information complexity of P as
IC(P) = inf IC(Π)
ζ,δ

Π

ζ

where the infimum is taken over all δ-error randomized protocols for P.
This is a general definition which does not depend on the structure of the distribution ζ. However,
our lower bound uses a switched distribution, and as we explained in Section 2, we give a bound on the
following, more fine-grained expression:
Definition 4. Let (X, M, Z) ∼ η be a distribution switched by M and Z. The switched information cost of
a protocol Π with respect to µ is given by

X
i
i
i
i
SIC(Π) :=
I
(X ; Π (X) | M, Z) +
I
(M; Π (X) | X , Z) .
η

i∈[k]

(X,M,Z)∼η

(X,M,Z)∼η

The switched information cost of a problem P is defined analogously.
In Sections 4 and 5 we show that the switched information cost of D ISJ n,k under our hard distribution is
Ω(nk). In Section 6 we use this fact to show that the internal information cost of D ISJ n,k is also Ω(nk).
To obtain a lower bound on the communication cost of a problem P, it is sufficient to give a lower bound
on its internal information cost (or similarly, on its switched information cost):
Lemma 3.6. For any problem P, CCδ (P) ≥ 1/2 · ICζ,δ (P).
10

Proof. For any δ-error protool Π,
IC(Π) = I (X; Π(X)) +
ζ

X∼ζ

≤ H(Π) +
≤ H(Π) +

X

i∈[k]

X

i∈[k]

X

i∈[k]


I (X ; Π (X) | X )
−i

i

i

X∼ζ

H(Πi | Xi )
H(Πi ) ≤ |Π| +

X

i∈[k]

|Πi | = 2|Π|.

The claim follows.
Problem statements. In the Set Disjointness problem, D ISJ n,k , each player receives an input X i ∈
{0, 1}n , and the goal is to compute
1

k

D ISJ n,k (X , . . . , X ) =

k
n ^
_

Xji .

j=1 i=1

We also consider the Task Allocation Problem, TASK A LLOC n,k . Here we think of the elements {1, . . . , n}
as tasks that need to be performed. Each player receives an input X i ⊆ [n] representing the set of tasks it is
able to perform, and the coordinator must output an assignment Y : [n] → [k], such that for each j ∈ [n],
j ∈ X Y (j) ; that is, every task is assigned to a player that had that task in its input.

4 Direct Sum Theorem
We begin by proving that the information cost of computing the set disjointness function
1

k

D ISJ n,k (X , . . . , X ) =

k
n ^
_

Xij

j=1 i=1

V
is as least n times the cost of solving the one-bit problem A NDk = ki=1 Xij . The proof is by reduction:
given a protocol Π for D ISJ n,k and a switched distribution η = ξ n , where ξ itself is a switched and ǫcollapsing distribution, we will construct a protocol Π̂ for A NDk , such that SICξ (Π̂) ≤ (1/n) SICη (Π).
The one-bit protocol Π̂ uses Π by constructing an n-bit input, running Π on it, and returning Π’s answer.
However, the input to Π̂ is only a single bit per player. To construct an n-bit input, the coordinator first
selects a random coordinate j ∈U [n], into which the one-bit input to Π̂ will be embedded. Next we wish to
randomly sample the other coordinates [n]\{j} from ξ n−1 , in order to obtain an n-bit input on which we can
run Π. We must do this carefully: we need Π̂ to have an information cost proportionate to the information
cost of Π, but we do not know where Π incurs the majority of its information cost—does the coordinator
learn a lot about the inputs given the switch M, or do the players learn a lot about the switch M given their
inputs? One of these terms may be small, and we must ensure that Π̂’s corresponding cost in the same term
is also small.
• If in Π the coordinator does not learn much about the input given M and Z, then our new protocol
Π̂ should also not reveal too much about the input to the coordinator. A good solution is to have the
coordinator sample M−j and Z−j and send them to the players, who can then sample their inputs
independently using their private randomness.
11

• If in Π the players do not learn much about M given their inputs and Z, then we should not reveal M
to the players in Π̂. A good solution is to have the coordinator sample M−j , Z−j and X−j , and send
to each player i its input X−j
i . Thus the players do not know M before they execute Π (except what
they can deduce from their inputs).
Since we do not know in advance how Π behaves on the average coordinate, our solution is to “hedge our
bets” by using the first approach to sample the coordinates below j, and the second approach to sample the
coordinates above j. More formally, on one-bit input (U, N, S) ∼ ξ, protocol Π̂ works as follows:
1. The coordinator samples a random coordinate j ∈U [n] and samples Z−j ∈U [k]n−1 , and sends them
to all players.
2. For each ℓ < j, the coordinator samples Mℓ and sends it to all players. Each player i then samples
Xiℓ from its marginal distribution given Mℓ and Zℓ .
3. For each ℓ > j, the coordinator samples Xℓ , Mℓ from their marginal distribution given Zℓ , and sends
to each player i its input Xiℓ .
4. The participants simulate the execution of Π using the joint input

embed(X, j, U) = (Xi1 , . . . , Xij−1 , Ui , Xij+1 , . . . , Xin

k
.
i=1

5. The coordinator outputs the value output by Π.

The last step is the reason
we require ξ to be ǫ-collapsing: for each coordinate
W ℓV6= j, with probability at
V
least 1 − ǫ we have ki=1 Xiℓ = 0. By union bound, the probability that ℓ6=j ki=1 Xiℓ = 0 is at least
1 − (n − 1)ǫ. Whenever this occurs we have D ISJ n,k (embed(X, j, U)) = A NDk (U), that is, if Π succeeds
then Π̂ succeeds as well. Therefore the error probability of Π̂ is at most nǫ + δ, where δ is the error
probability of Π.
The following lemma relates the information cost of Π̂ to that of Π:
Lemma 4.1. For each player i ∈ [k] we have

 1
I
(M; Πi (X) | Xi , Z)
N; Π̂i (U) | Ui , S ≤
n (X,M,Z)∼η
(U,N,S)∼ξ


 1
i
i
i
i
I
U ; Π̂ (U) | N, S ≤
I
(X ; Π (X) | M, Z) .
n (X,M,Z)∼η
(U,N,S)∼ξ
I



and

Proof. We begin with the first inequality. For each player i, the player’s view of the transcript of Π̂ is given
by
Π̂i (U) = j, Z−j , M[1,j−1] , Xi[j+1,n] , Π(embed(X, j, U)).
By Lemma 3.3, since the tuple hj, Z−j , M[1,j−1] , Xi[j+1,n] i is independent from N conditioned on Ui and S

12

(or even without the conditioning), we can write


I
N; Π̂i (U) | Ui , S
(U,N,S)∼ξ


N; j, Z−j , M[1,j−1] , Xi[j+1,n] , Πi (embed(X−j , j, U)) | Ui , S
=
I
(U,N,S)∼ξ
(X−j ,M−j ,Z−j )∼ξ n−1

=
=

I

(U,N,S)∼ξ
(X−j ,M−j ,Z−j )∼ξ n−1

I

(X,M,Z)∼η





N; Πi (embed(X−j , j, U)) | j, M[1,j−1] , Xi[j+1,n] , Ui , Z−j , S


Mj ; Πi (X) | j, M[1,j−1] , Xi[j,n] , Z .

(2)

Next, since Xi[1,j−1] and Mj (which we previously called N) are independent, even given the conditioning
in (2), we can apply Lemma 3.4 to add conditioning on Xi[1,j−1] , yielding


I
N; Π̂i (U) | Ui , S
(U,N,S)∼ξ

Mj ; Πi (X) | j, M[1,j−1] , Xi , Z
≤
I
=

(X,M,Z)∼η
n
X

1
n

j=1

I

(X,M,Z)∼η


1
Mj ; Πi (X) | M[1,j−1] , Xi , Z =
I
(M; Πi (X) | Xi , Z).
n (X,M,Z)∼η

The last step uses the chain rule.
Now let us prove the second inequality, which is quite similar. We begin as before: by Lemma 3.3, since
the tuple hj, Z−j , M[1,j−1] , Xi[j+1,n] i is independent from Ui conditioned on N and S,


I
Ui ; Π̂i (U) | N, S
(U,N,S)∼ξ


Ui ; j, Z−j , M[1,j−1] , Xi[j+1,n] , Πi (embed(X−j , j, U)) | N, S
=
I
(U,N,S)∼ξ
(X−j ,M−j ,Z−j )∼ξ n−1

=
=

I

(U,N,S)∼ξ
(X−j ,M−j ,Z−j )∼ξ n−1

I

(X,M,Z)∼η





Ui ; Πi (embed(X−j , j, U)) | j, M[1,j−1] , N, Xi[j+1,n] , Z−j , S


Xij ; Πi (X) | j, M[1,j] , Xi[j+1,n] , Z .

(3)

Next, since M[j+1,n] and Xij (previously called Ui ) are independent given the conditioning in (3), we can
apply Lemma 3.4 to add conditioning on M[j+1,n] , yielding


N; Π̂i (U) | Ui S
I
(U,N,S)∼ξ


≤
I
Xij ; Πi (X) | j, M, Xi[j+1,n] , Z
=

(X,M,Z)∼η
n
X

1
n

j=1


 1
Xij ; Πi (X) | M, Xi[j+1,n] , Z =
I
(Xi ; Πi (X) | M, Z).
n (X,M,Z)∼η
(X,M,Z)∼η
I

13

The direct sum theorem follows immediately from Lemma 4.1:
Theorem 4.2. Let ξ be an ǫ-collapsing distribution switched by M and Z, where ǫ < (1 − δ)/n, and let
η = ξ n . Then
SIC(D ISJ n,k ) ≥ n · SIC (A NDk ).
η,δ

ξ,δ+nǫ

5 The Information Complexity of One-Bit AND
By Theorem 4.2, in order to obtain an Ω(nk) lower bound on D ISJ n,k it is sufficient to show a lower bound
of Ω(k) on the information complexity of A NDk under a hard one-bit distribution ξ, which is both switched
and ǫ-collapsing. We will use the following distribution on (X, M, Z) (informally described in Section 2):
• First we select Z ∈U [k] and, independently, the mode M is selected with Pr[M = 0] = 2/3 and
Pr[M = 1] = 1/3.
• If M = 0, then each player’s input Xi is 0 or 1 with equal probability, independent of the other inputs.
If M = 1, then the joint input is ēZ := 1Z−1 01k−Z .
The distribution is switched by M and Z, and is ǫ-collapsing with ǫ = 1/(3 · 2k−1 ).

Notation. In this section we let Π(X) denote the distribution of the protocol’s transcript when executed
on input X ∈ {0, 1}k , and similarly, Πi (X) denotes the distribution of player i’s view of the transcript. We
also let Πi [x, m, z] denote the distribution of player i’s view when the input is drawn from ξ, conditioned
on Xi = x, M = m and Z = z. For example,
if j 6= i, then Πi [1, 1, j] = Π(ēj ). Notice that Πi [0, 1, j] for
 i
i 6= j is not well-defined, because Pr X = 0, M = 1, Z 6= i = 0. Similarly, we let Π[i, x, m, z] denote
the distribution of Π’s transcript, conditioned on Xi = x, M = m and Z = z. Finally, given a sequence
i1 , . . . , iℓ ∈ [k], we use ēi1 ,...,iℓ to denote the input in which players i1 , . . . , iℓ receive zero, and all other
players receive one.

5.1 Structural Properties of Protocols in the Coordinator Model
We prove that SICξ,δ (A ND k ) = Ω(k) in several steps. The distribution ξ comes in only when we relate
Hellinger distance to mutual information; for the most part we rely on the fact that Π has error at most δ on
any input, and on the structural properties of Π. We begin by outlining these properties.
The basic structural property on which we rely is rectangularity, introduced in [5] for the two-player
setting and the multi-player model with communication by shared blackboard. Rectangularity asserts, informally speaking, that if we partition the players into sets A1 , . . . , Am ⊆ [k], the protocol’s probability
distribution over transcripts can be decomposed into a product of functions f1 , . . . , fm , such that each fi
depends only in the inputs to players in Ai . Here we require only a simple version where we use two sets,
A1 = {i} and A2 = [k] \ {i} for some player i ∈ [k]. The lemma follows by reduction from two-player
rectangularity [5], but for the sake of completeness we include a proof.
Lemma 5.1 (One-player rectangularity for the coordinator model). Let Π be a k-player private-coin protocol in the coordinator model, with inputs from X = X 1 × . . . × X k . For i ∈ [k], let T i denote the set of
possible transcripts observed by player i, so any transcript of Π is in T 1 × · · · × T k . Then, for all i ∈ [k],
there exist mappings q i : X i × T i → [0, 1], q −i : X −i × T i → [0, 1] and p−i : X −i × T → [0, 1] such that
for any input X ∈ X and any transcript τ = (τ 1 , . . . , τ k ) ∈ T 1 × · · · × T k ,


Pr Πi (X) = τ i = q i (X i , τ i ) · q −i (X −i , τ i ) and
Pr [Π(X) = τ ] = q i (X i , τ i ) · p−i (X −i , τ ).
14

i
Proof. For any player i and any transcript τ i ∈ T i , let A(τ i ) = {(X, R) | ΠR
i (X) = τ } denote the set of
i
R
inputs and random coin tosses such that τ is the transcript Πi (X) of the communication between player i
and the coordinator in the deterministic protocol ΠR obtained from Π by fixing the outcome of the random
coin tosses to R. Also, let Ai (τ i ) = {(X i , Ri ) |(X, R) ∈ A(τ i )} and A−i (τ i ) = {(X −i , R−i ) |(X, R) ∈
i
A(τ i )}. Then, by the rectangular property for deterministic 2-player protocols, for all (X, R), ΠR
i (X) = τ
i
i
i
i
−i
−i
−i
i
if and only if (X , R ) ∈ A (τ ) and (X , R ) ∈ A (τ ).
For any X i ∈ X i , any X −i ∈ X −i , and any τ i ∈ T i , define


q i (X i , τ i ) = Pr (X i , Ri ) ∈ Ai (τ i ) and
Ri


−i
−i i
q (X , τ ) = Pr (X −i , R−i ) ∈ A−i (τ i ) .
R−i

On any input X, player i chooses Ri uniformly and the other players choose R−i independently and uniformly. Therefore,


Pr Πi (X) = τ i


i
= Pr ΠR
i (X) = τ
R




= Pr (X i , Ri ) ∈ Ai (τ i ) · Pr (X −i , R−i ) ∈ A−i (τ i )
Ri
i

R−i

i

i

−i

−i

i

= q (X , τ ) · q (X , τ ).

For any transcript τ ∈ T , let B(τ ) = {(X, R) | ΠR (X) = τ } denote the set of inputs and random
coin tosses such that τ is the transcript ΠR (X) of all communication (to and from the coordinator) in the
deterministic protocol ΠR obtained from Π by fixing the outcome of the random coin tosses to R. Let
B −i (τ ) = {(X −i , R−i ) |(X, R) ∈ B(τ )}. By the rectangular property for deterministic protocols, for all
(X, R), ΠR (X) = τ if and only if (X i , Ri ) ∈ Ai (τ i ) and (X −i , R−i ) ∈ B −i (τ ).
For any X −i ∈ X −i and any τ ∈ T , define


p−i (X −i , τ ) = Pr (X −i , R−i ) ∈ B −i (τ ) .
R−i

On any input X, player i chooses Ri uniformly and the other players choose R−i independently and uniformly. Therefore,
Pr [Π(X) = τ ]


= Pr ΠR (X) = τ
R




= Pr (X i , Ri ) ∈ Ai (τ i ) · Pr (X −i , R−i ) ∈ B −i (τ )
Ri
i

R−i

i

i

−i

−i

= q (X , τ ) · p (X , τ ).

For convenience, when we apply Lemma 5.1, we sometimes write
Pr [Π(X) = τ ] = pi (X i , τ ) · p−i (X −i , τ ),
where pi (X i , τ ) = q i (X i , τ i ).
Rectangularity, in turn, implies the Z-Lemma (or Pythagorean Lemma) of [5]. Here we use a simplified
version (which omits one of the terms on the right-hand side):
15

Lemma 5.2 (Diagonal Lemma). For any X, Y ∈ X and ℓ ∈ [k] we have

1
h2 (Π(X), Π(Y ))) ≥ h2 (Π(X), Π(embed(Y−ℓ , ℓ, Xℓ ))).
2

Under our distribution ξ, the inputs Xi are independent given M and Z. This allows us to prove the
following variant of the rectangular property, which, informally speaking, “abstracts away” all the inputs
X−i by grouping them together under the conditioning M = m, Z = z (for some m and z).
Lemma 5.3 (Conditional rectangularity for M and Xi under ξ). Let Π be a k-player private-coin protocol
for A NDk . For i ∈ [k], let T i denote the set of possible transcripts observed by player i. Then there exists a
function c : {0, 1}×[k]×T → [0, 1] and, for all i ∈ [k], there exists a function ci : {0, 1}×[k]×T i → [0, 1]
such that for any x ∈ X i , m ∈ {0, 1}, z ∈ [k] \ {i}, τ ∈ T , and τ i ∈ T i ,
Pr[Π(X) = τ | Xi = x, M = m, Z = z] = pi (x, τ ) · c(d, z, τ ) and

Pr[Πi (X) = τ i | Xi = x, M = m, Z = z] = q i (x, τ i ) · ci (d, z, τ i ),

where pi (x, τ ) = q i (x, τ i ) is the function from Lemma 5.1. Here the probability is over the protocol’s own
randomness as well as the input X drawn from ξ with the stated conditioning.
Proof. By Lemma 5.1 there exist functions q i and q −i such that, for any input X ∈ X ,


Pr Πi (X) = τ i = q i (X i , τ i ) · q −i (X −i , τ i ).

Therefore we can write


Pr Πi (X) = τ i | M = m, Z = z, Xi = x
X


q i (X i , τ i ) · q −i (X −i , τ i ) · Pr X = X | M = m, Z = z, Xi = x
=
X∈X

= q i (x, τ i ) ·

X

X −i ∈X −i



q −i (X −i , τ i ) · Pr X−i = X −i | M = m, Z = z .

Here we use the fact that the inputs X1 , . . . , Xk are independent conditioned on M and Z. The second
claim follows by setting
X


ci (d, z, τ i ) =
q −i (X −i , τ i ) · Pr X−i = X −i | < = m, Z = z .
X −i ∈X −i

Similarly, Lemma 5.1 implies there exist functions pi and p−i such that, for any input X ∈ X ,
Pr [Π(X) = τ ] = pi (X i , τ ) · p−i (X −i , τ ),

so


Pr Π(X) = τ | M = m, Z = z, Xi = x
X


= pi (x, τ ) ·
p−i (X −i , τ ) · Pr X−i = X −i | M = m, Z = z
X −i ∈X −i

and the first claim follows by setting
X
c(d, z, τ ) =

X −i ∈X −i



p−i (X −i , τ ) · Pr X−i = X −i | M = m, Z = z .

16

Lemma 5.3 yields the following variant of the Diagonal Lemma (Lemma 5.2).
Lemma 5.4 (Diagonal Lemma for M and Xi ). For any i 6= z we have
h2 (Πi [0, 0, z], Πi [1, 1, z]) ≥

1 2 i
h (Π (ēi,z ), Πi (ēz )).
2

Proof. The proof closely follows the proof of the original Z-Lemma from [5], but we include it here for
completeness.
Recall that Πi [1, 1, z] = Πi (ēz ). By Lemmas 5.1 and 5.3, we can decompose the distributions from the
lemma statement as follows:


Pr Πi [0, 0, z] = τ i = q i (0, τ i ) · ci (0, z, τ i ),




Pr Πi [1, 1, z] = τ i = Pr Πi (ēz ) = τ i = q i (1, τ i ) · q −i ((ēz )−i , τ i ) = q i (1, τ i ) · ci (1, z, τ i ), and


Pr Πi (ēi,z ) = τ i = q i (0, τ i ) · q −i ((ēi,z )−i , τ i ) = q i (0, τ i ) · q −i ((ēz )−i , τ i ).
From the definition of Hellinger distance, it follows that
Xq
2
i
i
q i (0, τ i ) · ci (0, z, τ i ) · q i (1, τ i ) · ci (1, z, τ i )
1 − h (Π [0, 0, z], Π [1, 1, z]) =
τi

≤

Xq

q i (0, τ i )q i (1, τ i )

τi

1X
=
2 i
τ

+

q

ci (0, z, τ i ) + ci (1, z, τ i )
2



q i (0, τ i )ci (0, z, τ i )q i (1, τ i )ci (0, z, τ i )

1X
2 i
τ
2



q

q i (0, τ i )q −i ((ēz )−i, τ i )q i (1, τ i )q −i ((ēz )−i , τ i )



= 1 − h (Πi [0, 0, z], Πi [1, 0, z]) /2 + 1 − h2 (Πi (ēi,z ), Πi (ēz ) /2

= 1 − h2 (Πi [0, 0, z], Πi [1, 0, z]) + h2 (Πi (ēi,z ), Πi (ēz ) /2
≤ 1 − h2 (Πi (ēi,z ), Πi (ēz ))/2.

Note that Lemma 5.2 concerns the complete transcript Π, while Lemma 5.4 concerns one player’s local
view, Πi . To move between the two we use the following “localization” lemma, which shows that when we
“keep everything the same” and change only Xi , the distance between the transcript’s distributions is caused
entirely by player i’s local view. What does it mean to “keep everything the same except Xi ”? One option
is to fix M = m and a specific value Z = z 6= i, and let Xi change from 0 to 1. This is well-defined only
in the case where m = 0, because when M = 1 and Z 6= i, we must have Xi = 1. The other option is to
fix a specific input X−i = X −i for the rest of the players and let Xi change from 0 to 1. We are particularly
interested in the case where all players receive 1, except for one player, z 6= i, and possibly player i itself.
Lemma 5.5 (Localizing the distance to a single player’s transcript). For any i 6= z we have
h(Π[i, 0, 0, z], Π[i, 1, 0, z]) = h(Πi [0, 0, z], Πi [1, 0, z]),

and similarly,
h(Π(ēi,z ), Π(ēz )) = h(Πi (ēi,z ), Πi (ēz )).
17

Proof. Given a complete transcript τ , let τ i denote player i’s part of the transcript. By Lemma 5.3,
Pr[Π(X) = τ | Xi = x, M = 0, Z = z] = pi (x, τ ) · c(0, z, τ ) and

Pr[Πi (X) = τ i | Xi = x, M = 0, Z = z] = q i (x, τ i ) · ci (0, z, τ i ).
Moreover,
Pr[Πi (X) = τ i | Xi = x, M = 0, Z = z] =

X

Pr[Π(X) = τ ′ | Xi = x, M = 0, Z = z],

X

c(d, z, τ ′ ).

τ ′ ∈T
τ ′i =τ i

so,
ci (d, z, τ i ) =

τ ′ ∈T
τ ′i =τ i

Therefore,
1 − h2 (Πi [0, 0, z], Πi [1, 0, z])
Xq
q i (0, τ i )ci (d, z, τ i )q i (1, τ i )ci (d, z, τ i )
=
τi

X q
=
q i (0, τ i )q i (1, τ i )
τi

=

X

τ ′ ∈T
τ ′i =τ i


c(d, z, τ ′ )

Xq
q i (0, τ i )q i (1, τ i )c(d, z, τ )
τ

Xq
=
q i (0, τ i )c(d, z, τ )q i (1, τ i )c(d, z, τ )
τ

= 1 − h2 (Π[i, 0, 0, z], Π[i, 1, 0, z]).

The other part of the lemma is similar: it is obtained by using Lemma 5.1 instead of Lemma 5.3 and
replacing c, ci with q −i , p−i (respectively).
Now we are ready to describe the main proof that the information complexity of A NDk is Ω(k).

5.2 Step I: setting up a rectangle.
Fix a player i and a value z 6= i, and consider the following four distributions:
Πi [0, 0, z]

Πi [1, 0, z]

Πi (ēi,z )

Πi (ēz ) = Πi [1, 1, z]

The two distributions in the top row differ only in the value of Xi , which is 0 for the first column and 1 for
the second; the same holds for the bottom row. The top-row distributions have M = 0, and it is helpful to
think of the bottom row as representing the hard case, M = 1 (although Πi [0, 1, z] is not well-defined, and
moreover, the input ēi,z has probability 0 under ξ).

18

Notice that our distribution ξ has the following nice property:




Pr Xi = 0 | M = 0, Z = z = Pr Xi = 1 | M = 0, Z = z = 1/2,




Pr M = 0 | Xi = 1, Z = z = Pr M = 1 | Xi = 1, Z = z = 1/2.

and

In other words, given that we are in the top row of the rectangle (M = 0, Z = z), the distribution of the
transcript Πi is equally likely to be Πi [0, 0, z] or Πi [1, 0, z], the two top-row distributions. This means that
if the two top-row distributions have a large Hellinger distance, then the conditional mutual information
I(Xi ; Πi | M = 0, Z = z) is large: although Xi is equally likely to be 0 or 1 a priori given M = 0, Z = z,
because of the large Hellinger distance, the transcript Πi allows us to distinguish the case Xi = 0 from the
case Xi = 1. This is captured by Lemma 3.5, which yields
I(M; Πi | Xi = 1, Z = z) ≥ h(Πi [1, 0, z], Πi [1, 1, z]).
Similarly, given that we are in the rightmost column (Xi = 1, Z = z), the distribution of Πi is equally
likely to be Πi [1, 0, z] or Πi [1, 1, z]. Therefore a large Hellinger distance between these distributions implies
that I(M; Πi | Xi = 1, Z = z) is large: Lemma 3.5 again yields
I(Xi ; Πi | M = 0, Z = z) ≥ h(Πi [0, 0, z], Πi [1, 0, z]).
Recall that
and observe that when z 6= i
 Pr [M = 0 | Z = z] = 2/3 (as M and Z are independent),

we have Pr Xi = 1 | Z = z = 2/3. Therefore I Xi ; Πi | M, Z = z ≥ (2/3) I Xi ; Πi | M = 0, Z = z
and I M; Πi | Xi , Z = z ≥ (2/3) I M; Πi | Xi = 1, Z = z . It follows that


2 2 i
h (Π [1, 0, z], Πi [1, 1, z]) + h2 (Πi [0, 0, z], Πi [1, 0, z])
3
2
h(Πi [1, 0, z], Πi [1, 1, z]) + h(Πi [0, 0, z], Πi [1, 0, z])
≥
3
h2 (Πi [0, 0, z], Πi [1, 1, z])
.
≥
3
The last step uses the triangle inequality. Now we apply Lemma 5.4, which together with the above yields

I(M; Πi | Xi , Z = z) + I(Xi ; Πi | M, Z = z) ≥

I(M; Πi | Xi , Z = z) + I(Xi ; Πi | M, Z = z) ≥

h2 (Πi (ēi,z ), Πi (ēz ))
.
3

(4)

This holds only for z 6= i. Taking the expectation over all z ∈ [k], we obtain

1X
I(M; Πi | Xi , Z) + I(Xi ; Πi | M, Z) ≥
I(M; Πi | Xi , Z = z) + I(Xi ; Πi | M, Z = z)
k
z6=i

(4)

≥


 1


k−1
E h2 (Πi (ēi,Z , Πi (ēZ )) ≥
E h2 (Πi (ēi,Z , Πi (ēZ )) .
3k Z6=i
6 Z6=i

(5)

The last step uses the fact that k − 1 ≥ k/2, as k > 1.


Let us define the usefulness of player i to be γi := EZ6=i h2 (Πi (ēi,Z , Πi (ēZ )) . Roughly speaking,
player i’s usefulness corresponds to how sensitive the protocol is to the fact that Xi = 0, when some other
player z 6= i also P
has 0. By (5) we see that
P in order to obtain our desired Ω(k) lower bound, it is sufficient
to bound the sum i γi (or the average, i γi /k). But why should γi be large on average? In other words,
why should the protocol distinguish the case where only one player has zero from the case where two players
have zero, when the answer to A NDk is 0 in both cases? This will again follow from the structural properties
of the protocol.
19

5.3 Step II: bounding the average usefulness.
In order to show that the average player has a large usefulness γi , consider any two players i 6= j, and the
following four distributions:
Π(1k )
Π(ēj )

Π(ēi )
Π(ēi,j )

We have A NDk (ēi ) = A NDk (ēj ) = 0, but A NDk (1k ) = 1. By the correctness of the protocol and
Lemma 3.1, the statistical √
distance between Π(ēi ) and Π(1k ) must be at least 1 − δ, which implies that
√
h(Π(ēi ), Π(1k )) ≥ (1−δ)/ 2. By the diagonal lemma (with ℓ = j), h(Π(ēi ), Π(ēj )) ≥ h(Π(ēi ), Π(1k ))/ 2 ≥
(1 − δ)/2, that is, the protocol must distinguish ēi from ēj . (Roughly speaking, this means that the protocol
must find a player that has zero in the case where M = 1, an interesting fact in itself.) By the triangle
inequality,
h(Π(ēi ), Π(ēi,j )) + h(Π(ēj ), Π(ēi,j )) ≥ h(Π(ēi ), Π(ēj )) ≥ (1 − δ)/2,
and therefore
(h(Π(ēi ), Π(ēi,j )) + h(Π(ēj ), Π(ēi,j )))2
(1 − δ)2
≥
.
2
8
P P
Now summing across all players i 6= j, we see that 2 i j6=i h2 (Π(ēi ), Π(ēi,j )) ≥ k(k − 1) · (1 − δ)2 /8,
P
which implies that i γi ≥ k · (1 − δ)2 /16 = Ω(k). Together with (5), this yields our main result for this
section:
h2 (Π(ēi ), Π(ēi,j )) + h2 (Π(ēj ), Π(ēi,j )) ≥

Theorem 5.6. For any k > 1, SICξ,δ (A ND k ) ≥ (1 − δ)2 /96.

Combining Theorem 5.6 with our direct-sum theorem from Section 4, we obtain
Theorem 5.7. For any n ≥ 1 and for k = Ω(log n), SICη,δ (D ISJ n,k ) = Ω(nk).

6 Internal Information Complexity and Communication Complexity of Set
Disjointness
Recall our definition of the internal information cost of a protocol from Section 3:

X
−i
i
i
ICζ (Π) := I (X; Π(X)) +
I (X ; Π (X) | X ) .
X∼ζ

i∈[k]

X∼ζ

We will now use Theorem 5.7 to show that the internal information complexity of set disjointness is Ω(nk).
In Theorem 5.7 we showed that for all protocols Π we have

X
i
i
i
i
SIC(Π) =
I
(X ; Π (X) | M, Z) +
I
(M; Π (X) | X , Z) = Ω(n · k).
η

i∈[k]

(X,M,Z)∼η

(X,M,Z)∼η

Let ζ be the distribution η restricted just to the input X (that is, ζ is the marginal distribution of X under η).
We will show:
Theorem 6.1. Let Π be a protocol in the coordinator model. Let η be a switched distribution and ζ be
the marginal distribution of X under η, as above. Namely, ζ is the marginal distribution of X where
(X, M, Z) ∼ η. Then,
ICζ (Π) > SIC(Π) − O(n log k).
η

20

Proof. We consider the two terms in each sum separately. We start with the term corresponding to the
amount of information learned by the coordinator. By the definition of η we have that I(Xi ; X[1..i−1] |M, Z) =
0 and thus by Lemma 3.4,
I(Xi ; Πi (X) | M, Z) ≤ I(Xi ; Πi (X) | M, Z, X[1..i−1] ).
Using the Chain Rule, we get:

X
i
i
I
(X ; Π (X) | M, Z) ≤
i∈[k]

X

(X,M,Z)∼η

i∈[k]

X

≤

i∈[k]

=
≤

i

I


(Xi ; Π(X) | M, Z, X[1..i−1] )

(X,M,Z)∼η

I

(X; Π(X) | M, Z)

I

(X, M, Z; Π(X))

I

(X; Π(X)) +

I

(X; Π(X)) + H(M, Z)

I

(X; Π(X)) + O(n log k)

≤

(X,M,Z)∼η

≤

(X,M,Z)∼η


)

(X ; Π (X) | M, Z, X

(X,M,Z)∼η

(X,M,Z)∼η

[1..i−1]

I

(X,M,Z)∼η

(X,M,Z)∼η

=

i

I

(X,M,Z)∼η

(M, Z; Π(X) | X)

Next, we consider the terms corresponding to what individual players learn. For each i ∈ [k] we have
I

(X,M,Z)∼η

I

(X−i ; Πi (X) | Xi , Z)

I

(X−i , Z; Πi (X) | Xi )

I

(X−i ; Πi (X) | Xi ) +

I

(X−i ; Πi (X) | Xi ) + H(Z) ≤

(M; Πi (X) | Xi , Z) ≤

(X,M,Z)∼η

≤

(X,M,Z)∼η

=
≤

(X,M,Z)∼η
(X,M,Z)∼η

I

(X,M,Z)∼η

(Z; Πi (X) | Xi , X−i )
I

(X,M,Z)∼η

(X−i ; Πi (X) | Xi ) + log k.

Putting these two calculations together we obtain that
SIC(Π) < ICζ (Π) + O(n log k),
η

and thus ICζ (Π) > SICη (Π) − O(n log k), completing the proof.
We are now ready to prove our main theorem:
Theorem 6.2. For any δ > 0, n ≥ 1 and for k = Ω(log n),
ICζ (D ISJ n,k ) = Ω(n · k)

and

CCδ (D ISJ n,k ) = Ω(n · k).

Proof. The first part of the theorem follows from Theorem 6.1 and Theorem 5.7. The second part follows
from the first part as well as the connection between communication complexity and information complexity
(Lemma 3.6).
21

7 Lower Bound for Task Allocation
In the task allocation problem, there are k players and n tasks. Each player i receives as input a set X i
which specifies a subset of tasks that it is capable of performing. The goal is for the players to partition the
tasks between them: each player i must output a subset of tasks such that each task is completed by exactly
one player. To make this problem feasible, we consider only inputs for which each tasks has at least one
player who is capable of performing it. Thus, task allocation is a promise problem. We require that, at the
end of the protocol, the coordinator knows which player is assigned to each task.
Task allocation is a distributed one-shot variant of the well-known k-server problem, where a centralized
online algortihm assigns tasks to k servers, minimizing the total cost of servicing all tasks. In the k-server
problem, each (server, task) pair is associated with a cost for having the server perform the task, and the
tasks arrive continually and must be assigned in an online manner. In the task allocation problem, all tasks
are given in the beginning, and all have a cost of either 1 or infinity. Partitioning the tasks between the
players corresponds to finding a minimum-weight assignment of tasks to servers. Task allocation is also
closely related to the problem of finding a rooted spanning tree in directed broadcast networks [19].
Drucker, Kuhn and Oshman [19] showed tight communication complexity lower bounds for the two
player task allocation problem. In this section, we generalize this lower bound to the k player setting by
showing an Ω(nk) lower bound for task allocation in the message passing model.
Our reduction is similar in spirit to the reduction, due to Noga Alon [3], from two-party set disjointness
to the promise task allocation problem in the two-player case.
Theorem 7.1. There is a reduction from k-party Set Disjointness to k-party (Promise) Task Allocation with
an overhead of O(n log n + k) bits. That is, given a task allocation protocol that communicates CTA (n, k)
bits, there is a protocol for set disjointness that communicates
CSD (n, k) = CTA (n, k) + O(n log n + k)
bits. Thus, for large enough n and large enough a, if k ≥ a log n, then the communication complexity of
Task Allocation in the coordinator model is Ω(nk).
Proof. We now give the reduction from multiplayer set disjointness to multiparty (promise) task allocation
in the coordinator model. Let the input to the set disjointness problem be X 1 , . . . , X k . Define Y i = [n]−X i .
As before, note that
∩ki=1 X i is empty if and only if
∪ki=1 Y i = [n]
The players simulate the protocol for task allocation on the inputs Y i , and the coordinator gets the
output (Z 1 , Z 2 , . . . , Z k ) where Z i is the set of tasks that player i is expected to complete.2 The protocol
then proceeds as follows:
1. The coordinator checks that the sets Z 1 , . . . , Z k form a partition of [n]. If not, the coordinator outputs
“not disjoint” and halts. If the check passes, proceed to the next step.
2. The coordinator sends Z i to player i. Each player i checks whether Z i ⊆ Y i . If Z i * Y i , player
i sends a “not disjoint” message to the coordinator (and if Z i ⊆ Y i , it sends an “OK” message.) If
the coordinator receives a “not disjoint” message from any player, it outputs “not disjoint” and halts.
Otherwise, it outputs “disjoint” and halts.
2
Our definition of the coordinator model postulates that the coordinator learns the result at the end of the protocol. A similar
reduction works in the case where the players learn their respective outputs, namely each player i learns Z i , the set of tasks that he
is expected to complete.

22

Assume that (X 1 , . . . , X k ) is a YES instance of set disjointness, namely that ∩ki=1 X i = ϕ. Then,
∪ki=1 Y i = [n], and the input (Y 1 , . . . , Y k ) satisfies the promise to the task allocation problem. By the
correctness of the task allocation protocol, the output (Z 1 , . . . , Z k ) is a valid allocation of the tasks, namely,
(Z 1 , . . . , Z k ) forms a partition of the universe [n], and Z i ⊆ Y i for each i ∈ [k]. Thus, the coordinator will
output “disjoint” in the above protocol.
On the other hand, if (X 1 , . . . , X k ) is a NO instance of set disjointness, then we know that ∪ki=1 Y i 6= [n]
and either of the following two events happen:
• for some i, Z i * Y i ; or
• ∪ki=1 Z i 6= [n]
Player i will detect the first of these two cases, and the coordinator will detect the second. In either case,
the coordinator will output “not disjoint”.
As for the complexity of the protocol, the coordinator runs step 2 of the protocol only if step 1 passes,
namely if (Z 1 , . . . , Z k ) forms a partition of [n]. In this case, the overhead of the protocol is O(n log n + k)
bits. Since the communication complexity of set disjointness in the coordinator model is Ω(nk), so is the
communication complexity of task allocation.

