
We introduce the cross-composition framework for proving kernelization lower bounds. A
classical problem L and/or-cross-composes into a parameterized problem Q if it is possible
to efficiently construct an instance of Q with polynomially bounded parameter value that
expresses the logical and or or of a sequence of instances of L. Building on work by
Bodlaender et al. (ICALP 2008) and using a result by Fortnow and Santhanam (STOC
2008) with a refinement by Dell and van Melkebeek (STOC 2010), we show that if an NPhard problem or-cross-composes into a parameterized problem Q then Q does not admit a
polynomial kernel unless NP ⊆ coNP/poly and the polynomial hierarchy collapses. Similarly,
an and-cross-composition for Q rules out polynomial kernels for Q under Bodlaender et al.’s
and-distillation conjecture.
Our technique generalizes and strengthens the recent techniques of using composition
algorithms and of transferring the lower bounds via polynomial parameter transformations. We show its applicability by proving kernelization lower bounds for a number of
important graphs problems with structural (non-standard) parameterizations, e.g., Clique,
Chromatic Number, Weighted Feedback Vertex Set, and Weighted Odd Cycle
Transversal do not admit polynomial kernels with respect to the vertex cover number
of the input graphs unless the polynomial hierarchy collapses, contrasting the fact that
these problems are trivially fixed-parameter tractable for this parameter. We have similar
lower bounds for Feedback Vertex Set and Odd Cycle Transversal under structural
parameterizations.
After learning of our results, several teams of authors have successfully applied the
cross-composition framework to different parameterized problems. For completeness, our
presentation of the framework includes several extensions based on this follow-up work. For
example, we show how a relaxed version of or-cross-compositions may be used to give lower
bounds on the degree of the polynomial in the kernel size.

1

Introduction

Preprocessing and data reduction are important and widely applied concepts for speeding up
polynomial-time algorithms, and for making computation feasible at all in the case of hard
problems that are not believed to have efficient algorithms. Kernelization is a way of formalizing
data reduction, which allows for a formal analysis of the (im)possibility of data reduction and
preprocessing. It originated as a technique to obtain fixed-parameter tractable algorithms for
hard (parameterized) problems, and has evolved into its own topic of research (see [32, 3,
∗
This work was supported by the Netherlands Organization for Scientific Research (NWO), project “KERNELS: Combinatorial Analysis of Data Reduction”. A preliminary version appeared in the proceedings of the
28th International Symposium on Theoretical Aspects of Computer Science (STACS 2011). Several results have
been strengthened compared to the preliminary version.
†
Department of Information and Computing Sciences, Utrecht University, P.O. Box 80.089, 3508 TB, Utrecht,
The Netherlands, {H.L.Bodlaender,B.M.P.Jansen,S.Kratsch}@uu.nl

1

44] for recent surveys). A parameterized problem [23, 27, 45] is a language Q ⊆ Σ∗ × N,
the second component is called the parameter. Such a problem is (strongly uniformly) fixedparameter tractable (FPT) if there is a computable function f such that membership of an
instance (x, k) can be decided in f (k)nO(1) time. A kernelization algorithm (kernel) for Q
transforms an instance (x, k) in time polynomial in |x| + k into an equivalent instance (x′ , k′ )
such that max(|x′ |, k′ ) ≤ f (k) for some computable function f , which is the size of the kernel.
It is well-known that a decidable problem admits a kernel if and only if it is fixed-parameter
tractable (cf. [3]). From a practical perspective we are particularly interested in cases where the
kernel size f is polynomially bounded in k, so-called polynomial kernels. Success stories of kernelization include the O(k2 ) kernel for k-Vertex Cover containing at most 2k vertices [12, 13, 1]
and the meta-theorems for kernelization of problems on topological graph classes [5, 28]. The
research community spent many years trying to find polynomial kernels for elusive problems
such as k-Path, before techniques were developed which made it possible to prove (under some
complexity-theoretic assumption) that a parameterized problem in FPT does not admit a polynomial kernel. Bodlaender et al. [4] introduced the concept of an or-composition algorithm as
a tool to give super-polynomial lower bounds on kernel sizes. Informally speaking — we defer
formal definitions to Section 2 — an or-composition algorithm combines a series of inputs of
a parameterized problem Q, all sharing the same parameter k, into a single instance (x′ , k′ )
of Q such that k′ is polynomial in k, and (x′ , k′ ) acts as the logical or of the inputs in the
sense that (x′ , k′ ) is a yes-instance if and only if (at least) one of the inputs is. They used
a theorem by Fortnow and Santhanam [29] to show that if there is an or-composition for an
NP-hard parameterized problem Q, then Q does not admit a polynomial kernelization unless
NP ⊆ coNP/poly. This machinery made it possible to prove, e.g., that k-Path and the Clique
problem parameterized by the treewidth of the graph do not admit polynomial kernels unless
NP ⊆ coNP/poly1 . The latter condition is equivalent to coNP ⊆ NP/poly, and is deemed unlikely as it implies a collapse of the polynomial hierarchy to its third level [49] and further [11].
It did not take long before the techniques of Bodlaender et al. were combined with the notion
of a polynomial parameter transformation to also prove lower bounds for problems for which no
direct or-composition algorithm could be found. This idea was used implicitly by Fernau et
al. [26] to show that k-Leaf Out-Branching does not admit a polynomial kernel, and was
formalized in a paper by Bodlaender et al. [10]: they showed that if there is a polynomial-time
transformation from Q to Q′ which incurs only a polynomial blow-up in the parameter size, then
if Q does not admit a polynomial kernel then Q′ does not admit one either. These polynomial
parameter transformations were used extensively by Dom et al. [22] who proved kernelization
lower bounds for a multitude of important parameterized problems such as Small Universe
Hitting Set and Small Universe Set Cover. Dell and van Melkebeek [21] were able to
extend the techniques of Fortnow and Santhanam to prove, e.g., that Vertex Cover does
not admit a kernel of bitsize O(k2−ε ) for any ε > 0. Follow-up work has resulted in lower
bounds on the degree of the polynomial in the kernel sizes of packing problems [20, 35], using
composition-like techniques in which the output parameter is allowed to depend sublinearly on
the number of inputs. The complementary witness lemma of Dell and van Melkebeek [21] shows
that even co-nondeterministic compositions give kernel lower bounds2; this subsequently led
one of the current authors to leverage the power of co-nondeterminism to obtain a lower bound
for a Ramsey-type problem [39].
Our contribution. We introduce the framework of cross-composition for obtaining ker1

In the remainder of this introduction we assume that NP 6⊆ coNP/poly when stating kernelization lower
bounds.
2
In fact, this is already implicit in the results of Fortnow and Santhanam as observed in unpublished work of
Chen and Müller (cf. [33]).

2

nelization lower bounds, and give several applications to fundamental graph problems under
structural parameterizations. The technique generalizes and strengthens the earlier methods
of compositions [4] and polynomial-parameter transformations [10], and puts the two existing
methods for obtaining kernelization lower bounds in a common perspective. Whereas the existing notion of and or or-composition works by composing multiple instances of a parameterized
problem Q into a single instance of Q with a bounded parameter value, in the cross-composition
framework it is sufficient to compose the and or or of any classical NP-hard problem into an
instance of the parameterized problem Q for which we want to prove a lower-bound. The term
cross in the name stems from this fact: the source- and target problem of the composition need
no longer be the same. Since the input to a cross-composition algorithm is a list of classical
instances instead of parameterized instances, the inputs do not have a parameter in which the
output parameter of the composition must be bounded; instead we require that the size of the
output parameter is polynomially bounded in the size of the largest input instance. This makes
our extension also fruitful when the source and target problems of the composition coincide,
since it allows for a larger parameter value in the target instance than what would be permissible
in a “classic” composition. In addition we show that the output parameter for a composition of t
instances may depend polynomially on the logarithm of the number of input instances, which
often simplifies the constructions and proofs. We also introduce the concept of a polynomial
equivalence relation to remove the need for padding arguments which were frequently required
in compositions.
We exhibit the power of cross-composition by giving kernelization lower bounds for structural
parameterizations of several important graph problems. Since many combinatorial problems are
easy on graphs of bounded treewidth [9], and since the treewidth of a graph is bounded by the
vertex cover number, many problems are fixed-parameter tractable when parameterized by the
cardinality of a given vertex cover. We show that this tractability does not extend to polynomial kernelizability: Clique, Chromatic Number, Weighted Feedback Vertex Set, and
Weighted Odd Cycle Transversal do not admit polynomial kernels under this parameterization. In the case of Clique it was already known [4] that the problem does not admit a
polynomial kernel parameterized by the treewidth of the graph; since the vertex cover number is
at least as large as the treewidth we prove a stronger result. By taking the edge-complement of
the input graph, Clique parameterized by the size of a given vertex cover is FPT-equivalent to
Vertex Cover parameterized by the size of a given vertex set whose removal leaves a clique.
Hence we also establish a kernel lower bound for the latter problem, which marks an interesting boundary in the search for the smallest parameterization of Vertex Cover admitting a
polynomial kernel [18, 36, 41]. We provide a polynomial-parameter transformation to extend
the lower bound to Feedback Vertex Set and Odd Cycle Transversal parameterized
by the vertex-deletion distance to a clique, contrasting the known polynomial kernelizability of
these problems with respect to the natural parameterization by solution size [48, 42]. These
results strengthen lower bounds given in a preliminary version of this work, where we supplied
lower bounds for the smaller parameters “deletion distance to a cluster graph” and “deletion
distance to a co-cluster graph”.
Since the introduction of the cross-composition framework, it has found numerous applications by various sets of authors [7, 8, 14, 15, 16, 17, 19, 31, 36, 38]. Although all applications of
the cross-composition technique presented here are for problems under structural parameterizations, the framework can also be used to obtain lower bounds for natural parameterizations. For
example, Cygan et al. [16] employed cross-composition to obtain kernelization lower bounds for
Edge Clique Cover, settling an open problem in kernelization, and also for various graph cut
problems parameterized by the size of the cutset. The mentioned follow-up work together with
other results on lower bounds for kernelization [21, 20, 35, 39] also suggests several extensions,
3

most of which are reviewed and included in this work. For one, we include the variant of an
and-cross-composition as used first by Cygan et al. [16]. Furthermore, we explicitly define a
modification of or-cross-compositions that allows proofs of polynomial lower bounds for kernelization in the style of Dell and van Melkebeek [21]. Regarding co-nondeterministic variants
of or-cross-compositions we refer the reader to the full version of recent work by Kratsch [39].3
Organization. We start by giving formal definitions of all concepts relevant for our discussion of kernelization lower bounds in Section 2, thereby providing a brief overview of the
existing techniques. In Section 3 we present the cross-composition framework. Our treatise of
the subject incorporates several small improvements that have been found after an extended
abstract of this work was published [6]. After giving the definitions of the various notions of
cross-composition, we show how they imply kernel lower bounds. The remainder of the paper is
concerned with applications of the technique to specific parameterized problems. As these are
all graph problems, we give some graph-theoretic preliminaries in Section 4.1 before presenting
our lower bounds.

2

A review of kernelization lower bound techniques

Before introducing the framework of cross-composition, we give formal definitions of the various
concepts relating to kernelization. Let us fix some notation. Throughout this work we use Σ
to denote finite alphabets; note that Σ may refer to a different alphabet for each problem.
We denote classical problems as L ⊆ Σ∗ and parameterized problems as Q ⊆ Σ∗ × N. Since
tuples (x, k) can straightforwardly be encoded as strings over Σ (when |Σ| ≥ 2) we may also say
that a parameterized problem is NP-hard or NP-complete; in all cases the parameter value k
of (x, k) is encoded in unary, for a total size of O(|x| + k). We call a string x ∈ Σ∗ an instance
for L ⊆ Σ∗ ; ditto for (x, k) ∈ Σ∗ × N and Q ⊆ Σ∗ × N. We say that the instance x ∈ Σ∗ is
yes for L ⊆ Σ∗ if x ∈ L, and no for L otherwise; the same holds for (x, k) ∈ Q. For positive
integers n we define [n] := {1, . . . , n}.

2.1

Kernelizations and Compressions

We begin with a formal definition of kernelization and generalized kernelization (also called bikernel [2]). Subsequently we also define a natural notion of compressing instances of parameterized problems into short strings over some alphabet, i.e., compressing to some language L ⊆ Σ∗ ,
which relaxes the notion of kernelization. The known kernelization lower bound techniques,
namely via compositions, cross-compositions, and the complementary witness lemma, can all
be easily seen to apply also to such compressions. In the following we will state the known tools
in this more general way.
Definition 1 (kernelization, generalized kernelization). Let Q, Q′ ⊆ Σ∗ × N be parameterized
problems and let h : N → N be a computable function. A generalized kernelization for Q into Q′
of size h(k) is an algorithm that on input (x, k) ∈ Σ∗ × N takes time polynomial in |x| + k and
outputs an instance (x′ , k′ ) such that:
“PB”: The size of x′ and the parameter value k′ are bounded by h(k).
“EQ”: The instance (x′ , k′ ) is yes for Q′ if and only if (x, k) is yes for Q.
The algorithm is a kernelization, or in short a kernel, for Q if Q′ = Q. It is a polynomial
(generalized) kernelization if h(k) is a polynomial.
3

This is not yet available but will soon appear in Transactions in Algorithms.

4

Definition 2 (compression). Let Q ⊆ Σ∗ × N be a parameterized problem, let L ⊆ Σ∗ be a
language, and let h : N → N be a computable function. A compression for Q into L of size h(k)
is an algorithm that on input (x, k) ∈ Σ∗ × N takes time polynomial in |x| + k and outputs a
string y ∈ Σ∗ such that:
“PB”: The length of y is bounded by h(k).
“EQ”: The string y is yes for L if and only if (x, k) is yes for Q.
The algorithm is a polynomial compression if h(k) is a polynomial.
The following proposition explicitly states that compressions are a relaxation of generalized
kernelizations, which in turn relax the notion of kernelization.
Proposition 1. Let Q ⊆ Σ∗ × N be a parameterized problem. If Q has a kernelization with
size h : N → N then Q also has a generalized kernelization with size h. Similarly, if Q has a
generalized kernelization with size h then Q has a compression with size O(h).
Remark 1. The proposition follows immediately from Definitions 1 and 2. Let us clarify however that a compression can be derived from a (generalized) kernelization with kernel size h
by mapping each output instance (x′ , k′ ) ∈ Σ∗ × N to an encoding as a string z ∈ Σ∗ (assume |Σ| ≥ 2, otherwise use Σ′ := {0, 1}). With a unary encoding for k′ this gives a bound
of O(h(k)) on the length of z since both |x′ | and k′ are bounded by h(k), where k is the input
parameter.

2.2

Compositions and Distillations

We now turn our attention to the main components of the original kernelization lower bound
framework of Bodlaender et al. [4]. We will first recall the notions of or/and-composition and
weak or/and-distillations. Both notions formalize ways of encoding the logical or respectively
and of a large number of instances into a single instance that is small according to some measure.
Compositions address parameterized problems and require the output parameter to be small.
Distillations address classical problems, or languages, and demand a small overall output size.
Although we do not use the compositions of Bodlaender et al. [4] in this work, we supply the
definitions to highlight the differences with cross-composition.
Definition 3 (or/and-composition [4]). Let Q ⊆ Σ∗ × N be a parameterized problem. An
or-composition for Q is an
that, given t instances (x1 , k), . . . , (xt , k) ∈ Σ∗ × N of Q,
Palgorithm
t
takes time polynomial in i=1 |xi | + k and outputs an instance (y, k ′ ) ∈ Σ∗ × N such that:
“PB”: The parameter value k′ is polynomially bounded in k.

“OR”: The instance (y, k ′ ) is yes for Q if and only if at least one instance (xi , k)
is yes for Q.
An and-composition is an algorithm that, instead, fulfills Properties “PB” and “AND”.
“AND”: The instance (y, k ′ ) is yes for Q if and only if all instances (xi , k) are
yes for Q.
A parameterized problem Q for which such an algorithm exists is called or-compositional respectively and-compositional.
Definition 4 (weak or/and-distillation [4, 29]). Let L, L′ ⊆ Σ∗ be languages. A weak ordistillation of L intoPL′ is an algorithm that, given t instances x1 , x2 , . . . , xt ∈ Σ∗ of L, takes
time polynomial in ti=1 |xi | and outputs a string y ∈ Σ∗ such that:
5

“PB”: The length of y is polynomially bounded in maxti=1 |xi |.
“OR”: The instance y is yes for L′ if and only if at least one instance xi is yes
for L.
A weak and-distillation of L into L′ is an algorithm that, instead, fulfills Properties “PB” and
“AND”.
“AND”: The instance y is yes for L′ if and only if all instances xi are yes for L.
The crux of the framework is that the combination of a polynomial kernelization and a
composition, for some parameterized problem Q, yields a distillation for Q (when interpreted
as a classical problem). In the following we denote the satisfiability problem for boolean formulae
as sat.
Theorem 1 ([4]). Let Q ⊆ Σ∗ × N be a parameterized problem that is NP-hard when the
parameter value is encoded in unary, i.e., when instances (x, k) have size O(|x| + k). If Q has
a polynomial kernelization (or polynomial compression) and an or-composition, then sat has
a weak or-distillation into some language L ⊆ Σ∗ . If Q instead has an and-composition, then
sat has an and-distillation into L.
Remark 2. The reason for requiring NP-hardness with parameter value encoded in unary is
that this implies a Karp reduction from instances φ for sat to instances (x, k) for Q with k
polynomially bounded in |φ|.
Bodlaender et al. [4] conjectured that no NP-hard problem has a distillation.
Conjecture 1 (or-distillation conjecture [4]). No NP-hard problem L has a weak or-distillation into any language L′ .
Conjecture 2 (and-distillation conjecture [4]). No NP-hard problem L has a weak anddistillation into any language L′ .
The or-distillation conjecture was proved shortly after by Fortnow and Santhanam [29],
under the assumption that NP 6⊆ coNP/poly. Drucker [24] recently announced a proof of the
and-distillation conjecture based on the same assumption, but using much more complicated
machinery.
Theorem 2 ([29]). If there is a weak or-distillation of sat into any language L ⊆ Σ∗ then
NP ⊆ coNP/poly and the polynomial-time hierarchy collapses to its third level (PH = Σp3 ).

2.3

Transformations and Oracle Communication Protocols

The result of Fortnow and Santhanam [29] was generalized by Dell and van Melkebeek [21],
who abstract away from the perspective of kernelization and distillation by considering an
appropriate oracle communication protocol. They obtain more fine-grained results by taking
into account not just the number of instances that are combined but also their maximum size.
This way they prove a more general form of Theorem 2, namely their complementary witness
lemma (see below) and also various polynomial lower bounds for kernelization (and PCPs); e.g.,
they show that d-Hitting Set (i.e., Vertex Cover on hypergraphs with edge size at most d)
admits no polynomial kernelization with size O(kd−ε ), for any ε > 0, unless NP ⊆ coNP/poly.

6

Definition 5 (oracle communication protocol [21]). An oracle communication protocol for a
language L is a communication protocol for two players. The first player is given the input x and
has to run in time polynomial in the length of the input; the second player is computationally
unbounded but is not given any part of x. At the end of the protocol the first player should be
able to decide whether x ∈ L. The cost of the protocol is the number of bits of communication
from the first player to the second player.
Definition 6 (or/and of a language [21]). Let L ⊆ Σ∗ be a language. The or of the language L,
denoted by or(L), is the set of all tuples (x1 , . . . , xt ) for which xi ∈ L for at least one i ∈ [t]. The
and of the language L, denoted by and(L), is the set of all tuples (x1 , . . . , xt ) for which xi ∈ L
for all i ∈ [t].
Lemma 1 (complementary witness lemma [21]). Let L be a language and t : N → N\{0} be polynomially bounded such that the problem of deciding whether tuples (x1 , . . . , xt(s) ) of strings each
of length at most s belong to or(L) has an oracle communication protocol of cost O(t(s) log t(s)),
where the first player can be co-nondeterministic. Then L ∈ coNP/poly.
Finally, we turn our attention to a different way of proving lower bounds for kernelization,
namely the use of appropriate reductions. The following type of parameterized reduction, originally called polynomial time and parameter transformation, was first formalized by Bodlaender
et al. [10]. It is not hard to see that they are strongly related to the existence of polynomial
kernelizations (or compressions).
Similarly, one may define parameterized reductions with other bounds on the new parameter
value, but they are not required in this work. Reductions with a linear dependence have been
used to transfer polynomial bounds for kernelization [35] and in the context of lower bounds on
the runtime of FPT-algorithms [43].
Definition 7 (polynomial parameter transformation [10]). Let Q, Q′ ⊆ Σ∗ × N be parameterized problems. A polynomial parameter transformation from Q to Q′ is an algorithm that on
input (x, k) ∈ Σ∗ × N takes time polynomial in |x| + k and outputs an instance (x′ , k′ ) ∈ Σ∗ × N
such that:
“PB”: The parameter value k′ is polynomially bounded in k.
“EQ”: The instance (x′ , k′ ) is yes for Q′ if and only if (x, k) is yes for Q.
We denote the existence of such a transformation by Q ≤ppt Q′ .
Theorem 3 ([4]). Let Q ⊆ Σ∗ × N be a parameterized problem that is NP-hard with parameter
encoded in unary, and let Q′ ⊆ Σ∗ × N be a parameterized problem that is contained in NP.
If Q ≤ppt Q′ and Q′ admits a polynomial kernelization then Q admits a polynomial kernelization.
To avoid the complication of having to insist on the unary encoding of the parameter value
we suggest the following proposition, which applies to the existence of polynomial compressions
(and generalized kernelizations). Since lower bounds for kernelization for some parameterized
problem Q ⊆ Σ∗ × N via the tools in this section exclude also polynomial compressions, it seems
much easier to only require Q ≤ppt Q′ to transfer the lower bound to any other parameterized
problem Q′ .
Proposition 2. Let Q and Q′ be parameterized problems with Q ≤ppt Q′ . If Q′ admits a
polynomial compression then Q admits a polynomial compression. If, possibly under some
complexity-theoretic assumption, Q admits no polynomial compression then Q′ admits no polynomial compression under the same assumption. The same is true regarding generalized polynomial kernelizations.
7

3

Cross-composition

3.1

The Basic Framework

The two main concepts of the framework are defined as follows.
Definition 8 (polynomial equivalence relation). An equivalence relation R on Σ∗ is called a
polynomial equivalence relation if the following two conditions hold:
1. There is an algorithm that given two strings x, y ∈ Σ∗ decides whether x and y belong to
the same equivalence class in time polynomial in |x| + |y|.
2. For any finite set S ⊆ Σ∗ the equivalence relation R partitions the elements of S into a
number of classes that is polynomially bounded in the size of the largest element of S.
Remark 3. The intended use of polynomial equivalence relations is to group inputs for a
(cross-)composition such that the composition will only be applied to groups of instances that
are somewhat similar, e.g., they ask for the same solution size or the considered graphs have
the same numbers of vertices and edges. We point out that R = Σ∗ × Σ∗ trivially fulfills
the definition of a polynomial equivalence relation (all strings are equivalent and any set S is
“partitioned” into a single class). Thus the use of polynomial equivalence relations in crosscompositions according to the following definition is optional.
Definition 9 (and/or-cross-composition). Let L ⊆ Σ∗ be a language, let R be a polynomial
equivalence relation on Σ∗ , and let Q ⊆ Σ∗ × N be a parameterized problem. An or-cross-com∗
position of L into Q (with respect to R) is an algorithm that, given t instances
Pt x1 , x2 , . . . , xt ∈ Σ
of L belonging to the same equivalence class of R, takes time polynomial in i=1 |xi | and outputs
an instance (y, k) ∈ Σ∗ × N such that:
“PB”: The parameter value k is polynomially bounded in maxi |xi | + log t.
“OR”: The instance (y, k) is yes for Q if and only if at least one instance xi is yes
for L.
An and-cross-composition of L into Q (with respect to R) is an algorithm that, instead, fulfills
Properties “PB” and “AND”.
“AND”: The instance (y, k) is yes for Q if and only if all instances xi are yes
for L.
We say that L or-cross-composes, respectively and-cross-composes, into Q if a cross-composition
algorithm of the relevant type exists for a suitable relation R.
For historic reasons we reserve cross-composition (without preposition) to refer to the or
variant. As with plain and/or-compositions, an and/or-cross-composition can be combined
with a polynomial compression to give a weak and/or-distillation; we prove this explicitly for
the case of and-cross-compositions.
Theorem 4. Let L ⊆ Σ∗ be a language and let Q ⊆ Σ∗ × N be a parameterized problem. If L
and-cross-composes into Q and Q has a polynomial compression (into an arbitrary language L′ )
then L has a weak and-distillation (into and(L′ )).
Proof. To prove the theorem we construct the claimed weak distillation by generalizing the
approach of Bodlaender et al. [4]. Let C denote an and-cross-composition algorithm from L
into Q and let R denote a suitable polynomial equivalence relation. Let K denote a polynomial
8

compression algorithm for Q into L′ . The input to the distillation is a sequence (x1 , . . . , xt ) of
instances of L ⊆ Σ∗ . Define s := maxti=1 |xi |. If t > (|Σ| + 1)s then there must be duplicate
′
inputs, since the number of distinct inputs of length s′ ≤ s is |Σ|s . By discarding duplicates
we may therefore assume that t ≤ (|Σ| + 1)s and hence that log t ∈ O(s).
The algorithm first partitions the input instances into disjoint nonempty sets X1 , . . . , Xr
according to equivalence under R. By
P the definition of R it is clear that this can be done
in time polynomial in the input size i |xi |. Next, the and-cross-composition algorithm C is
applied to each set Xi , 1 ≤ i ≤ r, and produces one instance (yi , ki ) ∈ Σ∗ × N from each set Xi .
From the definition of an and-cross-composition and using log t ∈ O(s) it follows that each ki
is polynomially bounded in s, and that the computation of these parameterized instances takes
time polynomial in the total input size. It also follows that (yi , ki ) is a yes instance of Q if and
only if all of the instances in Xi are yes for L.
Now, we apply the polynomial compression K to each instance (yi , ki ) to obtain an equivalent
instance zi of L′ for each 1 ≤ i ≤ r. Since K is a polynomial compression we know that these
transformations can be carried out in polynomial time and that |zi | is polynomially bounded
in ki . Since ki is polynomial in s it follows that |zi | is also polynomial in s for 1 ≤ i ≤ r.
Finally, the algorithm simply combines all strings zi into one tuple z ∗ := (z1 , . . . , zr ), which
is an instance of and(L′ ). Since the size of each component is polynomial in s, and since the
number of components r is polynomial in s, we have that |z ∗ | is polynomial in s. By Definition 6
we know that z ∗ ∈ and(L′ ) if and only if all elements of the tuple are contained in L′ . By tracing
back the series of equivalences we therefore find that z ∗ ∈ and(L′ ) if and only if all inputs xi
are yes for L. Since we can construct z ∗ in polynomial time and |z ∗ | is polynomial in s, we
have constructed a weak distillation of L into and(L′ ).
The analogous result holds for or-cross-compositions and can be proven along the same
lines.
Theorem 5. Let L ⊆ Σ∗ be a language and let Q ⊆ Σ∗ × N be a parameterized problem. If L
or-cross-composes into Q and Q has a polynomial compression (into an arbitrary language L′ )
then L has a weak or-distillation (into or(L′ )).
The machinery developed in this section leads to two ways of giving kernelization lower
bounds, via and- respectively or-cross-compositions.
Corollary 1. If an NP-hard language L and-cross-composes into the parameterized problem Q,
then Q does not admit a (generalized) polynomial kernelization or polynomial compression unless
the and-distillation conjecture fails.
Corollary 2. If an NP-hard language L or-cross-composes into the parameterized problem Q,
then Q does not admit a (generalized) polynomial kernelization or polynomial compression unless
the or-distillation conjecture fails and NP ⊆ coNP/poly.
The lower bounds via or-cross-compositions are somewhat stronger due to the result of
Fortnow and Santhanam (Theorem 2) who proved the or-distillation conjecture under the
assumption that NP 6⊆ coNP/poly. Note that a weak or-distillation for an NP-hard language L
can be combined with the NP-hardness reduction from sat to L, resulting in a weak ordistillation for sat. Using the tight bounds on the compressibility of or(L) that are provided
by the complementary witness lemma, it is possible to derive a statement that can also be applied
to give lower bounds on the degree of the polynomial for problems that do admit polynomial
kernels. We state and prove this extension in the next section as Theorem 6; it also implies the
NP ⊆ coNP/poly consequence of Corollary 2 but skips the intermediate step of building a weak
or-distillation.
9

3.2

Cross-compositions of bounded cost

The mentioned recent results of Dell and van Melkebeek [21] that permit polynomial lower
bounds via oracle communication protocols for the or of languages also permit us to create a
similar extension for or-cross-compositions. By a similar analysis as performed by Dell and van
Melkebeek [21] (see also [35]) we can establish that appropriate cross-compositions with bounded
cost imply polynomial lower bounds, assuming NP 6⊆ coNP/poly.
Definition 10 (and/or-cross-composition of bounded cost). An and/or-cross-composition
of L into Q (with respect to R) of cost f (t) is an and/or-cross-composition algorithm as
described in Definition 9 that satisfies “CB” instead of “PB”.
“CB”: The parameter k is bounded by O(f (t) · (maxi |xi |)c ), where c is some constant independent of t.
Theorem 6. Let L ⊆ Σ∗ be a language, let Q ⊆ Σ∗ × N be a parameterized problem, and
let d, ǫ be positive reals. If L has an or-cross-composition into Q with cost f (t) = t1/d+o(1) ,
where t denotes the number of instances, and Q has a polynomial compression into an arbitrary
language L′ with size bound O(kd−ǫ ) then L ∈ coNP/poly. If, additionally, L is NP-hard then
NP ⊆ coNP/poly.
Proof. Let R be a polynomial equivalence relation on Σ∗ which partitions any set of strings
of length at most s into at most O(sb ) equivalence classes. Let f (t) = t1/d+o(1) for some
constant d. Let C be an or-cross-composition from L into Q, which maps t instances of size
at most s and from the same R-equivalence class to an output instance with parameter value
bounded by O(f (t)sc ). Finally, let K be a polynomial compression for Q into some language L′
that outputs a string of size bounded by h(k) = O(kd−ǫ ).
d
We define a polynomially bounded function t by t(s) := s(b+cd)· ǫ . By Lemma 1 it suffices to
provide an oracle communication protocol for or(L) with cost O(t(s) log t(s)) for a tuple of t
strings each of length at most s. Fixing s and t := t(s), let a tuple of t strings each of length at
most s be given to the first player, say (x1 , . . . , xt ).
Let us first describe the protocol and bound the communication cost. The first player begins
by partitioning the strings xi according to equivalence under R, obtaining r ≤ O(sb ) groups.
Then he applies the or-cross-composition C to each group, obtaining r instances (y1 , k1 ), . . . ,
(yr , kr ). The parameter values ki are bounded by O(f (t)sc ).
Now the first player applies the assumed polynomial compression K to each instance (yi , ki ),
obtaining instances z1 , . . . , zr of the language L′ . Then he sends the instances zi to the second
player, who answers yes if at least one of the instances sent to him is yes, and no otherwise.
(Note that in this simple protocol the second player might as well be an L′ -oracle, and the cost
would correspond to the total length of queries.)
Each compressed instance has size at most h(ki ) = O((ki )d−ǫ ) = O((f (t)sc )d−ǫ ). Thus we
can bound the cost of sending the r compressed instances to the second player as follows:
 
d−ǫ 




ǫ
1
+o(1)
c
c d−ǫ
b
s
= O sb+c(d−ǫ) t1− d +o(1) = O(t),
O r · (f (t)s )
= O s td
using that r ≤ O(sb ) and the following bound for sb+c(d−ǫ) :
ǫ

ǫ

sb+c(d−ǫ) = sb+cd · s−cǫ = t d · s−cǫ = t d −δ ,
where δ =

cǫ2
(b+cd)d

> 0. (Note that t1−δ+o(1) = O(t), for any δ > 0.)

10

Correctness. It remains to show correctness of the protocol. Assume first that at least one
input instance xi is a yes-instance (requiring the protocol to correctly answer yes). It follows
that the corresponding instance (yj , kj ) that is created by C from all instances R-equivalent
to xi must be yes for Q. Accordingly, the polynomial compression K transforms (yj , kj ) to a
yes-instance for the language L′ . Hence, the oracle correctly answers yes, as it is given at least
one yes-instance for L′ .
In the remaining case all input instances x1 , . . . , xt are no for L. The or-cross-composition C
will therefore create r no-instances (yi , ki ) for Q. These are converted to r no-instances zi for L′ .
Hence, presented with only no-instances for L′ , the oracle answers no.
Thus we get an oracle communication protocol for deciding the or of t instances of L at
cost O(t). By Lemma 1 this implies that L is contained in coNP/poly. Hence, if L is NP-hard
then NP ⊆ coNP/poly.
It is an immediate consequence that cross-compositions with cost f (t) = to(1) exclude any
polynomial compression. To see this, observe that their cost is bounded also by t1/d+o(1) for
any positive constant d. Thus, for any constant d this excludes polynomial compressions to
size O(kd−ǫ ) and hence any polynomial compression.
Corollary 3. Let L ⊆ Σ∗ be a language and let Q ⊆ Σ∗ × N be a parameterized problem. If L
has an or-cross-composition into Q with dependence f (t) = to(1) on the number t of instances
and Q has a polynomial compression into an arbitrary language L′ then L ∈ coNP/poly. If,
additionally, L is NP-hard then NP ⊆ coNP/poly.

4

Our lower bounds

Cross-composition makes it possible to give kernelization lower bounds for structural parameterizations of various fundamental graph problems. In the following sections we study Clique,
Chromatic Number, Feedback Vertex Set, and Odd Cycle Transversal. We show
that parameterizations solvable by the simplest of FPT algorithms nevertheless fail to admit
polynomial kernelizations unless NP ⊆ coNP/poly. All lower bounds we give in this section also
apply to generalized kernelizations, but for brevity we only state them for normal kernelizations.
The cross-compositions employed in this section all take the form of or-cross-compositions. For
historic reasons and simplicity we shall therefore omit the adjective or in the remainder. Before
presenting our kernel lower bounds we give some graph-theoretic preliminaries.

4.1

Graph preliminaries

We will only work with undirected, finite, simple graphs. For a graph G we denote its vertex
set by V (G) and the edge set by E(G). We use G[V ′ ] to denote the subgraph of G induced
by V ′ , i.e., the graph on vertex set V ′ and edge set {{u, v} ∈ E(G) | u, v ∈ V ′ }. We use G − Z
as an abbreviation for G[V (G) \ Z]. The open neighborhood of a vertex v in graph G contains
the vertices adjacent
to v, and is written as NG (v). The open neighborhood of a set S ⊆ V (G)
S
is defined as v∈S NG (v) \ S. Identifying a set S ⊆ V (G) of vertices of graph G into a new
vertex x, results in the graph obtained from G − S by adding a new vertex x adjacent to the
vertices in NG (S). The edge-complement of G is the graph G with edge set {{u, v} ⊆ V (G) |
u 6= v ∧ {u, v} 6∈ E(G)}. An odd cycle is a simple cycle on an odd number of vertices. An
ℓ-coloring of graph G is a function f : V (G) → [ℓ], and it is a proper coloring if {u, v} ∈ E(G)
implies f (u) 6= f (v).
The chromatic number χ(G) of the graph G is defined as the smallest integer ℓ for which G
has a proper ℓ-coloring. A vertex cover in the graph G is a subset Z ⊆ V (G) which intersects
11

all edges, therefore implying that G − Z is an edgeless graph. If Z intersects all cycles then
it is a feedback vertex set (fvs), and its removal G − Z yields a forest. Finally, an odd cycle
transversal (oct) intersects all odd cycles, and its removal results in a bipartite graph. The
vertex cover number of G is the size of a smallest vertex cover; the numbers related to the other
two types of transversals are defined analogously. The vertex-deletion distance of a graph G to
a graph family F is the size of a smallest set S ⊆ V (G) such that G − S ∈ F. We use Kt and Pt
to denote a clique or path on t vertices, respectively. We will occasionally use n to refer to
the number of vertices in the (input) graph under consideration. When taking the n-bit binary
expansion of numbers in the range 1 up to 2n , we map 2n to the bitstring consisting of n zeros.

4.2

Cliques and Vertex Covers

In this section we prove a kernel lower bound for a strong structural parameterization of Clique,
and we consider some of its consequences. An instance of the NP-complete Clique problem [30,
GT19] is a tuple (G, ℓ) and asks whether the graph G contains a clique on ℓ vertices. This
classical problem is the source language for the cross-composition which establishes our first
kernelization lower bound. The parameterization for which we derive a lower bound is formally
defined as follows.
Clique parameterized by Vertex Cover
Instance: A graph G, a vertex cover Z ⊆ V (G), and a positive integer ℓ.
Parameter: The size k := |Z| of the vertex cover.
Question: Does G have a clique of size at least ℓ?
Note that we supply a vertex cover in the input of the problem, to ensure that well-formed
instances can be recognized efficiently: the parameter to the problem claims a bound on the
vertex cover number of the graph, and using the set Z we may verify this bound in polynomial
time. We will define the other parameterized problems for which we establish kernel lower
bounds similarly. Observe that these versions of the problems, where a witness of the parameter
value is supplied in the input, are certainly no harder to kernelize than the versions where
such a witness is not given. An extensive discussion of the technicalities regarding structural
parameterizations can be found in the recent survey by Fellows et al. [25].
Let us briefly consider the complexity of the chosen parameterization of the Clique problem.
If the graph G has a vertex cover Z and contains a clique C ⊆ V (G), then |C \ Z| ≤ 1: as
the definition of a vertex cover ensures there are no edges between vertices in V (G) \ Z, any
clique contains at most one vertex from V (G) \ Z. The problem defined above can therefore
be solved in O(2|Z| n2 ) time by enumerating all subsets C ⊆ Z, checking whether they induce
a clique G[C], and whether there is a vertex in V (G) \ Z adjacent to all members of C which
may be added to the clique. We detect a maximum clique when its intersection with Z is used
as the subset C.
This same insight also yields a so-called cheating kernel [26] or Turing kernel [34]. For
an input instance (G, Z, ℓ, k) of Clique parameterized by Vertex Cover, create a list of
instances which contains for each v ∈ V (G) \ Z the instance (G[Z ∪ {v}], Z, ℓ, k), in addition
to (G[Z], Z, ℓ, k). The preceding discussion shows that G has a clique of size ℓ, if and only
if one of the instances in the list has such a clique. As each instance in the list contains at
most |Z| + 1 = k + 1 vertices, this is an interesting example of a rare phenomenon: although
we cannot, in polynomial time, reduce the size of an instance of Clique parameterized
by Vertex Cover to polynomial in the parameter, we can create O(nO(1) ) instances of size
polynomial in the parameter, such that the input is yes if and only if one of the outputs is.

12

B

n

z

t
}|

ui

···











vℓ,p

···



..


.





|

..
.

..
.

C

···
wp,q

vℓ,q
..
.

···
{z
ℓ

uj

}

..
.
w·,·

{

wp,q̂ wp̂,q








 
n
2


.. D .. 

.
. 




w·,ˆ·

wˆ·,·

Figure 1: A sketch of the construction used in the proof of Theorem 7. The dashed edges show
in an exemplary way how vertices wp,q , wp,q̂ , and wp̂,q are connected to vertices of B and C,
e.g., {p, q} is an edge of Gi but not of Gj .
Having provided all the necessary background for the following lower bound, we give its
proof by cross-composition.
Theorem 7. Clique parameterized by Vertex Cover does not admit a polynomial kernel
unless NP ⊆ coNP/poly.
Proof. We prove the theorem by showing that Clique cross-composes into Clique parameterized by Vertex Cover; by Corollary 2 this is sufficient to establish the claim. We define
a polynomial equivalence relation R such that all bitstrings that do not encode a valid instance
of Clique or that have a target clique size ℓ that exceeds the number of vertices are equivalent.
Of the remaining instances any two (well-formed) instances (G1 , ℓ1 ) and (G2 , ℓ2 ) are equivalent
if and only if they satisfy |V (G1 )| = |V (G2 )| and ℓ1 = ℓ2 . From this definition it follows that
any set of well-formed instances on at most n vertices each is partitioned into O(n2 ) equivalence
classes. Thus R is a polynomial equivalence relation since the number of bits in a clique instance
on n vertices is at least n.
We now give a cross-composition algorithm that composes t input instances x1 , . . . , xt that
are equivalent under R into a single instance of Clique parameterized by Vertex Cover.
If the input instances are malformed or the size of the clique that is asked for exceeds the number
of vertices in the graph, then we may output a single constant-size no instance; hence in the remainder we may assume that all inputs are well-formed and encode structures (G1 , ℓ), . . . , (Gt , ℓ)
such that |V (Gi )| = n for all i ∈ [t] and all instances agree on the value of ℓ ≤ n. We construct
a single instance (G′ , Z ′ , ℓ′ , k′ ) of Clique parameterized by Vertex Cover, which consists
of a graph G′ with vertex cover Z ′ ⊆ V (G′ ) of size k′ , and an integer ℓ′ .
Let the vertices in each graph Gi be numbered arbitrarily from 1 to n. We construct the
graph G′ as follows (see also Figure 1):
1. Create ℓn vertices vi,j with i ∈ [ℓ] and j ∈ [n]. Connect two vertices vi,j and vi′ ,j ′ if i 6= i′
and j 6= j ′ . Let C denote the set of these vertices. It is crucial that any clique in G′ can
only contain one vertex vi,· or v·,j for each choice of i ∈ [ℓ] respectively j ∈ [n]. Thus any
clique contains at most ℓ vertices from C.
2. For each pair 1 ≤ p < q ≤ n of distinct vertices from [n] (i.e., vertices of graphs Gi ),
create three vertices: wp,q , wp,q̂ , and wp̂,q and make them adjacent to C as follows:
13

(a) wp,q is adjacent to all vertices from C,
(b) wp,q̂ is adjacent to all vertices from C except for v·,j with j = q, and
(c) wp̂,q is adjacent to all vertices from C except for v·,j with j = p.
Furthermore we add all edges between
vertices w·,· that correspond to distinct pairs

from [n]. Let D denote these 3 n2 vertices. Any clique can contain at most one w·,·
vertex for each pair from [n].
3. For each input instance xi with graph Gi , make a new vertex ui and connect it to all
vertices in C. The adjacency to D is as follows:
(a) Make ui adjacent to wp,q if {p, q} is an edge in Gi .
(b) Otherwise make ui adjacent to wp,q̂ and wp̂,q .
Let B denote this set of t vertices.

We define ℓ′ := ℓ + 1 + n2 . Furthermore, we let Z ′ := C ∪ D which is easily verified to be a
vertex cover for G′ of size k′ := |Z ′ | = ℓn + 3 n2 . The value k′ is the parameter to the problem;
it is polynomial in n and hence in the size of the largest input instance. The cross-composition
outputs the instance x′ := (G′ , Z ′ , ℓ′ , k′ ). It is easy to see that our construction of G′ can be
performed in polynomial time. Let us now argue that x′ is yes for Clique parameterized
by Vertex Cover if and only if at least one of the instances xi is yes for Clique.
(⇐) First we will assume that some xi∗ = (Gi∗ , ℓ) is yes for Clique, i.e., that Gi∗ contains
a clique on at least ℓ vertices. Let S ⊆ [n] denote a clique of size exactly ℓ in Gi∗ . We will
construct a set S ′ of size ℓ′ = ℓ + 1 + n2 and show that it is a clique in G′ :
1. We add the vertex ui∗ to S ′ .

2. Let S = {p1 , . . . , pℓ } ⊆ [n]. For each pj in S we add the vertex vj,pj to S ′ . By Step 1 all
these vertices are pairwise adjacent, and by Step 3 they are adjacent to ui∗ .
3. For each pair 1 ≤ p < q ≤ n there are two cases:
(a) If {p, q} is an edge of Gi∗ then the vertex ui∗ is adjacent to wp,q in G′ (by Step 3)
and wp,q is adjacent to all vertices of C (by Step 2). We add wp,q to S ′ .
(b) Otherwise the vertex ui∗ is adjacent to both wp,q̂ and wp̂,q . Since the clique S cannot
contain both p and q when {p, q} is a non-edge, we can add wp,q̂ or wp̂,q to S ′ while
preserving the fact that G′ [S ′ ] is a clique. Recall that, e.g., wp,q̂ is adjacent to all
vertices of C except those corresponding to q.
In both cases we add one w·,· -vertex to S ′ , each corresponding to a different pair p, q; all
these vertices are pairwise adjacent by Step 2.

We have identified the clique S ′ in G′ of size ℓ′ = ℓ + 1 + n2 , proving that x′ is a yes-instance.

(⇒) Now assume that x′ is a yes-instance and let S ′ be a clique of size ℓ + 1 + n2 in G′ .
Since S ′ contains at most ℓ vertices from C (i.e., one vi,· for each i ∈ [ℓ]) and at most n2 vertices
from D it must contain at least one vertex from B, say ui∗ ∈ B. Since Bis an independent
set, the clique S ′ must contain exactly ℓ vertices from C and exactly n2 vertices from D.
Let S = {j ∈ [n] | vi,j ∈ S ′ for some i ∈ [ℓ]}. The set S has size ℓ since S ′ contains at most
one vertex v·,j for each j ∈ [n]. We will now argue that S is a clique in Gi∗ . Let p, q ∈ S.
The clique S ′ must contain a w·,· -vertex corresponding to {p, q} and it must contain vertices vi,p
and vi′ ,q for some i, i′ ∈ [ℓ]. Therefore it must contain wp,q since wp,q̂ has no edges to vertices v·,q
14

and wp̂,q has no edges to v·,p by Step 2. Thus ui∗ ∈ S ′ must be adjacent to wp,q which implies
that Gi∗ contains the edge {p, q}. Thus S is a clique in Gi∗ .
Since we proved that the instance (G′ , Z ′ , ℓ′ , k′ ) can be constructed in polynomial time and
that it acts as the or of the input instances, and because the parameter value k ′ is bounded
by a polynomial in the size of the largest input instance, this concludes the cross-composition
proof and establishes the claim.
In the remainder of this work we will not be as explicit in giving the definition of the
equivalence relationship R as we were in the proof of Theorem 7: we shall simply state the
desired forms of the inputs when it is easy to see that such a form can be achieved by a suitable
choice of R. We restrict ourselves to giving cross-compositions for well-formed input instances,
since we can simply output a constant-sized no instance if the input is a sequence of malformed
instances. The previous theorem yields an interesting corollary for the following structural
parameterization of Vertex Cover.
Vertex Cover parameterized by Clique Deletion Set
Instance: A graph G, a set Z ⊆ V (G) such that G − Z is a clique, and a positive
integer ℓ.
Parameter: The size k := |Z| of the deletion set.
Question: Does G have a vertex cover of size at most ℓ?
As the vertex cover number of a clique Kt is t−1, we can interpret this as a parameterization
by the distance from trivially solvable instances as discussed by Niedermeier [46]. Our results
imply that even though the parameter will often be very large, the problem is unlikely to admit
a polynomial kernel.
Corollary 4. If F is a class of graphs containing all cliques, then Vertex Cover and Independent Set parameterized by the minimum number of vertex deletions to obtain a graph
in F do not admit polynomial kernels unless NP ⊆ coNP/poly. In particular, Vertex Cover
and Independent Set parameterized by clique deletion set do not admit polynomial kernels
unless NP ⊆ coNP/poly.
Proof. Consider an instance (G, Z, ℓ, k) of Clique parameterized by Vertex Cover. Since
a clique in G is an independent set in G, the Clique instance is equivalent to asking whether
the graph G has an independent set of size at least ℓ. Because Z is a vertex cover for G we know
that G − Z is an independent set, and therefore G − Z is a clique. Hence the instance (G, Z, ℓ, k)
of Clique parameterized by Vertex Cover is equivalent to an instance (G, Z, ℓ, k) of Independent Set parameterized by Clique Deletion Set. Since G has an independent set
of size ℓ if and only if it has a vertex cover of size |V (G)| − ℓ it follows that these two instances
are also equivalent to the instance (G, Z, |V (G)| − ℓ, k) of Vertex Cover parameterized by
Clique Deletion Set. Hence the described operations serve as polynomial parameter transformations from Clique parameterized by Vertex Cover into the mentioned problems,
which yields the corollary by Theorem 7 and Proposition 2.

4.3

Chromatic Number

In this section we give a kernelization lower bound for Chromatic Number parameterized
by Vertex Cover, by cross-composing a restricted version of 3-Coloring into it. We consider
the problem on the following class of graphs.
Definition 11. A graph G is a triangle split graph if V (G) can be partitioned into sets X
and Y such that G[X] is an edgeless graph and G[Y ] is a disjoint union of triangles.
15

We will see that 3-Coloring instances on triangle split graphs lend themselves better to
composition than general instances: if we take the disjoint union of a set of triangle split graphs
and merge the induced triangles one by one, no adjacency information is lost. Before we give the
composition, however, we must prove that 3-Coloring is still NP-complete with this restriction
on the input graphs.
3-Coloring with Triangle Split Decomposition
Instance: A graph G with a partition of its vertex set into X ∪ Y such that G[X]
is edgeless and G[Y ] is a union of vertex-disjoint triangles.
Question: Is there a proper 3-coloring of G?
We prove the NP-completeness of this problem by replacing edges in a general instance of
3-Coloring by triangles.
Lemma 2. 3-Coloring with Triangle Split Decomposition is NP-complete.
Proof. It is well-known that 3-Coloring on general graphs is NP-complete [30, GT4], and it
is trivial to see that the problem restricted to triangle split graphs is contained in NP. We show
how to transform an instance G of 3-coloring in polynomial time into an equivalent instance
of 3-coloring on a graph G′ with a triangle split decomposition of V (G′ ) into sets X ′ and Y ′ .
Number the edges in G as e1 , e2 , . . . , em . Construct the graph G′ as follows:
• Set V (G′ ) := V (G) ∪ {ai , bi , ci | i ∈ [m]} and E(G′ ) := ∅.
• Add the edges {ai , bi }, {bi , ci }, {ai , ci } to E(G′ ) for i ∈ [m].
• For each edge ei = {ui , vi } (i ∈ [m]) of graph G, make vertex ui adjacent in G′ to ai , and
make vi adjacent to bi and ci .
• Define X ′ := V (G) and Y ′ := {ai , bi , ci | i ∈ [m]}.
This concludes the description of G′ . It is easy to see that G′ is a triangle split graph with the
partition X ′ and Y ′ since G′ [X ′ ] is an independent set and G′ [Y ′ ] is a disjoint union of triangles.
We now show that χ(G′ ) ≤ 3 if and only if χ(G) ≤ 3.
(⇒) Assume that χ(G′ ) ≤ 3 and consider a 3-coloring of G′ . For every edge {ui , vi } ∈ E(G)
we added a triangle on vertices {ai , bi , ci } to the graph G′ . Hence G′ [NG′ ({ui , vi })] contains a
triangle for all pairs of vertices {ui , vi } which are adjacent in G. If some pair ui and vi receive the
same color, then this leaves only two colors to use on the triangle in their open neighborhood.
As it takes three colors to properly color a triangle, any proper 3-coloring of G′ uses different
colors for ui and vi , for all {ui , vi } ∈ E(G). Therefore the 3-coloring of G′ restricted to the
vertex set of G is a proper 3-coloring of G.
(⇐) Assume that G has a proper 3-coloring. We construct a 3-coloring for G′ by coloring
all vertices of V (G′ ) ∩ V (G) the same as in G; now all that remains is to color the triangles we
added to the graph. If there is a triangle {ai , bi , ci } for a pair {ui , vi } then {ui , vi } are adjacent
in G and hence they receive different colors in the proper coloring. Now give ai the color of vi ,
give bi the color of ui and give ci the remaining color. If we do this for every triangle then we
obtain a proper 3-coloring of G′ which proves that χ(G′ ) ≤ 3.
Since the instance (G′ , X ′ , Y ′ ) can be built from G in polynomial time this proves that
3-Coloring with Triangle Split Decomposition is NP-complete.
Equipped with this lemma we can prove a kernel lower bound for the following problem.

16

Chromatic Number parameterized by Vertex Cover
Instance: A graph G, a vertex cover Z ⊆ V (G), and a positive integer ℓ.
Parameter: The size k := |Z| of the vertex cover.
Question: Is there a proper ℓ-coloring of G?
The parameterization is easily seen to be fixed-parameter tractable by noting that the chromatic number of a graph exceeds its vertex cover number by at most one. Hence ℓ ≤ |Z| + 1 for
all relevant inputs, which yields an FPT algorithm by trying all ℓ-colorings of G[Z] and testing
whether they can be extended to the entire graph. This test comes down to checking whether
for each vertex v ∈ V (G) \ Z there is a color which is not yet used on a neighbor in Z, resulting
in a total runtime of O(ℓ|Z| nO(1) ) = O((k + 1)k nO(1) ).
Theorem 8. Chromatic Number parameterized by Vertex Cover does not admit a
polynomial kernel unless NP ⊆ coNP/poly.
Proof. To prove the theorem we will show that 3-Coloring with Triangle Split Decomposition cross-composes into Chromatic Number parameterized by Vertex Cover. By a
suitable choice of polynomial equivalence relation — in the same style as in Theorem 7 — we may
assume that we are given t input instances that encode structures (G1 , X1 , Y1 ), . . . , (Gt , Xt , Yt )
of 3-Coloring with Triangle Split Decomposition with |Xi | = n and |Yi | = 3m for
all i ∈ [t] (i.e., m is the number of triangles in each instance). We will compose these instances
into one instance (G′ , Z ′ , ℓ′ , k′ ) of Chromatic Number parameterized by Vertex Cover.
By duplicating some instances we may assume that the number of inputs t is a power of 2; this
does not affect the truth value of the or of the inputs, and a parameter value which is suitably
bounded with respect to the longer sequence of inputs, is also suitably bounded with respect to
the original list of inputs.
For each set Yi , label the triangles in Gi [Yi ] as T1 , . . . , Tm in some arbitrary way, and label
the vertices in each triangle Tj for a set Yi as aij , bij , cij . We build a graph G′ with a vertex cover
of size k′ := 3 log t + 4 + 3m ∈ O(m + log t) such that G′ can be ℓ′ := log t + 4-colored if and
only if one of the input instances can be 3-colored.
1. Initialize the graph G′ as the disjoint union of the input graphs G1 , . . . , Gt .
2. For each j ∈ [m], identify the vertices {aij | i ∈ [t]} into a new vertex aj . Similarly
identify all bij into bj , and all cij into cj , for each j ∈ [m]. The vertices resulting from
these identification operations are the triangle vertices T ′ . As we are effectively merging
triangles one by one, G′ [T ′ ] is a disjoint union of triangles.
3. Add a clique on vertices {pi | i ∈ [log t]} ∪ {w, x, y, z} to G′ ; it is called the palette.
4. Make all vertices in T ′ adjacent to all vertices from the palette except x, y, and z.
S
5. Make all the vertices in ti=1 Xi adjacent to w.

6. For i ∈ [log t] add a path on two new vertices {q0i , q1i } to the graph, and make them
adjacent to all vertices of the palette except pi and w. These vertices form the instance
selector vertices.

7. For each instance number i ∈ [t] we can write a binary representation of the value i in log t
bits. Consider each position j ∈ [log t] of this binary representation, where position 1 is
most significant and log t is least significant. If bit number j of the representation of i is
a 0 (resp. a 1) then make vertex q0j (resp. q1j ) adjacent to all vertices of Xi .
17

This concludes the construction. The following claims about G′ are easy to verify:
(I) In every proper ℓ′ = log t + 4-coloring of G′ , the following holds:
(a) each of the log t + 4 vertices of the palette clique receives a unique color,
(b) for each i ∈ [log t] the vertices q0i and q1i receive different colors (since they are
adjacent); one of them must take the color of w and the other of pi (they are
adjacent to all other vertices of the palette),
(c) the triangle vertices T ′ are colored using the colors of x, y, z (they are adjacent to
all other vertices of the palette),
(d) the only colors which can occur on a vertex in Xi (for all i ∈ [t]) are the colors given
to x, y, z and {pj | j ∈ [log t]} (since the vertices in Xi are adjacent to w).
(II) For every i ∈ [t], the graph G′ [Xi ∪ T ′ ] is isomorphic to Gi .
(III) The set Z ′ := {pi | i ∈ [log t]} ∪ {w, x, y, z} ∪ T ′ ∪ {q0i , q1i | i ∈ [log t]} forms a vertex cover
of G′ of size k′ = |Z ′ | = 3 log t + 4 + 3m. Hence we establish that G′ has a vertex cover
of size O(m + log t).
The output of the cross-composition is the instance (G′ , Z ′ , ℓ′ := log t + 4, k ′ ). It is easy to verify
that the construction can be performed in polynomial time. As the value of k′ is polynomial
in log t plus the size of the largest input, it remains to prove that the output indeed acts as
the logical or of the input instances: χ(G′ ) ≤ log t + 4 if and only if there is an i ∈ [t] such
that χ(Gi ) ≤ 3.
(⇒) Suppose χ(G′ ) ≤ ℓ′ and consider some proper ℓ′ -coloring of G′ . By (I.b) we know that
for each i ∈ [log t] exactly one vertex of the pair {q0i , q1i } receives the same color as pi . Consider
the string of log t bits where the i-th most significant bit is a 1 if and only if vertex q1i receives
the same color as pi . This bitstring encodes some integer i∗ ∈ [t]. We focus on the instance with
the number i∗ . Let Q be the set of vertices which contains for each pair {q0i , q1i } (i ∈ [log t])
the unique vertex which is colored the same as pi . By the definition of G′ we know that all
vertices of Xi∗ are adjacent to all vertices of Q; hence in any proper coloring of G′ the vertices
of Xi∗ cannot use any colors which are used on {pi | i ∈ [log t]}. By (I.d) this implies that the
coloring for G′ can only use the colors of x, y, z on the vertices of Xi∗ . By (I.c) the triangle
vertices T ′ are also colored using only the colors of x, y, z. The graph G′ [Xi∗ ∪ T ′ ] is isomorphic
to the input graph Gi∗ by (II), and since the coloring of G′ only uses the colors of x, y, z on
these vertices, this shows that the coloring of G′ restricted to the induced subgraph G′ [Xi∗ ∪ T ′ ]
is in fact a 3-coloring of graph Gi∗ , which proves that χ(Gi∗ ) ≤ 3 and establishes this direction
of the equivalence.
(⇐) Suppose χ(Gi∗ ) ≤ 3 for some i∗ ∈ [t]. We will construct a proper ℓ′ -coloring of G′ . Start
by giving all vertices of the palette different colors. By (II) the graph G′ [Xi∗ ∪ T ′ ] is isomorphic
to Gi∗ . Re-label the colors in the 3-coloring of Gi∗ such that it uses the colors given to {x, y, z}
in our partial ℓ′ -coloring of G′ . Give a vertex v in the induced subgraph G′ [Xi∗ ∪ T ′ ] the same
color as the vertex in Gi∗ that it is mapped to by the isomorphism. Afterwards we have a
proper partial ℓ′ -coloring, where all vertices of the palette, all vertices of Xi∗ , and all triangle
vertices of G′ are colored. It remains to color the sets Xi for i 6= i∗ , and the pairs {q0i , q1i }. For
each i ∈ [log t] we color the pair {q0i , q1i } as follows: if the i-th most significant bit of the binary
representation of the number i∗ is a 1 then we color q1i the same color as pi and we color q0i as w;
if the bit is a 0 then we do it the other way around. It is straight forward to verify that we do
not create any monochromatic edges in this way. As the final step we have to color the sets Xi
for i 6= i∗ ; so consider some i ∈ [t] with i 6= i∗ . The binary representation of the number i∗
18

must differ from the binary representation of i in at least one position; suppose they differ at
position j. The vertex of {q0j , q1j } that matches the bit value of i∗ at position j was colored the
same as pj , hence the other vertex of the pair must have been colored the same as w. Since the
bit values differ, by the definition of adjacencies in G′ we find that the vertices Xi are adjacent
to the vertex of {q0j , q1j } that is colored as w. Therefore the vertices of Xi do not have any
neighbors colored as pj , and since Xi is an independent set we may color all vertices in it the
same as pj . If we color all sets Xi for i 6= i∗ in this way we obtain a proper ℓ′ -coloring of G′
which proves that χ(G′ ) ≤ ℓ′ .
Theorem 8 shows that Chromatic Number parameterized by Vertex Cover is unlikely to admit a polynomial kernel. If we treat the number of colors as a constant q, rather than
a variable, then the problem does admit a polynomial kernel: q-Coloring parameterized
by Vertex Cover has a kernel with O(kq ) vertices for every fixed q [37]. The lower bound
shows that q must appear in the degree of the polynomial for such kernels.
By interpreting Chromatic Number on G as the problem of partitioning the vertex set
of G into a minimum number of cliques, we obtain the following corollary to Theorem 8 — note
that if Z ⊆ V (G) is a vertex cover of G, then G − Z is a clique.
Corollary 5. Vertex Partition Into Cliques [30, GT15] parameterized by vertex-deletion
distance to a clique does not admit a polynomial kernel unless NP ⊆ coNP/poly.

4.4

Feedback Vertex Set and Odd Cycle Transversal

The problems Feedback Vertex Set (fvs) and Odd Cycle Transversal (oct) ask
whether a given graph contains a small set of vertices that intersects all cycles, respectively
all odd cycles. The study of their natural parameterization by the solution size has led to
important advances in the design of FPT algorithms and kernelizations. Both problems are
fixed-parameter tractable [48, 47] and admit (randomized) polynomial kernels [48, 42]. We
consider the kernelization complexity of these problems from a different angle. First we study
the non-standard parameter “deletion distance to a clique” and use a polynomial parameter
transformation to transfer a lower bound result from the similarly parameterized vertex cover
problem (Corollary 4). Thus the two cycle transversal problems do not admit polynomial kernels for this parameter, unless NP ⊆ coNP/poly. Then we consider a generalization of the
problem where each vertex is assigned an integral weight, and we seek a cycle transversal of
bounded total weight. Using cross-composition we prove that the resulting problems do not
admit polynomial kernels when parameterized by the cardinality of a given vertex cover.
4.4.1

Unweighted problems parameterized by distance to a clique

We give kernelization lower bounds for fvs and oct under the following structural parameterization.
Feedback Vertex Set parameterized by Clique Deletion Set
Instance: A graph G, a set Z ⊆ V (G) such that G − Z is a clique, and a positive
integer ℓ.
Parameter: The size k := |Z| of the deletion set.
Question: Is there a set S ⊆ V (G) of at most ℓ vertices that intersects all cycles?
The problem Odd Cycle Transversal parameterized by Clique Deletion Set is defined analogously, by asking for a set that intersects all odd cycles. It is easy to give FPT
algorithms for these two parameterizations. If G is a graph in which the removal of Z ⊆ V (G)
19

leaves a clique, then an fvs or oct in G avoids at most two vertices of V (G) \ Z, as otherwise V (G)\Z contains a triangle not intersected by the transversal. Hence there are O(n2 ) ways
in which a valid transversal may intersect V (G) \ Z. For each valid intersection with V (G) \ Z
we may simply try all subsets of Z to see which gives the smallest transversal that is valid for
the entire graph, resulting in an algorithm of runtime O(2|Z| nO(1) ).
Despite the simplicity of the algorithms, the problems are unlikely to admit polynomial
kernels. The following theorem strengthens the results in a preliminary version of this work
where we proved kernel lower bounds for fvs under the smaller parameterizations “vertexdeletion distance to a cluster graph” and “vertex-deletion distance to a co-cluster graph” [6].
The theorem also subsumes results from an extended abstract by a subset of the authors,
where a kernel lower bound for oct was given for parameterizations by (co-)cluster deletion
distance [38].
Theorem 9. Feedback Vertex Set and Odd Cycle Transversal do not admit polynomial kernels when parameterized by a clique deletion set, unless NP ⊆ coNP/poly.
Proof. By Corollary 4 and Proposition 2 it is sufficient to prove that there are a polynomialparameter transformations from Vertex Cover parameterized by Clique Deletion Set
into fvs parameterized by Clique Deletion Set and oct parameterized by Clique
Deletion Set. We give a single construction that works for both cases.
Let (G, Z, ℓ, k) be an instance of Vertex Cover parameterized by Clique Deletion
Set. Let us first argue that the edges of G can be covered by a small number of cliques; this
will be essential for our transformation. Take the family of vertex subsets G defined as follows:
G := E(G[Z]) ∪ {V (G) \ Z} ∪ {NG [v] \ (Z \ {v}) | v ∈ V (G) \ Z}. The endpoints of an edge
trivially form a two-vertex clique, the problem definition ensures that G−Z is a clique, and each
vertex together with its neighborhood in the clique G − Z also forms a clique: hence each subset
induces a clique in G. Since each edge of G is either contained in G[Z], contained in G − Z, or
connects a vertex in Z to a vertex outside Z, the family of cliques covers all edges. It is easy
to see that |G| ≤ X2 + 1 + |X|, and hence we can cover the edges in the input instance by a
number of cliques which is polynomial in the parameter. The clique cover G can be computed
in polynomial time. We use it to construct an output instance as follows.
Initialize G′ as a copy of G. For each clique C ∈ G, add a vertex vC to G′ with NG′ (vC ) := C.
Let Z ′ be the union of Z and all the vertices vC added in this way. We find that |Z ′ | =
|Z| + |G| and therefore |Z ′ | is bounded polynomially in the input parameter |Z|; let k′ := |Z ′ |.
As G′ − Z ′ = G − Z, removal of the set Z ′ from G′ results in a clique. We claim that when
interpreting the tuple (G′ , Z ′ , ℓ, k ′ ) as an instance of fvs or oct parameterized by a clique
deletion set, the answer to the instance is the same as for the input instance (G, Z, ℓ, k).
Suppose that (G, Z, ℓ, k) is a yes-instance of Vertex Cover parameterized by Clique
Deletion Set, and let S ⊆ V (G) be a vertex cover of G of size at most ℓ. By the definition of
a vertex cover, G − S is an independent set. Since every subset C ∈ G is a clique in G′ , it follows
that |C \ S| ≤ 1 for all C ∈ G. Observe that we can obtain G′ − S from G − S by introducing
the vertices vC for all C ∈ G. Starting from the graph G − S without edges, and using the fact
that |C \ S| ≤ 1 for all C ∈ G′ it is easy to see that adding the vertices vC to obtain G′ − S
comes down to repeatedly adding vertices of degree at most one to an acyclic graph. As such
a process does not create cycles, G′ − S is a forest. Therefore S is both an fvs and an oct
for G′ , of size at most ℓ, which proves that (G′ , Z ′ , ℓ, k ′ ) a yes-instance for the two considered
problems.
For the reverse direction, suppose that there is a set S ′ ⊆ V (G′ ) of size at most ℓ whose
removal from G′ leaves a graph without odd cycles; if (G′ , Z ′ , ℓ, k ′ ) is a yes-instance of fvs or
oct then such a set exists. We first show that without loss of generality, we may assume vC 6∈ S ′
20

for all C ∈ G. To this end, assume that there is some C ∗ ∈ G such that vC ∗ ∈ S ′ . If C ∗ \ S ′ = ∅,
∗ } is also an oct for G′ as all neighbors of v ∗ are contained in the deletion set.
then S ′ \ {vC
C
If, on the other hand, there exists some u ∈ C ∗ \ S ′ , then we claim S ∗ := (S ′ \ {u}) ∪ {vC ∗ } is
also an oct in G′ . Indeed, by construction of G′ we have NG′ [vC ∗ ] ⊆ NG′ [u] and therefore we
can substitute u for vC ∗ in any odd cycle in G′ − S ∗ to obtain an odd cycle in G′ − S ′ . As the
latter graph does not contain odd cycles, it follows S ∗ is an oct in G′ . Since the replacement
process can be performed independently for each C ∈ G we conclude that if (G′ , Z ′ , ℓ, k′ ) is a
yes-instance, then G′ has an oct S ′ of size at most ℓ that does not contain any vertex vC
for c ∈ G. Now observe that such a set S ′ forms a vertex cover of graph G: if G − S contains
an edge {x, y}, then the edge clique cover G contains a clique Cx,y ⊇ {x, y}. As vCx,y 6∈ S ′ by
construction, this implies G′ − S ′ contains a triangle on x, y and vCx,y ; a contradiction. This
establishes the correctness of the transformation. Since it can be carried out in polynomial
time, and the resulting parameter |Z ′ | is bounded polynomially in the input parameter |Z|, the
theorem follows.
4.4.2

Weighted problems parameterized by vertex cover

In this section we consider the kernelization complexity of weighted versions of fvs and oct,
parameterized by the cardinality of a given vertex cover. Our results extend the line of research
initiated by a subset of the authors, who showed that Weighted Vertex Cover does not
admit a polynomial kernel under such a parameterization, unless NP ⊆ coNP/poly [36]. The
cross-composition we present unifies a construction from a preliminary version of this work [6]
for fvs, with a construction for oct which appeared in an extended abstract by a subset of the
authors [38]. Let us formally define the problems under consideration.
Weighted Feedback Vertex Set parameterized by Vertex Cover
Instance: A graph G, a vertex cover Z ⊆ V (G), a weight function w : N → N, and
a positive integer ℓ.
Parameter: The size k := |Z| of the vertex cover.
Question:
Is there a set S ⊆ V (G) that intersects all cycles in G and satisP
fies v∈S w(v) ≤ ℓ?

The related problem Weighted Odd Cycle Transversal parameterized by Vertex
Cover is defined in the natural way. The parameterized problems are easily seen to be fixedparameter tractable by noting that the treewidth of the input graphs is bounded by k, which
allows for a solution by standard dynamic programming techniques [9]. We start by presenting
a construction that will be the key to merging multiple input instances.
Definition 12. For a graph G define its inflation φ(G) by the following steps:
• Obtain graph G′ from G by completing every edge into a triangle with a new vertex: for
each edge e = {u, v} ∈ E(G), add a new vertex ve with NG′ (ve ) := {u, v} to G′ .
• Obtain graph φ(G) from G′ by replacing every edge {u, v} ∈ E(G′ ) by a path on two new
vertices: remove edge {u, v} while adding vertices p1 and p2 with the edges {u, p1 }, {p1 , p2 }
and {p2 , v}.
Note that by this definition, the vertex set of φ(G) is a superset of V (G); hence we may
take a subset S ⊆ V (G) and consider the effect of removing S from φ(G). As an example of
the inflation operation, note that the inflation φ(K2 ) of a single edge yields a simple cycle on
nine vertices.
21

Observation 1. For any graph G and its inflation φ(G), the following holds:
• The graph φ(G) − V (G) is the disjoint union of 3|E(G)| copies of P2 .
• The set V (G) is independent in φ(G).
There is a correspondence between vertex covers of G, and sets that form an fvs or oct in
the inflation φ(G). This correspondence will enable us to cross-compose instances of Vertex
Cover into the cycle covering problems.
Lemma 3. For any graph G and integer ℓ, the following conditions are equivalent.
1. The graph G has a vertex cover of size at most ℓ.
2. The graph φ(G) has a feedback vertex set of size at most ℓ.
3. The graph φ(G) has an odd cycle transversal of size at most ℓ.
Proof. (1⇒2) Suppose that S ⊆ V (G) is a vertex cover of G of size at most ℓ, and consider an
arbitrary simple cycle C in φ(G): we will show that S contains a vertex on C. Let G′ be the
intermediate graph obtained from G that is used in the construction of φ(G) in Definition 12. As
all edges were replaced by P2 ’s when going from G′ to φ(G), it follows that C can be transformed
into a cycle C ′ in G′ by replacing such P2 ’s by direct edges. Hence C corresponds to a simple
cycle C ′ in G′ such that V (C ′ ) ⊆ V (C).
• If C ′ contains a vertex ve that was introduced to complete an edge e = {u, v} into a
triangle in the first step of Definition 12, then ve only has u and v as neighbors and
therefore C ′ contains u and v. This pair is connected by the edge e in G. As S is a vertex
cover of G it contains one of the vertices u and v, and therefore intersects the cycle C ′ .
Since V (C ′ ) ⊆ V (C) the set S intersects C as well.
• If C ′ does not contain any vertices ve used to complete edges into triangles, then V (C ′ ) ⊆
V (G) and hence the cycle C ′ also exists in G. Now the vertex cover S of G contains at
least one vertex of C ′ , which implies that it intersects C.
Hence all cycles in φ(G) are intersected by S, which shows that S is an fvs of size at most ℓ
in φ(G).
(2⇒3) An fvs of size at most ℓ in φ(G) is also an oct: the former covers all cycles, and the
latter only has to cover odd cycles.
(3⇒1) Suppose S ⊆ V (φ(G)) is an oct of φ(G), of size at most ℓ. We first show that we
may assume S ⊆ V (G). So assume S contains a vertex v 6∈ V (G), i.e., a vertex which was
introduced by the inflation operation to subdivide an edge or complete an edge into a triangle.
From Definition 12 it follows that v has degree two in φ(G), and that by following a path of
consecutive degree-two vertices in φ(G) we arrive at a vertex u in V (G) ∩ V (φ(G)). As all
cycles through v contain the vertex u, any cycle intersected by v is also intersected by u, and
therefore (S \{v})∪{u} is also an oct of φ(G). By repeating this step we obtain a set S ⊆ V (G)
of size at most ℓ which intersects the odd cycles of φ(G). We claim that this S is a vertex cover
in G.
Assume for a contradiction that there is an edge e = {u, v} in G for which no endpoint is
contained in S. The graph G′ used in the construction of φ(G) has a vertex ve adjacent to u
and v, and hence contains a triangle C ′ := (v, ve , u). When creating φ(G) from G′ , each edge on
this triangle is subdivided by two new vertices resulting in an odd cycle C in φ(G) on 3 + 6 = 9
vertices. Hence φ(G) contains an odd cycle C such that V (C) ∩ V (G) = {u, v}. As S does not
contain u nor v by assumption, φ(G) − S contains an odd cycle which implies that S is not an
oct for φ(G); a contradiction.
22

1
0

0
1

Figure 2: The K4 -in-a-box graph BK4 with labeled vertices.
Before presenting the cross-composition we also introduce the following gadget, which will
be used as a bit selector.
Definition 13. The K4 -in-a-box graph BK4 (see Figure 2) is the graph obtained from a clique on
four vertices {a, b, c, d} by adding a new degree-2 vertex v for each pair {a, b}, {b, c}, {c, d}, {d, a}
such that v is adjacent to both vertices of the pair. The vertices {a, c} are the 0-labeled terminals
of the graph, and the vertices {b, d} are the 1-labeled terminals of the graph.
Observation 2. Any vertex set that covers all triangles of BK4 has size at least two. Every
size-2 vertex set covering all triangles either consists of the 0-labeled terminals or the 1-labeled
terminals.
We present a single construction that can serve as a cross-composition of the classical Vertex Cover problem into both cycle covering problems considered in this section. Recall that
an instance of the NP-complete [30, GT1] Vertex Cover problem is a tuple (G, ℓ) and asks
whether G has a vertex cover of size at most ℓ.
Theorem 10. Weighted Feedback Vertex Set and Weighted Odd Cycle Transversal do not admit polynomial kernels when parameterized by vertex cover, unless NP ⊆ coNP/poly.
Proof. We prove the theorem by showing that Vertex Cover cross-composes into both Weighted
Feedback Vertex Set and Weighted Odd Cycle Transversal under the chosen parameterization. The same cross-composition works for both problems. By a suitable choice of polynomial equivalence relation we may assume the input consists of well-formed instances (G1 , ℓ), . . . ,
(Gt , ℓ) of Vertex Cover that all have the same number of vertices, say n, and edges, say m,
and that have the same target value ℓ. By the argument given in the proof of Theorem 8 we
may assume that t is a power of 2. As a graph on n vertices trivially has a vertex cover of size n,
we may output a constant-size yes-instance if ℓ = n and assume that ℓ < n in the remainder
of the proof.
We will merge the inflated versions of the input graphs to obtain the desired cross-composition.
By Observation 1 it holds for each input Gi that φ(Gi ) − V (Gi ) is a disjoint union of 3m copies
of P2 . Label the P2 ’s in φ(Gi ) − V (Gi ) arbitrarily from 1 to 3m, and assign each P2 a left and
right endpoint. Construct a graph G′ with weight function w′ as follows.
1. Initialize G′ as the disjoint union of the graphs φ(Gi ) for i ∈ [t].
2. For each j ∈ [3m], consider the j-th copy of P2 in the inflated input graph φ(Gi ) − V (Gi ).
Modify the graph G′ by identifying all the left endpoints of the j-th P2 into a single vertex.
Similarly identify all the right endpoints of the j-th P2 into a single vertex. Let A′ ⊆ V (G′ )
contain the resulting merged vertices. Observe that as we merged P2 ’s one by one, the
graph G′ [A′ ] is a disjoint union of P2 ’s and therefore G′ [V (Gi ) ∪ A′ ] is isomorphic to φ(Gi )
for all i ∈ [t].
23

3. We can represent an instance number in the range [t] using exactly log t bits since we
assumed t is a power of 2. For each bit position j ∈ [log t] we create a copy of the
graph BK4 described in Definition 13. We label its 0-terminal vertices {bj,0′ , bj,0′′ } and
the 1-terminal vertices {bj,1′ , bj,1′′ }. For each instance number i whose j-th most significant
bit in the binary expansion is a 0, we make all vertices of V (Gi ) in G′ adjacent to the 0terminals {bj,0′ , bj,0′′ }, and for instance numbers whose bit value is 1 we make it adjacent
to {bj,1′ , bj,1′′ }.
4. Assign each vertex corresponding to a copy of BK4 a weight of t · n, and give all other
vertices weight 1.
This concludes the description of the graph G′ and weight function w′ . Since a valid instance of
Weighted Feedback Vertex Set parameterized by vertex cover also contains a vertex cover
set Z ′ , we must supply such a vertex cover as part of the output of the procedure. Observation 1
shows that for each input Gi , the set V (Gi ) is independent in φ(Gi ). As G′ contains the disjoint
union ofSthe inflated input graphs, and since merging the P2 ’s does not introduce edges in
the set ti=1 V (Gi ), it follows that a vertex cover Z ′ of G′ can be formed by taking the union
of A′ and all vertices of each of the log t copies of BK4 . The size of this vertex cover Z ′
is |A′ | + 8 log t = 3m + 8 log t. The parameter value k′ := |Z ′ | is bounded by a polynomial
in log t plus the size of the largest instance. We set ℓ′ := 2(log t)t · n + (t − 1)n + ℓ. It is easy
to see that this construction can be carried out in polynomial time. The constructed tuple can
serve as an instance of Weighted fvs parameterized by Vertex Cover or Weighted
oct parameterized by Vertex Cover; we will prove that this makes no difference for
the truth value. We therefore conclude the proof by showing that the following conditions are
equivalent:
1. The graph G′ has a feedback vertex set of weight at most ℓ′ .
2. The graph G′ has an odd cycle transversal of weight at most ℓ′ .
3. There is an input i∗ ∈ [t] such that Gi∗ has a vertex cover of size at most ℓ.
Clearly the equivalence of these conditions shows that the construction serves as a crosscomposition of Vertex Cover into both problems, which establishes the kernelization lower
bounds by Corollary 2.
(1⇒2) Any feedback vertex set is also an odd cycle transversal of the same size.
(2⇒3) Assume that G′ has an oct S ′ of total weight at most 2(log t)t · n + (t − 1)n + ℓ. The
graph G′ contains log t vertex-disjoint copies of the graph BK4 . By Observation 2 at least two
vertices are needed to cover all the triangles in BK4 , hence the transversal S ′ contains at least
two vertices from each copy of BK4 . If there is some copy of BK4 from which S ′ contains more
than two vertices, then as each vertex in a copy of BK4 has weight t · n the set S ′ has weight
at least (2(log t) + 1)t · n, which is strictly greater than ℓ′ as ℓ < n. Therefore any oct S ′ of
weight at most ℓ′ contains exactly two vertices from each copy of BK4 . From Observation 2
it then follows that for each copy of BK4 the set S ′ contains either the 0-terminal vertices or
the 1-terminal vertices, as no other pair of vertices can cover all triangles. We now construct
the binary representation of an instance number using the contents of S ′ . Let the j-th bit of the
number be a 1 if set S ′ contains {bj,1′ , bj,1′′ }, and a 0 in the case that it contains {bj,0′ , bj,0′′ };
let i∗ denote the instance number in the range [t] that is represented by this bitstring.
Observe that by the choice of i∗ , for all vertices in V (Gi∗ ) all of their neighbors in the BK4
graphs are contained in S ′ . On the other hand, if we consider some instance number i′ 6= i∗ then
there is at least one bit position where the representations of the numbers i′ and i∗ differ. Let j
24

be such a bit position and assume for the moment that the j-th bit of the number i∗ is a 1, which
implies that the j-th bit of i′ is a 0 (the other case is symmetric). Then S ′ contains the terminal
vertices {bj,1′ , bj,1′′ } but does not contain {bj,0′ , bj,0′′ }. But then S ′ must contain all vertices
from the set V (Gi′ ), for if S ′ would avoid some vertex v ∈ V (Gi′ ) then the graph G′ − S ′
would contain a triangle on vertices {v, bj,0′ , bj,0′′ } which contradicts the assumption that S ′
is an oct. This shows that for all instance numbers i′ 6= i∗ the set S ′ contains all vertices
of V (Gi′ ). These vertices together with the two terminal vertices in each copy of BK4 account
for 2(log t)t · n + (t − 1)n of the weight of S ′ , and therefore the remaining vertices in S ′ have
weight at most ℓ; in particular S ′ contains at most ℓ vertices from the set V (Gi∗ ) ∪ A′ since
each such vertex has weight 1. Choose Si′∗ as S ′ ∩ (V (Gi∗ ) ∪ A′ ); the preceding argument
shows |Si′∗ | ≤ ℓ. Since S ′ is an oct for G′ it breaks all odd cycles in all induced subgraphs,
hence Si′∗ is an oct of G′ [V (Gi∗ ) ∪ A′ ]. During the construction of G′ we already observed that
the graph G′ [V (Gi∗ ) ∪ A′ ] is isomorphic to φ(Gi∗ ), which together with the previous observation
shows that φ(Gi∗ ) has an oct of size at most |Si′∗ | ≤ ℓ. By Lemma 3 this implies that Gi∗
has a vertex cover of size at most ℓ, thereby proving that (Gi∗ , ℓ) is a yes-instance of Vertex
Cover.
(3⇒1) For the reverse direction, assume that one of the input instances, say (Gi∗ , ℓ), is a
yes-instance of Vertex Cover, i.e., that Gi∗ has a vertex cover of size ℓ. By Lemma 3 this
implies that φ(Gi∗ ) has an fvs of size at most ℓ. We construct an fvs S ′ in G′ of weight at
most ℓ′ .
1. For each bit position j ∈ [log t] add {bj,0′ , bj,0′′ } to S ′ if the j-th bit of i∗ is a 0, and
otherwise add {bj,1′ , bj,1′′ }. This contributes a total weight of 2(log t)t · n.
S
2. Add the set i6=i∗ V (Gi ) to S ′ for a total weight addition of (t − 1)n.

3. By the construction of G′ , the graph G′ [V (Gi∗ ) ∪ A′ ] is isomorphic to φ(Gi∗ ), and by assumption this graph has a feedback vertex set of size at most ℓ′ . Add an fvs of G′ [V (Gi∗ )∪
A′ ] of size at most ℓ to S ′ ; as the vertices in this subgraph have a weight of 1 under w′ ,
this increases the weight of S ′ by at most ℓ.

Summing up the weight increases we find that the resulting set S ′ has weight at most ℓ′ . To see
that S ′ indeed intersects all cycles in G′ , observe that by taking two matching terminal vertices
for each copy of BK4 we have broken all cycles within the BK4 graphs. For all sets V (Gi′ )
with i′ 6= i∗ we have taken all the V (Gi′ ) vertices into S ′ so G′ − S ′ cannot contain cycles
through such sets V (Gi′ ). By taking the appropriate terminal vertices in S ′ we have broken all
connections between vertices in V (Gi∗ ) and vertices in copies of BK4 . Finally there can be no
cycles in G′ [V (Gi∗ ) ∪ A′ ] − S ′ since we have added an fvs for this graph to S ′ . Hence S ′ indeed
covers all cycles, and has the desired weight.
Slight variations of the proof of Theorem 10 can be used to show kernel lower bounds
for various other weighted vertex-deletion problems parameterized by vertex cover, such as
Chordal Deletion and Planar Deletion. Observe that the weight function used in the
construction is very simple: it uses only two possible weight values, namely 1 and t · n, both of
which are polynomially bounded in the total input size to the cross-composition algorithm. The
theorem shows that when it comes to weighted problems, even graphs with a simple structure
(i.e., graphs with a small vertex cover) can encode the logical or or many input instances.

5

Conclusions

We have introduced the cross-composition framework and used it to derive kernelization lower
bounds for structural parameterizations of several graph problems. Through its many appli25

cations [7, 8, 14, 15, 16, 17, 19, 31, 36, 38], the framework has already proven itself to be a
fruitful tool in the study of kernelization complexity. The key to many cross-compositions is
choosing a convenient NP-hard source problem. As the examples in Section 4 show, a series of
input graphs (G1 , . . . , Gt ) may be amenable to composition if the vertex set of each graph can
be partitioned into Xi ∪ Yi such that all graphs Gi [Xi ] are isomorphic, and all graphs Gi [Yi ] are
isomorphic. In such settings we may merge the graphs by identifying all subgraphs Gi [Xi ] into
a single canonical copy. Our construction for Chromatic Number employs graphs which decompose into an independent set and disjoint triangles, whereas the inflation φ(G) of a graph G,
which underlies the construction of Theorem 10, can be decomposed into an independent set
and a disjoint union of P2 ’s. The importance of starting from a convenient source problem when
proving kernel lower bounds can also be observed in the recent work of Dell and Marx [20] and
Cygan et al. [16].
Two recent papers [39, 40] extend the cross-composition framework by the use of conondeterministic (cross-)compositions. The full version of [39] contains the natural variant
of defining a co-nondeterministic or-cross-composition and a formal proof for the fact that it
excludes polynomial kernels and compressions when the dependence on t is at most f (t) = to(1) ;
the same follows immediately regarding polynomial lower bounds when f (t) = t1/d+o(1) . Note
that a similar result for and-cross-compositions is highly unlikely; it is an easy exercise to construct a co-nondeterministic and-cross-composition for any language. Furthermore, Kratsch et
al. [40] point out that or-cross-compositions do not need NP-hard source problems, but that
NP-hardness under co-nondeterministic many-one reductions suffices. To see this, note that the
consequence of a cross-composition for L ⊆ Σ∗ into Q ⊆ Σ∗ × N together with a polynomial kernel or compression for Q implies L ∈ coNP/poly. If L is (only) NP-hard under coNP-many-one
reductions then this still implies NP ⊆ coNP/poly. (This of course holds for any lower bound
technique that produces the consequence that L ∈ coNP/poly.)
We hope to see many applications of cross-composition in the future.
Acknowledgments. We would like to thank Holger Dell for insightful discussions.

