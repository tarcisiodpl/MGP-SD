GROUP ACTIVITY SELECTION PROBLEM

arXiv:1401.8151v1 [cs.GT] 31 Jan 2014

ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 ,
AND GERHARD WOEGINGER5

A BSTRACT. We consider a setting where one has to organize one or several group activities for a set of agents. Each agent will participate in at most one activity, and her
preferences over activities depend on the number of participants in the activity. The goal
is to assign agents to activities based on their preferences. We put forward a general model
for this setting, which is a natural generalization of anonymous hedonic games. We then
focus on a special case of our model, where agents’ preferences are binary, i.e., each agent
classifies all pairs of the form ”(activity, group size)” into ones that are acceptable and
ones that are not. We formulate several solution concepts for this scenario, and study them
from the computational point of view, providing hardness results for the general case as
well as efficient algorithms for settings where agents’ preferences satisfy certain natural
constraints.

1. I NTRODUCTION
There are many real-life situations where a group of agents is faced with a choice of
multiple activities, and the members of the group have differing preferences over these
activities. Sometimes it is feasible for the group to split into smaller subgroups, so that
each subgroup can pursue its own activity. Consider, for instance, a workshop whose
organizers would like to arrange one or more social activities for the free afternoon.1 The
available activities include a hike, a bus trip, and a table tennis competition. As they will
take place simultaneously, each attendee can select at most one activity (or choose not to
participate). It is easy enough to elicit the attendees’ preferences over the activities, and
divide the attendees into groups based on their choices. However, the situation becomes
more complicated if one’s preferences may depend on the number of other attendees who
choose the same activity. For instance, the bus trip has a fixed transportation cost that has to
be shared among its participants, which implies that, typically, an attendee i is only willing
to go on the bus trip if the number of other participants of the bus trip exceeds a threshold
ℓi . Similarly, i may only be willing to play table tennis if the number of attendees who
signed up for the tournament does not exceed a threshold ui : as there is only one table, the
more participants, the less time each individual spends playing.
Neglecting to take the number of participants of each activity into account may lead to
highly undesirable outcomes, such as a bus that is shared by two persons, each of them
paying a high cost, and a 48-participant table tennis tournament with one table. Adding
constraints on the number of participants for each activity is a practical, but imperfect
solution, as the agents’ preferences over group sizes may differ: while some attendees
(say, senior faculty) may be willing to go on the bus trip with just 4–5 other participants,
others (say, graduate students) cannot afford it unless the number of participants exceeds
10. A more fine-grained approach is to elicit the agents’ preferences over pairs of the
form “(activity, group size)”, rather than over activities themselves, and allocate agents to
1

Some of the co-authors of this paper had to deal with this problem when co-organizing a Dagstuhl seminar.
1

2ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5

activities based on this information. In general, agents’ preferences can be thought of as
weak orders over all such pairs, including the pair “(do nothing, 1)”, which we will refer to
as the void activity. A simpler model, which will be the main focus of this paper, assumes
that each agents classifies all pairs into ones that are acceptable to him and ones that are not,
and if an agent views his current assignment as unacceptable, he prefers (and is allowed)
to switch to the void activity (so the assignment is unstable unless it is acceptable to all
agents).
The problem of finding a good assignment of agents to activities, which we will refer to as the Group Activity Selection Problem (GASP), may be viewed as a mechanism
design problem (or, more narrowly, a voting problem) or as a coalition formation problem, depending on whether we expect the agents to act strategically when reporting their
preferences. Arguably, in our motivating example the agents are likely to be honest, so
throughout the paper we assume that the central authority knows (or, rather, can reliably
elicit) the agents’ true preferences, and its goal is to find an assignment of players to activities that, informally speaking, is stable and/or maximizes the overall satisfaction. This
model is closely related to that of anonymous hedonic games [3], where, just as in our setting, players have to split into groups and each player has preferences over possible group
sizes. The main difference between anonymous hedonic games and our problem is that,
in our setting, the agents’ preferences depend not only on the group size, but also on the
activity that has been allocated to their group; thus, our model can be seen as a generalization of anonymous hedonic games. On the other hand, we can represent our problem
as a general (i.e., non-anonymous) hedonic game [4, 3], by creating a dummy agent for
each activity and endowing it with suitable preferences (see Section 2.2 for details). However, our setting has useful structural properties that distinguish it from a generic hedonic
game: for instance, it allows for succinct representation of players’ preferences, and, as we
will see, has several natural special cases that admit efficient algorithms for finding good
outcomes.
In this paper, we initiate the formal study of GASP. Our goal is to put forward a model
for this problem that is expressive enough to capture many real-life activity selection scenarios, yet simple enough to admit efficient procedures for finding good assignments of
agents to activities. We describe the basic structure of the problem, and discuss plausible constraints of the number and type of available activities and the structure of agents’
preferences. We show that even under a fairly simple preference model (where agents are
assumed to approve or disapprove each available alternative) finding an assignment that
maximizes the number of satisfied agents is computationally hard; however, we identify
several natural special cases of the problem that admit efficient algorithms. We also briefly
discuss the issue of stability in our setting.
We do not aim to provide a complete analysis of the group activity selection problem;
rather, we view our work as a first step towards understanding the algorithmic and incentive
issues that arise in this setting. We hope that our paper will lead to future research on this
topic; to facilitate this, throughout the paper we highlight several possible extensions of
our model as well as list some problems left open by our work.
2. F ORMAL M ODEL
Definition 2.1. An instance of the Group Activity Selection Problem (GASP) is given by a
set of agents N = {1, . . . , n}, a set of activities A = A∗ ∪{a∅ }, where A∗ = {a1 , . . . , ap },
and a profile P , which consists of n votes (one for each agent): P = (V1 , . . . , Vn ). The
vote of agent i describes his preferences over the set of alternatives X = X ∗ ∪ {a∅ }, where

GROUP ACTIVITY SELECTION PROBLEM

3

X ∗ = A∗ × {1, . . . , n}; alternative (a, k), a ∈ A∗ , is interpreted as “activity a with k
participants”, and a∅ is the void activity.
The vote Vi of an agent i ∈ N is (also denoted by i ) is a weak order over X ∗ ; its
induced strict preference and indifference relations are denoted by ≻i and ∼i , respectively.
We set Si = {(a, k) ∈ X ∗ | (a, k) ≻i a∅ }; we say that voter i approves of all alternatives
in Si , and refer to the set Si as the induced approval vote of voter i.
Throughout the paper we will mostly focus on a special case of our problem where
no agent is indifferent between the void activity and any other alternative (i.e., for any
i ∈ N we have {x ∈ X ∗ | x ∼i a∅ } = ∅), and each agent is indifferent between all the
alternatives in Si . In other words, preferences are trichotomous: the agent partitions X
into three clusters Si , {a∅ } and X \ (Si ∪ {a∅ }), is indifferent between two alternatives of
the same cluster, prefers any (a, k) in Si to a∅ , and a∅ to any (a, k) in X \ (Si ∪ {a∅ });
we denote this special case of our problem by a-GASP.
It will be convenient to distinguish between activities that are unique and ones that exist
in multiple copies. For instance, if there is a single tennis table and two buses, then we
can organize one table tennis tournament, two bus trips (we assume that there is only one
potential destination for the bus trip, so these trips are identical), and an unlimited number
of hikes (again, we assume that there is only one hiking route). This distinction will be
useful for the purposes of complexity analysis: for instance, some of the problems we
consider are easy when we have k copies of one activity, but hard when we have k distinct
activities. Formally, we say that two activities a and b are equivalent if for every agent i
and every j ∈ {1, . . . , n} it holds that (a, j) ∼i (b, j). We say that an activity a ∈ A∗ is
k-copyable if A∗ contains exactly k activities that are equivalent to a (including a itself).
We say that a is simple if it is 1-copyable; if a is k-copyable for k ≥ n, we will say that
it is ∞-copyable (note that we would never need to organize more than n copies of any
activity). If some activities in A∗ are equivalent, A∗ can be represented more succinctly by
listing one representative of each equivalence class, together with the number of available
copies. However, as long as we make the reasonable assumption that each activity exists
in at most n copies, this representation is at most polynomially more succinct.
Our model can be enriched by specifying a set of constraints Γ. One constraint that
arises frequently in practice is a global cardinality constraint, which specifies a bound K
on the number of activities to be organized. More generally, we could also consider more
complex constraints on the set of activities that can be organized simultaneously, which can
be encoded, e.g., by a propositional formula or a set of linear inequalities. We remark that
there can also be external constraints on the number of participants for each activity: for
instance, a bus can fit at most 40 people. However, these constraints can be incorporated
into agents’ preferences, by assuming that all agents view the alternatives that do not satisfy
these constraints as unacceptable.
2.1. Special Cases. We now consider some natural restrictions on agents’ preferences that
may simplify the problem of finding a good assignment. We first need to introduce some
additional notation. Given a vote Vi and an activity a ∈ A∗ , let Si↓a denote the projection
of Si onto {a} × {1, . . . , n}. That is, we set Si↓a = {k | (a, k) ∈ Si }.

Example 2.2. Let A∗ = {a, b} and consider an agent i whose vote Vi is given by
(a, 8) ≻i (a, 7) ∼i (b, 4) ≻i (a, 9) ≻i (b, 3) ≻i (b, 5) ≻i (a, 6) ≻i (b, 6) ≻i a∅ ≻i . . .
Then Si = {a} × [6, 9] ∪ {b} × [3, 6] and Si↓a = {6, 7, 8, 9}.

We are now ready to define two types of restricted preferences for a-GASP that are
directly motivated by our running example, namely, increasing and decreasing preferences.

4ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5

Informally, under increasing preferences an agent prefers to share each activity with as
many other participants as possible (e.g., because each activity has an associated cost,
which has to be split among the participants), and under decreasing preferences an agent
prefers to share each activity with as few other participants as possible (e.g., because each
activity involves sharing a limited resource). Of course, an agent’s preferences may also be
increasing with respect to some activities and decreasing with respect to others, depending
on the nature of each activity. We provide a formal definition for a-GASP only; however,
it can be extended to GASP in a straightforward way.
Definition 2.3. Consider an instance (N, A, P ) of a-GASP. We say that the preferences
of agent i are increasing (INC) with respect to an activity a ∈ A∗ if there exists a threshold
ℓai ∈ {1, . . . , n + 1} such that Si↓a = [ℓai , n] (where we assume that [n + 1, n] = ∅).
Similarly, we say that the preferences of agent i are decreasing (DEC) with respect to an
activity a ∈ A∗ if there exists a threshold uai ∈ {0, . . . , n} such that Si↓a = [1, uai ] (where
we assume that [1, 0] = ∅).
We say that an instance (N, A, P ) of a-GASP is increasing (respectively, decreasing) if
the preferences of each agent i ∈ N are increasing (respectively, decreasing) with respect
to each activity a ∈ A∗ . We say that an instance (N, A, P ) of a-GASP is mixed increasingdecreasing (MIX) if there exists a set A+ ⊆ A∗ such that for each agent i ∈ N his
preferences are increasing with respect to each a ∈ A+ and decreasing with respect to
each a ∈ A− = A∗ \ A+ .
A recently proposed model which can be embedded into GASP with decreasing preferences is the ordinal version of cooperative group buying ([7], Section 6): the model has a
set of buyers and a set of items with volume discounts; buyers rank all pairs (j, pj ) for any
item j and any of its possible discounted prices, where the discounted price is a function
of the number of buyers who are matched to the item.
For some activities, an agent may have both a lower and an upper bound on the acceptable group size: e.g., one may prefer to go on a hike with at least 3 other people, but does
not want the group to be too large (so that it can maintain a good pace). In this case, we
say that an agent has interval (INV) preferences; note that INC/DEC/MIX preferences are
a special case of interval preferences.
Definition 2.4. Consider an instance (N, A, P ) of a-GASP. We say that the preferences
of agent i are interval (INV) if for each a ∈ A∗ there exists a pair of thresholds ℓai , uai ∈
{1, . . . , n} such that Si↓a = [ℓai , uai ] (where we assume that [i, j] = ∅ for i > j).
Other natural constraints on preferences include restricting the size of Si (or, more
liberally, that of Si↓a for each a ∈ A∗ ), or requiring agents to have similar preferences:
for instance, one could limit the number of agent types, i.e., require that the set of agents
can be split into a small number of groups so that the agents in each group have identical
preferences. We will not define such constraints formally, but we will indicate if they are
satisfied by the instances constructed in the hardness proofs in Section 4.1.
2.2. GASP and Hedonic Games. Recall that a hedonic game [3, 4] is given by a set of
agents N , and, for each agent i ∈ N , a weak order ≥i over all coalitions (i.e., subsets of
N ) that include i. That is, in a hedonic game each agent has preferences over coalitions
that he can be a part of. A coalition S, i ∈ S, is said to be unacceptable for player i if
{i} >i S. A hedonic game is said to be anonymous if each agent is indifferent among all
coalitions of the same size that include him, i.e., for every i ∈ N and every S, T ⊆ N \ {i}
such that |S| = |T | it holds that S ∪ {i} ≥i T ∪ {i} and T ∪ {i} ≥i S ∪ {i}.

GROUP ACTIVITY SELECTION PROBLEM

5

At a first glance, it may seem that the GASP formalism is more general than that of
hedonic games, since in GASP the agents care not only about their coalition, but also
about the activity they have been assigned to. However, we will now argue that GASP can
be embedded into the hedonic games framework.
Given an instance of the GASP problem (N, A, P ) with |N | = n, where the i-th agent’s
preferences are given by a weak order i , we construct a hedonic game H(N, A, P ) as
follows. We create n + p players; the first n players correspond to agents in N , and the
last p players correspond to activities in A∗ . The last p players are indifferent among all
coalitions. For each i = 1, . . . , n, player i ranks every non-singleton coalition with no
activity players as unacceptable; similarly, all coalitions with two or more activity players
are ranked as unacceptable. The preferences over coalitions with exactly one activity player
are derived naturally from the votes: if S, T are two coalitions involving player i, x is the
unique activity player in S, and y is the unique activity player in T , then i weakly prefers
S to T in H(N, A, P ) if and only if (x, |S| − 1) i (y, |T | − 1), and i weakly prefers S
to {i} in H(N, A, P ) if and only if (x, |S| − 1) i a∅ . We emphasize that the resulting
hedonic games are not anonymous. Further, while this embedding allows us to apply the
standard solution concepts for hedonic games without redefining them, the intuition behind
these solution concepts is not always preserved (e.g., because activity players never want
to deviate). Therefore, in Section 3, we will provide formal definitions of the relevant
hedonic games solution concepts adapted to the setting of a-GASP.
We remark that when A∗ consists of a single ∞-copyable activity (i.e., there are n activities in A∗ , all of them equivalent to each other), GASP become equivalent to anonymous
hedonic games. Such games have been studied in detail by Ballester [2], who provides a
number of complexity results for them. In particular, he shows that finding an outcome
that is core stable, Nash stable or individually stable (see Section 3 for the definitions of
some of these concepts in the context of a-GASP) is NP-hard. Clearly, all these complexity
results also hold for GASP. However, they do not directly imply similar hardness results
for a-GASP.
3. S OLUTION C ONCEPTS
Having discussed the basic model of GASP, as well as a few of its extensions and special
cases, we are ready to define what constitutes a solution to this problem.
Definition 3.1. An assignment for an instance (N, A, P ) of GASP is a mapping π : N →
A; π(i) = a∅ means that agent i does not participate in any activity. Each assignment
naturally partitions the agents into at most |A| groups: we set π 0 = {i | π(i) = a∅ } and
π j = {i | π(i) = aj } for j = 1, . . . , p. Given an assignment π, the coalition structure
CS π induced by π is the coalition structure over N defined as follows:


CS π = π j | j = 1, . . . , p, π j 6= ∅ ∪ {i} | i ∈ π 0 .
Clearly, not all assignments are equally desirable. As a minimum requirement, no agent
should be assigned to a coalition that he deems unacceptable. More generally, we prefer
an assignment to be stable, i.e., no agent (or group of agents) should have an incentive
to change its activity. Thus, we will now define several solution concepts, i.e., classes of
desirable assignments. We will state our definitions for a-GASP only, though all of them
can be extended to the more general case of GASP in a natural way. Given the connection
to hedonic games pointed out in Section 2.2, we will proceed by adapting the standard
hedonic game solution concepts to our setting; however, this has to be done carefully to
preserve intuition that is specific to our model.

6ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5

The first solution concept that we will consider is individual rationality.
Definition 3.2. Given an instance (N, A, P ) of a-GASP, an assignment π : N → A is
said to be individually rational if for every j > 0 and every agent i ∈ π j it holds that
(aj , |π j |) ∈ Si .
Clearly, if an assignment is not individually rational, there exists an agent that can benefit from abandoning his coalition in favor of the void activity. Further, an individually
rational assignment always exists: for instance, we can set π(i) = a∅ for all i ∈ N . However, a benevolent central authority would usually want to maximize the number of agents
that are assigned to non-void activities. Formally, let #(π) = |{i | π(i) 6= a∅ }| denote the
number of agents assigned to a non-void activity. We say that π is maximum individually
rational if π is individually rational and #(π) ≥ #(π ′ ) for every individually rational
assignment π ′ . Further, we say that π is perfect2 if #(π) = n. We denote the size of a
maximum individually rational assignment for an instance (N, A, P ) by #(N, A, P ). In
Section 4, we study the complexity of computing a perfect or maximum individually rational assignment for a-GASP, both for the general model and for the special cases defined in
Section 2.1.
Besides individual rationality, there are a number of solution concepts for hedonic
games that aim to capture stability against individual or group deviations, such as Nash
stability, individual stability, contractual individual stability, and (weak and strong) core
stability (see, e.g., [5]). In what follows, due to lack of space, we only provide the formal definition (and some results) for Nash stability. We briefly discuss how to adapt other
notions of stability to our setting, but we leave the detailed study of their algorithmic properties as a topic for future work.
Definition 3.3. Given an instance (N, A, P ) of a-GASP, an assignment π : N → A is
said to be Nash stable if it is individually rational and for every agent i ∈ N such that
π(i) = a∅ and every aj ∈ A∗ it holds that (aj , |π j | + 1) 6∈ Si .
If π is not Nash stable, then there is an agent assigned to the void activity who wants to
join a group that is engaged in a non-void activity, i.e., he would have approved of the size
of this group and its activity choice if he was one of them. Note that a perfect assignment is
Nash stable. The reader can verify that our definition is a direct adaptation of the notion of
Nash stability in hedonic games: if an assignment is individually rational, the only agents
who can profitably deviate are the ones assigned to the void activity. The requirement of
Nash stability is much stronger than that of individual rationality, and there are cases where
a Nash stable assignment does not exist (the proof is omitted due to space limits).
Proposition 3.4. For each n ≥ 2, there exists an instance (N, A, P ) of a-GASP with
|N | = n that does not admit a Nash stable assignment. This holds even if |A∗ | = 1 and all
agents have interval preferences.
In Definition 3.3 an agent is allowed to join a coalition even if the members of this
coalition are opposed to this. In contrast, the notion of individual stability only allows a
player to join a group if none of the existing group members objects. We remark that if all
agents have increasing preferences, individual stability is equivalent to Nash stability: no
group of players would object to having new members join.
2The terminological similarity with the notion of perfect partition in a hedonic game [1] is not a coincidence;

there a perfect partition assigns each agent to her preferred coalition; here a perfect assignment assigns each
agent to one of her equally preferred alternatives.

GROUP ACTIVITY SELECTION PROBLEM

7

A related hedonic games solution concept is contractual individual stability: under this
concept, an agent is only allowed to move from one coalition to another if neither the
members of his new coalition nor the members of his old coalition object to the move.
However, for a-GASP contractual individual stability is equivalent to individual stability.
Indeed, in our model no agent assigned to a non-void activity has an incentive to deviate,
so we only need to consider deviations from singleton coalitions.
The solution concepts discussed so far deal with individual deviations; resistance to
group deviations is captured by the notion of the core. One typically distinguishes between
strong group deviations, which are beneficial for each member of the deviating group, and
weak group deviations, where the deviation should be beneficial for at least one member
of the deviating group and non-harmful for others; these notions of deviation correspond
to, respectively, weak and strong core. We note that in the context of a-GASP strong group
deviations amount to players in π 0 forming a coalition in order to engage in a non-void
activity. This observation immediately implies that every instance of a-GASP has a nonempty weak core, and an outcome in the weak core can be constructed by a natural greedy
algorithm; we omit the details due to space constraints.
4. C OMPUTING G OOD O UTCOMES
In this section, we consider the computational complexity of finding a “good” assignment for a-GASP. We mostly focus on finding perfect or maximum individually rational
assignments; towards the end of the section, we also consider Nash stability. Besides the
general case of our problem, we consider special cases obtained by combining constraints
on the number and type of activities (e.g., unlimited number of simple activities, a constant
number of copyable activities, etc.) and constraints on voters’ preferences (INC, DEC,
INV, etc.). Note that if we can find a maximum individually rational assignment, we can
easily check if a perfect assignment exists, by looking at the size of our maximum individually rational assignment. Thus, we will state our hardness results for the “easier” perfect
assignment problem and phrase our polynomial-time algorithms in terms of the “harder”
problem of finding a maximum individually rational assignment.
4.1. Individual Rationality: Hardness Results. We start by presenting four NP-completeness
results, which show that finding a perfect assignment is hard even under fairly strong constraints on preferences and activities. We remark that this problem is obviously in NP, so
in what follows we will only provide the hardness proofs.
Our first hardness result applies when all activities are simple and the agents’ preferences are increasing.
Theorem 4.1. It is NP-complete to decide whether a-GASP admits a perfect assignment,
even when all activities in A∗ are simple and all agents have increasing preferences.
sketch. We provide a reduction from E XACT C OVER BY 3-S ETS (X3C). Recall that an
instance of X3C is a pair hX, Yi, where X = {1, . . . , 3q} and Y = {Y1 , . . . , Yp } is
a collection of 3-element subsets of X; it is a “yes”-instance if X can be covered by
exactly q sets from Y, and a “no”-instance otherwise. Given an instance hX, Yi of X3C,
we construct an instance of a-GASP as follows. We set N = {1, . . . , 3q} and A∗ =
{a1 , . . . , ap }. For each agent i, we define his vote Vi so that the induced approval vote Si
is given by Si = {(aj , k) | i ∈ Yj , k ≥ 3}, and let P = (V1 , . . . , Vn ). Clearly, (N, A, P )
is an instance of a-GASP with increasing preferences. It is not hard to check that hX, Yi
is a “yes”-instance of X3C if and only if (N, A, P ) admits a perfect assignment.  

8ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5

Our second hardness result applies to simple activities and decreasing preferences, and
holds even if each agent is willing to share each activity with at most one other agent.
Theorem 4.2. It is NP-complete to decide whether a-GASP admits a perfect assignment,
even when all activities in A∗ are simple, all agents have decreasing preferences, and,
moreover, for every agent i ∈ N and every alternative a ∈ A∗ we have Si↓a ⊆ {1, 2}.
sketch. Consider the following restricted variant of the problem of scheduling on unrelated
machines. There are n jobs and p machines. An instance of the problem is given by a
collection of numbers {pij | i = 1, . . . , n, j = 1, . . . , p}, where pij is the running time of
job i on machine j, and pij ∈ {1, 2, +∞} for every i = 1, . . . , n and every j = 1, . . . , p.
It is a “yes”-instance if there is a mapping ρ : {1, . . . , n} → {1, . . . , p} assigning jobs
to machines so that the makespan is at most 2, i.e., for each j = 1, . . . , p it holds that
P
i:ρ(i)=j pij ≤ 2. This problem is known to be NP-hard (see the proof of Theorem 5
in [6]).
Given an instance {pij | i = 1, . . . , n, j = 1, . . . , p} of this problem, we construct an
instance of a-GASP as follows. We set N = {1, . . . , n}, A∗ = {a1 , . . . , ap }. Further,
for each agent i ∈ N we construct a vote Vi so that the induced approval vote Si satisfies
↓a
↓a
↓a
Si j = {1} if pij = 2, Si j = {1, 2} if pij = 1, and Si j = ∅ if pij = +∞. Clearly,
these preferences satisfy the constraints in the statement of the theorem, and it can be
shown that a perfect assignment for (N, A, P ) corresponds to a schedule with makespan
of at most 2, and vice versa.


Our third hardness result also concerns simple activities and decreasing preferences.
However, unlike Theorem 4.2, it holds even if each agent approves of at most 3 activities.
The proof proceeds by a reduction from M ONOTONE 3-SAT.
Theorem 4.3. It is NP-complete to decide whether a-GASP admits a perfect assignment,
even when all activities in A∗ are simple, all agents have decreasing preferences, and,
moreover, for every agent i ∈ N it holds that |{a | Si↓a 6= ∅}| ≤ 3.
Our fourth hardness result applies even when there is only one activity, which is ∞copyable, and every agent approves at most two alternatives; however, the agents’ preferences constructed in our proof do not satisfy any of the structural constraints defined in
Section 2.1. The proof proceeds by a reduction from X3C.
Theorem 4.4. It is NP-complete to decide whether a-GASP admits a perfect assignment,
even when all activities in A∗ are equivalent (i.e., A∗ consists of a single ∞-copyable
activity a) and for every i ∈ N we have |Si↓a | ≤ 2.
4.2. Individual Rationality: Easiness Results. The hardness results in Section 4.1 imply that if A∗ contains an unbounded number of distinct activities, finding a maximum
individually rational assignment is computationally hard, even under strong restrictions on
agents’ preferences (such as INC or DEC). Thus, we can only hope to develop an efficient
algorithm for this problem if we assume that the total number of activities is small (i.e.,
bounded by a constant) or, more liberally, that the number of pairwise non-equivalent activities is small, and the agents’ preferences satisfy additional constraints. We will now
consider both of these settings, starting with the case where p = |A∗ | is bounded by a
constant.
Theorem 4.5. There exist an algorithm that given an instance of a-GASP finds a maximum
individually rational assignment and runs in time (n + 1)p poly(n).

GROUP ACTIVITY SELECTION PROBLEM

9

Proof. We will check, for each r = 0, . . . , n, if there is an individually rational assignment
π with #(π) = r, and output the maximum value of r for which this is the case. Fix an
r ∈ {0, . . . , n}. For every vector (n1 , . . . , np ) ∈ {0, . . . , n}p that satisfies n1 + · · · + np =
r we will check if there exists an assignment of agents to activities such that for each
j = 1, . . . , p exactly nj agents are assigned to activity aj (with the remaining agents being
assigned to the void activity), and each agent approves of the resulting assignment. Each
check will take poly(n) steps, and there are at most (n + 1)p vectors to be checked; this
implies our bound on the running time of our algorithm.
For a fixed vector (n1 , . . . , np ), we construct an instance of the network flow problem
as follows. Our network has a source s, a sink t, a node i for each player i = 1, . . . , n, and
a node aj for each aj ∈ A∗ . There is an arc of unit capacity from s to each agent, and an
arc of capacity nj from node aj to the sink. Further, there is an arc of unit capacity from
i to aj if and only if (aj , nj ) ∈ Si . It is not hard to see that an integral flow F of size r
in this network corresponds to an individually rational assignment of size r. It remains to
observe that it can be checked in polynomial time whether a given network admits a flow
of a given size.


Moreover, when A∗ consists of a single simple activity a, a maximum individually
rational assignment can be found by a straightforward greedy algorithm.
Proposition 4.6. Given an instance (N, A, P ) of a-GASP with A∗ = {a}, we can find
a maximum individually rational assignment for (N, A, P ) in time O(s log s), where s =
P
i∈N |Si |.
Proof. Clearly, (N, A, P ) admits an individually rational assignment π with #(π) = k if
and only if | {i | (a, k) ∈ Si } | ≥ k. Let R = {(i, k) | (a, k) ∈ Si }; note that |R| = s.
We can sort the elements of R in descending order with respect to their second coordinate
in time O(s log s). Now we can scan R left to right in order to find the largest value of k
such that R contains at least k pairs that have k as their second coordinate; this requires a
single pass through the sorted list.


Now, suppose that A∗ contains many activities, but most of them are equivalent to each
other; for instance, A∗ may consist of a single k-copyable activity, for a large value of
k. Then the algorithm described in the proof of Theorem 4.5 is no longer efficient, but
this setting still appears to be more tractable than the one with many distinct activities.
Of course, by Theorem 4.4, in the absence of any restrictions on the agents’ preferences,
finding a maximum individually rational assignment is hard even for a single ∞-copyable
activity. However, we will now show that this problem becomes easy if we additionally
assume that the agents’ preferences are increasing or decreasing.
Observe first that for increasing preferences having multiple copies of the same activity
is not useful: if there is an individually rational assignment where agents are assigned to
multiple copies of an activity, we can reassign these agents to a single copy of this activity
without violating individual rationality. Thus, we obtain the following easy corollary to
Theorem 4.5.
Corollary 4.7. Let (N, A, P ) be an instance of a-GASP with increasing preferences where
A∗ contains at most K activities that are not pairwise equivalent. Then we can find a
maximum individually rational assignment for (N, A, P ) in time nK poly(n).
If all preferences are decreasing, we can simply eliminate all ∞-copyable activities.
Indeed, consider an instance (N, A, P ) of a-GASP where some activity a ∈ A∗ is ∞copyable. Then we can assign each agent i ∈ N such that (a, 1) ∈ Si to his own copy

10
ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5

of a; clearly, this will only simplify the problem of assigning the remaining agents to the
activities.
It remains to consider the case where the agents’ preferences are decreasing, there is
a limited number of copies of each activity, and the number of distinct activities is small.
While we do not have a complete solution for this case, we can show that in the case of
a single k-copyable activity a natural greedy algorithm succeeds in finding a maximum
individually rational assignment.
Theorem 4.8. Given a decreasing instance (N, A, P ) of a-GASP where A∗ consists of a
single k-copyable activity (i.e., A∗ = {a1 , . . . , ak }, and all activities in A∗ are pairwise
equivalent), we can find a maximum individually rational assignment in time O(n log n).
Proof. Since all activities in A∗ are pairwise equivalent, we can associate each agent i ∈ N
with a single number ui ∈ {0, . . . , n}, which is the maximum size of a coalition assigned
to a non-void activity that he is willing to be a part of. We will show that our problem can
be solved by a simple greedy algorithm. Specifically, we sort the agents in non-increasing
order of ui s. From now on, we will assume without loss of generality that u1 ≥ · · · ≥ un .
To form the first group, we find the largest value of i such that ui ≥ i, and assign agents
1, . . . , i to the first copy of the activity. In other words, we continue adding agents to the
group as long as the agents are happy to join. We repeat this procedure with the remaining
agents until either k groups have been formed or all agents have been assigned to one of
the groups, whichever happens earlier.
Clearly, the sorting step is the bottleneck of this procedure, so the running time of
our algorithm is O(n log n). It remains to argue that it produces a maximum individually
rational assignment. To show this, we start with an arbitrary maximum individually rational
assignment π and transform it into the one produced by our algorithm without lowering the
number of agents that have been assigned to a non-void activity. We will assume without
loss of generality that π assigns all k copies of the activity (even though this is is not
necessarily the case for the greedy algorithm).
First, suppose that π(i) = a∅ , π(j) = aℓ for some i < j and some ℓ ∈ {1, . . . , k}.
Then we can modify π by setting π(i) = aℓ , π(j) = a∅ . Since i < j implies ui ≥ uj ,
the modified assignment is individually rational. By applying this operation repeatedly, we
can assume that the set of agents assigned to a non-void activity forms a contiguous prefix
of 1, . . . , n.
Next, we will ensure that for each ℓ = 1, . . . , k the group of agents that are assigned to
aℓ forms a contiguous subsequence of 1, . . . , n. To this end, let us sort the coalitions in π
according to their size, from the largest to the smallest, breaking ties arbitrarily. That is,
we reassign the k copies of our activity to coalitions in π so that ℓ < r implies |π ℓ | ≥ |π r |.
Now, suppose that there exist a pair of players i, j such that i < j, π(i) = aℓ , π(j) = ar ,
and ℓ > r (and hence |π ℓ | ≤ |π r |). We have uj ≥ |π r | ≥ |π ℓ |, ui ≥ uj ≥ |π r |, so if we
swap i and j (i.e., modify π by setting π(j) = aℓ , π(i) = ar ), the resulting assignment
remains individually rational. Observe that every such swap increases the quantity Σ =
Pk P
t=1
s∈π t (s · t) by at least 1: prior to the swap, the contribution of i and j to Σ is
iℓ + jr, ans after the swap it is ir + jℓ > iℓ + jr. Since for any assignment we have
Σ ≤ kn(n + 1)/2, eventually we arrive to an assignment where no such pair (i, j) exists.
At this point, each π ℓ , ℓ = 1, . . . , k, forms a contiguous subsequence of 1, . . . , n, and,
moreover, ℓ < r implies i ≤ j for all i ∈ π ℓ , j ∈ π r .
Now, consider the smallest value of ℓ such that π ℓ differs from the ℓ-th coalition constructed by the greedy algorithm (let us denote it by γ ℓ ), and let i be the first agent in π ℓ+1 .
The description of the greedy algorithm implies that π ℓ is a strict subset of γ ℓ and agent

GROUP ACTIVITY SELECTION PROBLEM

11

i belongs to γ ℓ . Thus, if we modify π by moving agent i to π ℓ , the resulting allocation
remains individually rational (since i is happy in γ ℓ ). By repeating this step, we will gradually transform π into the output of the greedy algorithm (possibly discarding some copies
of the activity). This completes the proof.


The algorithm described in the proof of Theorem 4.8 can be extended to the case where
we have one k-copyable activity a and one simple activity b, and the agents have decreasing
preferences over both activities. For each s = 1, . . . , n we will look for the best solution
in which s players are assigned to b; we will then pick the best of these n solutions. For
a fixed s let Ns = {i ∈ N | (b, s) ∈ Si }. If |Ns | < s, no solution for this value of s
exists. Otherwise, we have to decide which size-s subset of Ns to assign to b. It is not hard
to see that we should simply pick the agents in Ns that have the lowest level of tolerance
for a, i.e., we order the agents in Ns by the values of uai from the smallest to the largest,
and pick the first s agents. We then assign the remaining agents to copies of a using the
algorithm from the proof of Theorem 4.8. Indeed, any assignment can be transformed into
one of this form by swapping agents so that the individual rationality constraints are not
broken. It would be interesting to see if this idea can be extended to the case where instead
of a single simple activity b we have a constant number of simple activities or a single
k ′ -copyable activity.
√
We conclude this section by giving an O( n)-approximation algorithm for finding a
maximum individually rational assignment in a-GASP with a single ∞-copyable activity.
Theorem 4.9. There exists a polynomial-time algorithm that given an instance (N, A, P )
of a-GASP where A∗ consists of a single ∞-copyable activity a, outputs an individually
rational assignment π with #(π) = Θ( √1n )#(N, A, P ).
Proof. We say that an agent i is active in π if π(i) 6= a∅ ; a coalition of agents is said
to be active if it is assigned to a single copy of a. We construct an individually rational
assignment π iteratively, starting from the assignment where no agent is active. Let N ∗ =
{i | π(i) = a∅ } be the current set of inactive agents (initially, we set N ∗ = N ). At
each step, we find the largest subset of N ∗ that can be assigned to a single fresh copy of
a without breaking the individual rationality constraints, and append this assignment to π.
We repeat this step until the inactive agents cannot form another coalition.
Now we compare the number of active agents in π with the number of active agents
in a maximum individually rational assignment π ∗ . To this end, let √
us denote the active
coalitions of π by B1 , . . . , Bs , where |B1 | ≥ . . . ≥ |Bs |. If |B1 | ≥ n, we are done, so
assume√that this is not the case. Note that since B1 was chosen greedily, this implies that
|C| ≤ n for every active coalition C in π ∗ .
Let C be the set of active coalitions in π ∗ . We partition C into s groups by setting
1
C = {C ∈ C | C ∩ B1 6= ∅} and C i = {C ∈ C | C ∩ Bi 6= ∅, C 6∈ C j for j < i}
for i = 2, . . . , s. Note that every active coalition C ∈ π ∗ intersects some coalition in π:
otherwise we could add C to π. Therefore, each active coalition in π ∗ belongs to one of the
sets C 1 , . . . , C s . Also, by construction, the sets C 1 , . . . , C s are pairwise disjoint. Further,
since the coalitions in C i are pairwise disjoint and each of them intersects Bi , we have
|C i | ≤ |Bi | for each i = 1, . . . , s. Thus, we obtain
X X
X X √
#(π ∗ ) =
|C| ≤
n
i=1,...,s C∈C i

≤

X
i=1,...,s

i=1,...,s C∈C i

X
√
√
√
|C | n ≤
|Bi | n ≤ #(π) n.
i

i=1,...,s



12
ANDREAS DARMANN1 , EDITH ELKIND2 , SASCHA KURZ3 , JÉRÔME LANG4 , JOACHIM SCHAUER1 , AND GERHARD WOEGINGER5


4.3. Nash Stability. We have shown that a-GASP does not not always admit a Nash stable
assignment (Proposition 3.4). In fact, it is difficult to determine whether a Nash stable
assignment exists. The proofs of the next two results are omitted due to space constraints.
Theorem 4.10. It is NP-complete to decide whether a-GASP admits a Nash stable assignment.
However, if agents’ preferences satisfy INC, DEC, or MIX, a Nash stable assignment
always exists and can be computed efficiently.
Theorem 4.11. If (N, A, P ) is an instance of a-GASP that is increasing, decreasing, or
mixed increasing-decreasing, a Nash stable assignment always exists and can be found in
polynomial time.
Moreover, the problem of finding a Nash stable assignment that maximizes the number
of agents assigned to a non-void activity admits an efficient algorithm if A∗ consists of a
single simple activity.
Theorem 4.12. There exist a polynomial-time algorithm that given an instance (N, A, P )
of a-GASP with A∗ = {a} finds a Nash stable assignment maximizing the number of
agents assigned to a non-void activity, or decides that no Nash stable assignment exists.
Proof. For each k = n, . . . , 0, we will check if there exists a Nash stable assignment π
with #(π) = k, and output the largest value of k for which this is the case.
For each i ∈ N , let Si′ = Si↓a . For k = n a Nash stable assignment π with #(π) =
n exists if and only if n ∈ Si′ for each i ∈ N . Assigning every agent to a∅ is Nash
stable if and only if 1 ∈
/ Si′ for each i ∈ N . Now we assume 1 ≤ k ≤ n − 1 and set
U1 = {i ∈ N | k ∈ Si′ , k + 1 ∈
/ Si′ }, U2 = {i ∈ N | k ∈
/ Si′ , k + 1 ∈ Si′ }, and
U3 = {i ∈ N | k ∈ Si′ , k + 1 ∈ Si′ }. If |U1 | + |U3 | < k, there does not exist an
individually rational assignment π with #(π) = k. If U2 6= ∅, no Nash stable assignment
π with #(π) = k can exist, since each agent from U2 would want to switch. If |U3 | > k,
no Nash stable assignment π with #(π) = k can exist, since at least one agent in U3 would
not be assigned to a and thus would be unhappy. Finally, if |U1 | + |U3 | ≥ k, |U3 | ≤ k,
U2 = ∅, we can construct a Nash stable assignment π by assigning all agents from U3 and
k − |U3 | agents from U1 to a. Since we have π(i) = a∅ for all i with k 6∈ Si′ and π(i) 6= a∅
for all i with k + 1 ∈ Si′ , no agent is unhappy.


5. C ONCLUSIONS

AND

F UTURE W ORK

We have defined a new model for the selection of a number of group activities, discussed
its connections with hedonic games, defined several stability notions, and, for two of them,
we have obtained several complexity results. A number of our results are positive: finding
desirable assignments proves to be tractable for several restrictions of the problem that
are meaningful in practice. Interesting directions for future work include exploring the
complexity of computing other solution concepts for a-GASP and extending our results to
the more general setting of GASP.
Acknowledgments This research was supported by National Research Foundation (Singapore) under Research Fellowship NRF2009-08, by the project ComSoc (ANR-09-BLAN0305-01), and by the Austrian Science Fund (P23724-G11 and P23829-N13). This project
was initiated during the Dagstuhl seminar 12101 “Computation and Incentives in Social

GROUP ACTIVITY SELECTION PROBLEM

13

Choice”, and the authors are very grateful to Dagstuhl for providing a great research environment and inspiration for this work. We thank Craig Boutilier and Michel Le Breton
for helpful comments. Part of this work was done when the second author was visiting
Université Paris-Dauphine.
