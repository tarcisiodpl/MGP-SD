 Inspired by the recently introduced framework of AND OR search spaces for graphical models  we propose to augment Multi Valued Decision Diagrams  MDD  with AND nodes  in order to capture function decomposition structure and to extend these compiled data structures to general weighted graphical models  e g   probabilistic models   We present the AND OR Multi Valued Decision Diagram  AOMDD  which compiles a graphical model into a canonical form that supports polynomial  e g   solution counting  belief updating  or constant time  e g  equivalence of graphical models  queries  We provide two algorithms for compiling the AOMDD of a graphical model  The first is search based  and works by applying reduction rules to the trace of the memory intensive AND OR search algorithm  The second is inference based and uses a Bucket Elimination schedule to combine the AOMDDs of the input functions via the the APPLY operator  For both algorithms  the compilation time and the size of the AOMDD are  in the worst case  exponential in the treewidth of the graphical model  rather than pathwidth as is known for ordered binary decision diagrams  OBDDs   We introduce the concept of semantic treewidth  which helps explain why the size of a decision diagram is often much smaller than the worst case bound  We provide an experimental evaluation that demonstrates the potential of AOMDDs      Introduction The paper extends decision diagrams into AND OR multi valued decision diagrams  AOMDDs  and shows how graphical models can be compiled into these data structures  The work presented in this paper is based on two existing frameworks      AND OR search spaces for graphical models and     decision diagrams      AND OR Search Spaces AND OR search spaces  Dechter   Mateescu      a      b        have proven to be a unifying framework for various classes of search algorithms for graphical models  The main characteristic is the exploitation of independencies between variables during search  which can provide exponential speedups over traditional search methods that can be viewed as traversing an OR structure  The c      AI Access Foundation  All rights reserved    M ATEESCU   D ECHTER   M ARINESCU  AND nodes capture problem decomposition into independent subproblems  and the OR nodes represent branching according to variable values  AND OR spaces can accommodate dynamic variable ordering  however most of the current work focuses on static decomposition  Examples of AND OR search trees and graphs will appear later  for example in Figures   and    The AND OR search space idea was originally developed for heuristic search  Nilsson         In the context of graphical models  AND OR search  Dechter   Mateescu        was also inspired by search advances introduced sporadically in the past three decades for constraint satisfaction and more recently for probabilistic inference and for optimization tasks  Specifically  it resembles the pseudo tree rearrangement  Freuder   Quinn               that was adapted subsequently for distributed constraint satisfaction by Collin  Dechter  and Katz              and more recently by Modi  Shen  Tambe  and Yokoo         and was also shown to be related to graph based backjumping  Dechter         This work was extended by Bayardo and Miranker        and Bayardo and Schrag        and more recently applied to optimization tasks by Larrosa  Meseguer  and Sanchez         Another version that can be viewed as exploring the AND OR graphs was presented recently for constraint satisfaction  Terrioux   Jegou      b  and for optimization  Terrioux   Jegou      a   Similar principles were introduced recently for probabilistic inference  in algorithm Recursive Conditioning  Darwiche        as well as in Value Elimination  Bacchus  Dalmao    Pitassi      b      a   and are currently at the core of the most advanced SAT solvers  Sang  Bacchus  Beame  Kautz    Pitassi             Decision Diagrams Decision diagrams are widely used in many areas of research  especially in software and hardware verification  Clarke  Grumberg    Peled        McMillan         A BDD represents a Boolean function by a directed acyclic graph with two terminal nodes  labeled   and     and every internal node is labeled with a variable and has exactly two children  low for   and high for    If isomorphic nodes were not merged  we would have the full search tree  also called Shannon tree  which is the usual full tree explored by a backtracking algorithm  The tree is ordered if variables are encountered in the same order along every branch  It can then be compressed by merging isomorphic nodes  i e   with the same label and identical children   and by eliminating redundant nodes  i e   whose low and high children are identical   The result is the celebrated reduced ordered binary decision diagram  or OBDD for short  introduced by Bryant         However  the underlying structure is OR  because the initial Shannon tree is an OR tree  If AND OR search trees are reduced by node merging and redundant nodes elimination we get a compact search graph that can be viewed as a BDD representation augmented with AND nodes      Knowledge Compilation for Graphical Models In this paper we combine the two ideas  creating a decision diagram that has an AND OR structure  thus exploiting problem decomposition  As a detail  the number of values is also increased from two to any constant  In the context of constraint networks  decision diagrams can be used to represent the whole set of solutions  facilitating solutions count  solution enumeration and queries on equivalence of constraint networks  The benefit of moving from OR structure to AND OR is in a lower complexity of the algorithms and size of the compiled structure  It typically moves from being bounded exponentially in pathwidth pw   which is characteristic to chain decompositions or linear structures  to being exponentially bounded in treewidth w   which is characteristic of tree       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  structures  Bodlaender   Gilbert         it always holds that w  pw and pw  w  log n  where n is the number of variables of the model   In both cases  the compactness result achieved in practice is often far smaller than what the bounds suggest  A decision diagram offers a compilation of a propositional knowledge base  An extension of the OBDDs was provided by Algebraic Decision Diagrams  ADD   Bahar  Frohm  Gaona  Hachtel  Macii  Pardo    Somenzi         where the terminal nodes are not just   or    but take values from an arbitrary finite domain  The knowledge compilation approach has become an important research direction in automated reasoning in the past decade  Selman   Kautz        Darwiche   Marquis        Cadoli   Donini         Typically  a knowledge representation language is compiled into a compact data structure that allows fast responses to various queries  Accordingly  the computational effort can be divided between an offline and an online phase where most of the work is pushed offline  Compilation can also be used to generate compact building blocks to be used by online algorithms multiple times  Macro operators compiled during or prior to search can be viewed in this light  Korf   Felner         while in graphical models the building blocks are the functions whose compact compiled representations can be used effectively across many tasks  As one example  consider product configuration tasks and imagine a user that chooses sequential options to configure a product  In a naive system  the user would be allowed to choose any valid option at the current level based only on the initial constraints  until either the product is configured  or else  when a dead end is encountered  the system would backtrack to some previous state and continue from there  This would in fact be a search through the space of possible partial configurations  Needless to say  it would be very unpractical  and would offer the user no guarantee of finishing in a limited time  A system based on compilation would actually build the backtrack free search space in the offline phase  and represent it in a compact manner  In the online phase  only valid partial configurations  i e   that can be extended to a full valid configuration  are allowed  and depending on the query type  response time guarantees can be offered in terms of the size of the compiled structure  Numerous other examples  such as diagnosis and planning problems  can be formulated as graphical models and could benefit from compilation  Palacios  Bonet  Darwiche    Geffner        Huang   Darwiche      a   In diagnosis  compilation can facilitate fast detection of possible faults or explanations for some unusual behavior  Planning problems can also be formulated as graphical models  and a compilation would allow swift adjustments according to changes in the environment  Probabilistic models are one of the most used types of graphical models  and the basic query is to compute conditional probabilities of some variables given the evidence  A compact compilation of a probabilistic model would allow fast response to queries that incorporate evidence acquired in time  For example  two of the most important tasks for Bayesian networks are computing the probability of the evidence  and computing the maximum probable explanation  MPE   If some of the model variables become assigned  evidence   these tasks can be performed in time linear in the compilation size  which in practice is in many cases smaller than the upper bound based on the treewidth or pathwidth of the graph  Formal verification is another example where compilation is heavily used to compare equivalence of circuit design  or to check the behavior of a circuit  Binary Decision Diagram  BDD   Bryant        is arguably the most widely known and used compiled structure  The contributions made in this paper to knowledge compilation in general and to decision diagrams in particular are the following     We formally describe the AND OR Multi Valued Decision Diagram  AOMDD  and prove it to be a canonical representation for constraint networks  given a pseudo tree        M ATEESCU   D ECHTER   M ARINESCU     We extend the AOMDD to general weighted graphical models     We give a compilation algorithm based on AND OR search  that saves the trace of a memory intensive search and then reduces it in one bottom up pass     We present the APPLY operator that combines two AOMDDs and show that its complexity is at most quadratic in the input  but never worse than exponential in the treewidth     We give a scheduling order for building the AOMDD of a graphical model starting with the AOMDDs of its functions which is based on a Variable Elimination algorithm  This guarantees that the complexity is at most exponential in the induced width  treewidth  along the ordering     We show how AOMDDs relate to various earlier and recent compilation frameworks  providing a unifying perspective for all these methods     We introduce the semantic treewidth  which helps explain why compiled decision diagrams are often much smaller than the worst case bound     We provide an experimental evaluation of the new data structure  The structure of the paper is as follows  Section   provides preliminary definitions  a description of binary decision diagrams and the Bucket Elimination algorithm  Section   gives an overview of AND OR search spaces  Section   introduces the AOMDD and discusses its properties  Section   describes a search based algorithm for compiling the AOMDD  Section   presents a compilation algorithm based on a Bucket Elimination schedule and the APPLY operation  Section   proves that the AOMDD is a canonical representation for constraint networks given a pseudo tree  and Section   extends the AOMDD to weighted graphical models and proves their canonicity  Section   ties the canonicity to the new concept of semantic treewidth  Section    provides an experimental evaluation  Section    presents related work and Section    concludes the paper  All the proofs appear in an appendix      Preliminaries Notations A reasoning problem is defined in terms of a set of variables taking values from finite domains and a set of functions defined over these variables  We denote variables or subsets of variables by uppercase letters  e g   X  Y         and values of variables by lower case letters  e g   x  y          Sets are usually denoted by bold letters  for example X    X            Xn   is a set of variables  An assignment  X    x            Xn   xn   can be abbreviated as x    hX    x  i          hXn   xn i  or x    x            xn    For a subset of variables Y  DY denotes the Cartesian product of the domains of variables in Y  The projection of an assignment x    x            xn   over a subset Y is denoted by xY or x Y   We will also denote by Y   y  or y for short  the assignment of values to variables in Y from their respective domains  We denote functions by letters f   g  h etc   and the scope  set of arguments  of the function f by scope f        Graphical Models D EFINITION    graphical model  A graphical model M is a   tuple  M   hX  D  F  i  where        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS     X    X            Xn   is a finite set of variables     D    D            Dn   is the set of their respective finite domains of values     F    f            fr   is a set of positive real valued discrete functions  i e   their domains can be listed   each defined over a subset of variables Si  X  called its scope  and denoted by scope fi    Q P     is a combination operator   e g               product  sum  join   that can take as input two  or more  real valued discrete functions  and produce another real valued discrete function  The graphical model represents the combination of all its functions  ri   fi   Several examples of graphical models appear later  for example  Figure   shows a constraint network and Figure   shows a belief network  In order to define the equivalence of graphical models  it is useful to introduce the notion of universal graphical model that is defined by a single function  D EFINITION    universal equivalent graphical model  Given a graphical model M   hX  D  F    i the universal equivalent model of M is u M    hX  D  F     fi F  fi    i  Two graphical models are equivalent if they represent the same function  Namely  if they have the same universal model  D EFINITION    weight of a full and a partial assignment  Given a graphical model M   hX  D  Fi  the weight of a full assignment x    x            xn   is defined by w x    f F f  x scope f      Given a subset of variables Y  X  the weight of a partial assignment y is the combination of all the functions whose scopes are included in Y  denoted by FY   evaluated at the assigned values  Namely  w y    f FY f  y scope f      Consistency For most graphical models  the range of the functions has a special zero value   that is absorbing relative to the combination operator  e g   multiplication   Combining anything with   yields a    The   value expresses the notion of inconsistent assignments  It is a primary concept in constraint networks but can also be defined relative to other graphical models that have a   element  D EFINITION    consistent partial assignment  solution  Given a graphical model having a   element  a partial assignment is consistent if its cost is non zero  A solution is a consistent assignment to all the variables  D EFINITION    primal graph  The primal graph of a graphical model is an undirected graph that has variables as its vertices and an edge connects any two variables that appear in the scope of the same function  The primal graph captures the structure of the knowledge expressed by the graphical model  In particular  graph separation indicates independency of sets of variables given some assignments to other variables  All of the advanced algorithms for graphical models exploit the graphical structure  by using a heuristically good elimination order  a tree decomposition or some similar method  We will use the concept of pseudo tree  which resembles the tree rearrangements introduced by Freuder and Quinn            The combination operator can also be defined axiomatically  Shenoy                M ATEESCU   D ECHTER   M ARINESCU  E  A  A  D  E  B  D F  B  G  F  C  G C   a  Graph coloring problem   b  Constraint graph  Figure    Constraint network D EFINITION    pseudo tree  A pseudo tree of a graph G    X  E  is a rooted tree T having the same set of nodes X  such that every arc in E is a backarc in T  A path in a rooted tree starts at the root and ends at one leaf  Two nodes can be connected by a backarc only if there exists a path that contains both   We use the common concepts and parameters from graph theory  that characterize the connectivity of the graph  and how close it is to a tree or to a chain  The induced width of a graphical model governs the complexity of solving it by Bucket Elimination  Dechter         and was also shown to bound the AND OR search graph when memory is used to cache solved subproblems  Dechter   Mateescu         D EFINITION    induced graph  induced width  treewidth  pathwidth  An ordered graph is a pair  G  d   where G     X            Xn    E  is an undirected graph  and d    X            Xn   is an ordering of the nodes  The width of a node in an ordered graph is the number of neighbors that precede it in the ordering  The width of an ordering d  denoted w d   is the maximum width over all nodes  The induced width of an ordered graph  w  d   is the width of the induced ordered graph obtained as follows  for each node  from last to first in d  its preceding neighbors are connected in a clique  The induced width of a graph  w   is the minimal induced width over all orderings  The induced width is also equal to the treewidth of a graph  The pathwidth pw of a graph is the treewidth over the restricted class of orderings that correspond to chain decompositions  Various reasoning tasks  or queries can be defined over graphical models  Those can be defined formally using marginalization operators such as projection  summation and minimization  However  since our goal is to present a compilation of a graphical model which is independent of the queries that can be posed on it  we will discuss tasks in an informal manner only  For more information see the work of Kask  Dechter  Larrosa  and Dechter         Throughout the paper  we will use two examples of graphical models  constraint networks and belief networks  In the case of constraint networks  the functions can be understood as relations  In other words  the functions  also called constraints  can take only two values          or  f alse  true   A   value indicates that the corresponding assignment to the variables is inconsistent  not allowed   and a   value indicates consistency  Belief networks are an example of the more general case of graphical models  also called weighted graphical models   The functions in this case are conditional probability tables  so the values of a function are real numbers in the interval                AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Example   Figure   a  shows a graph coloring problem that can be modeled by a constraint network  Given a map of regions  the problem is to color each region by one of the given colors  red  green  blue   such that neighboring regions have different colors  The variables of the problems are the regions  and each one has the domain  red  green  blue   The constraints are the relation different between neighboring regions  Figure   b  shows the constraint graph  and a solution  A red  B blue  C green  D green  E blue  F blue  G red  is given in Figure   a   A more detailed example will be given later in Example    Propositional Satisfiability A special case of a CSP is propositional satisfiability  SAT   A formula  in conjunctive normal form  CNF  is a conjunction of clauses             t   where a clause is a disjunction of literals  propositions or their negations   For example      P  Q  R  is a clause  where P   Q and R are propositions  and P   Q and R are literals  The SAT problem is to decide whether a given CNF theory has a model  i e   a truth assignment to its propositions that does not violate any clause  Propositional satisfiability  SAT  can be defined as a CSP  where propositions correspond to variables  domains are         and constraints are represented by clauses  for example the clause  A  B  is a relation over its propositional variables that allows all tuples over  A  B  except  A      B       Cost Networks An immediate extension of constraint networks are cost networks where the set of functions are real valued cost functions  and the primary task is optimization  Also  GAI nets  generalized additive independence  Fishburn        can be used to represent utility functions  An example of cost functions will appear in Figure     D EFINITION P   cost network  combinatorial optimization  A cost network is a   tuple  hX  D  C  i  where X is a set of variables X    X            Xn    associated with a set of discrete valued domains  D    D            Dn    and a set of cost functions C    C            Cr    Each Ci is a real valued function defined on a subset of variables Si  X  The combination operator  is P   The reasoning problem is to find a minimum cost solution   Belief Networks  Pearl        provide a formalism for reasoning about partial beliefs under conditions of uncertainty  They are defined by a directed acyclic graph over vertices representing random variables of interest  e g   the temperature of a device  the gender of a patient  a feature of an object  the occurrence of an event   The arcs signify the existence of direct causal influences between linked variables quantified by conditional probabilities that are attached to each cluster of parentschild vertices in the network  Q D EFINITION    belief networks  A belief network  BN  is a graphical model P   hX  D  PG   i  where X    X            Xn   is a set of variables over domains D    D            Dn    Given a directed acyclic graph G over X as nodes  PG    P            Pn    where Pi    P  Xi   pa  Xi       are conditional probability tables  CPTs for short  associated with each Xi   where pa Xi   are the parents of Xi in the Qacyclic graph G  A belief network represents a probability distribution over X  P  x            xn     ni   P  xi  xpa Xi      An evidence set e is an instantiated subset of variables  When formulated as a graphical model  functions in F denote conditional probability tables and the scopes of these functions are determined by the directed acyclic graph G  each function Q fi ranges over variable Xi and its parents in G  The combination operator is product       The primal graph of a belief network  viewed as an undirected model  is called a moral graph  It connects any two variables appearing in the same CPT        M ATEESCU   D ECHTER   M ARINESCU  A Season  Sprinkler B  Watering D  A  C Rain  B  F Wetness  D  G Slippery  C  F  G   a  Directed acyclic graph   b  Moral graph  Figure    Belief network Example   Figure   a  gives an example of a belief network over   variables  and Figure   b  shows its moral graph   The example expresses the causal relationship between variables Season  A   The configuration of an automatic sprinkler system  B   The amount of rain expected  C   The amount of manual watering necessary  D   The wetness of the pavement  F   and Whether or not the pavement is slippery  G   The belief network expresses the probability distribution P  A  B  C  D  F  G    P  A   P  B A   P  C A   P  D B  A   P  F  C  B   P  G F    Another example of a belief network and CPTs appears in Figure    The two most popular tasks for belief networks are defined below  D EFINITION     belief updating  most probable explanation  MPE   Given a belief network and evidence e  the belief updating task is to compute the posterior marginal probability of variable Xi   conditioned on the evidence  Namely  X  Bel Xi   xi     P  Xi   xi   e      n Y  P  xk   e xpak       x       xi   xi        xn   E e Xi  xi   k    where  is a normalization constant  The most probable explanation  MPE  task is to find a complete assignment which agrees with the evidence  and which has the highest probability among all such assignments  Namely  to find an assignment  xo            xon   such that P  xo            xon     maxx       xn  n Y  P  xk   e xpak     k        Binary Decision Diagrams Review Decision diagrams are widely used in many areas of research to represent decision processes  In particular  they can be used to represent functions  Due to the fundamental importance of Boolean functions  a lot of effort has been dedicated to the study of Binary Decision Diagrams  BDDs   which are extensively used in software and hardware verification  Clarke et al         McMillan         The earliest work on BDDs is due to Lee         who introduced the binary decision program  that can be understood as a linear representation of a BDD  e g   a depth first search ordering of the nodes   where each node is a branching instruction indicating the address of the next instruction for both the   and the   value of the test variable  Akers        presented the actual graphical       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  A                  B                  C                  f ABC                   A  A  B  C  C     C      a  Table     B  B        B        B  C         b  Unordered tree  C        C        C            c  Ordered tree  Figure    Boolean function representations representation and further developed the BDD idea  However  it was Bryant        that introduced what is now called the Ordered Binary Decision Diagram  OBDD   He restricted the order of variables along any path of the diagram  and presented algorithms  most importantly the apply procedure  that combines two OBDDs by an operation  that have time complexity at most quadratic in the sizes of the input diagrams  OBDDs are fundamental for applications with large binary functions  especially because in many practical cases they provide very compact representations  A BDD is a representation of a Boolean function  Given B           a Boolean function f   Bn  B  has n arguments  X         Xn   which are Boolean variables  and takes Boolean values  Example   Figure   a  shows a table representation of a Boolean function of three variables  This explicit representation is the most straightforward  but also the most costly due to its exponential requirements  The same function can also be represented by a binary tree  shown in Figure   b   that has the same exponential size in the number of variables  The internal round nodes represent the variables  the solid edges are the    or high  value  and the dotted edges are the    or low  value  The leaf square nodes show the value of the function for each assignment along a path  The tree shown in   b  is unordered  because variables do not appear in the same order along each path  In building an OBDD  the first condition is to have variables appear in the same order  A B C  along every path from root to leaves  Figure   c  shows an ordered binary tree for our function  Once an order is imposed  there are two reduction rules that transform a decision diagram into an equivalent one      isomorphism  merge nodes that have the same label and the same children      redundancy  eliminate nodes whose low and high edges point to the same node  and connect parent of removed node directly to child of removed node  Applying the two reduction rules exhaustively yields a reduced OBDD  sometimes denoted rOBDD  We will just use OBDD and assume that it is completely reduced  Example   Figure   a  shows the binary tree from Figure   c  after the isomorphic terminal nodes  leaves  have been merged  The highlighted nodes  labeled with C  are also isomorphic  and Figure   b  shows the result after they are merged  Now  the highlighted nodes labeled with C and B are redundant  and removing them gives the OBDD in Figure   c       Bucket Elimination Review Bucket Elimination  BE   Dechter        is a well known variable elimination algorithm for inference in graphical models  We will describe it using the terminology for constraint networks  but BE       M ATEESCU   D ECHTER   M ARINESCU  A  A  B  B  C  C  C        A  B  C  B  C  C      a  Isomorphic nodes  B  C         b  Redundant nodes      c  OBDD  Figure    Reduction rules A   A C  AC  C  AB  C  ABE   B  C  C  BCD   h  A   B   C  AB   E   C  ABE   A  h  AB   h  AB   AB bucket B AB  ABE  C  E  D   a  Constraint network  D   C  AC   h  BC   bucket A  A  bucket E  AB  ABC bucket C BC  BCD bucket D  C   BCD    b  BE execution   c  Bucket tree  Figure    Bucket Elimination can also be applied to any graphical model  Consider a constraint network R   hX  D  Ci and an ordering d    X    X            Xn    The ordering d dictates an elimination order for BE  from last to first  Each variable is associated with a bucket  Each constraint from C is placed in the bucket of its latest variable in d  Buckets are processed from Xn to X  by eliminating the bucket variable  the constraints residing in the bucket are joined together  and the bucket variable is projected out  and placing the resulting constraint  also called message  in the bucket of its latest variable in d  After its execution  BE renders the network backtrack free  and a solution can be produced by assigning variables along d  BE can also produce the solutions count if marginalization is done by summation  rather than projection  over the functional representation of the constraints  and join is substituted by multiplication  BE also constructs a bucket tree  by linking the bucket of each Xi to the destination bucket of its message  called the parent bucket   A node in the bucket tree typically has a bucket variable  a collection of constraints  and a scope  the union of the scopes of its constraints   If the nodes of the bucket tree are replaced by their respective bucket variables  it is easy to see that we obtain a pseudo tree  Example   Figure   a  shows a network with four constraints  Figure  b  shows the execution of Bucket Elimination along d    A  B  E  C  D   The buckets are processed from D to A   Figure   c  shows the bucket tree  The pseudo tree corresponding to the order d is given in Fig    a      The representation in Figure   reverses the top down bucket processing described in earlier papers  Dechter                AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Procedure GeneratePseudoTree G  d             input   graph G    X  E   order d    X            Xn   output   Pseudo tree T Make X  the root of T Condition on X   eliminate X  and its incident edges from G   Let G            Gp be the resulting connected components of G for i     to p do Ti   GeneratePseudoTree  Gi   d Gi   Make root of Ti a child of X     return T      Orderings and Pseudo Trees Given an ordering d  the structural information captured in the primal graph through the scopes of the functions F    f            fr   can be used to create the unique pseudo tree that corresponds to d  Mateescu   Dechter         This is precisely the bucket tree  or elimination tree   that is created by BE  when variables are processed in reverse d   The same pseudo tree can be created by conditioning on the primal graph  and processing variables in the order d  as described in Procedure GeneratePseudoTree  In the following  d Gi is the restriction of the order d to the nodes of the graph Gi       Overview of AND OR Search Space for Graphical Models The AND OR search space is a recently introduced  Dechter   Mateescu      a      b        unifying framework for advanced algorithmic schemes for graphical models  Its main virtue consists in exploiting independencies between variables during search  which can provide exponential speedups over traditional search methods oblivious to problem structure  Since AND OR MDDs are based on AND OR search spaces we need to provide a comprehensive overview for the sake of completeness      AND OR Search Trees The AND OR search tree is guided by a pseudo tree of the primal graph  The idea is to exploit the problem decomposition into independent subproblems during search  Assigning a value to a variable  also known as conditioning   is equivalent in graph terms to removing that variable  and its incident edges  from the primal graph  A partial assignment can therefore lead to the decomposition of the residual primal graph into independent components  each of which can be searched  or solved  separately  The pseudo tree captures precisely all these decompositions given an order of variable instantiation  D EFINITION     AND OR search tree of a graphical model  Given a graphical model M   hX  D  Fi  its primal graph G and a pseudo tree T of G  the associated AND OR search tree has alternating levels of OR and AND nodes  The OR nodes are labeled Xi and correspond to variables  The AND nodes are labeled hXi   xi i  or simply xi   and correspond to value assignments  The structure of the AND OR search tree is based on T   The root is an OR node labeled with the root of T   The children of an OR node Xi are AND nodes labeled with assignments hXi   xi i that        M ATEESCU   D ECHTER   M ARINESCU  A  A  B     B  B    E  E     C  D    C       E        D       a  Pseudo tree         C  E        D  D                   C  E        D  D                 C       D  D  D                  b  Search tree  Figure    AND OR search tree are consistent with the assignments along the path from the root  The children of an AND node hXi   xi i are OR nodes labeled with the children of variable Xi in the pseudo tree T   Example   Figure   shows an example of an AND OR search tree for the graphical model given in Figure   a   assuming all tuples are consistent  and variables are binary valued  When some tuples are inconsistent  some of the paths in the tree do not exist  Figure   a  gives the pseudo tree that guides the search  from top to bottom  as indicated by the arrows  The dotted arcs are backarcs from the primal graph  Figure   b  shows the AND OR search tree  with the alternating levels of OR  circle  and AND  square  nodes  and having the structure indicated by the pseudo tree  The AND OR search tree can be traversed by a depth first search algorithm  thus using linear space  It was already shown  Freuder   Quinn        Bayardo   Miranker        Darwiche        Dechter   Mateescu      a        that  T HEOREM   Given a graphical model M over n variables  and a pseudo tree T of depth m  the size of the AND OR search tree based on T is O n k m    where k bounds the domains of variables  A graphical model of treewidth w has a pseudo tree of depth at most w log n  therefore it has an  AND OR search tree of size O n k w log n    The AND OR search tree expresses the set of all possible assignments to the problem variables  all solutions   The difference from the traditional OR search space is that a solution is no longer a path from root to a leaf  but rather a tree  defined as follows  D EFINITION     solution tree  A solution tree of an AND OR search tree contains the root node  For every OR node  it contains one of its child nodes and for each of its AND nodes it contains all its child nodes  and all its leaf nodes are consistent      AND OR Search Graph The AND OR search tree may contain nodes that root identical subproblems  These nodes are said to be unifiable  When unifiable nodes are merged  the search space becomes a graph  Its size becomes smaller at the expense of using additional memory by the search algorithm  The depth first search algorithm can therefore be modified to cache previously computed results  and retrieve them when the same nodes are encountered again  The notion of unifiable nodes is defined formally next         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  D EFINITION     minimal AND OR graph  isomorphism  Two AND OR search graphs G and G  are isomorphic if there exists a one to one mapping  from the vertices of G to the vertices of G  such that for any vertex v  if  v    v     then v and v   root identical subgraphs relative to   An AND OR graph is called minimal if all its isomorphic subgraphs are merged  Isomorphic nodes  that root isomorphic subgraphs  are also said to be unifiable  It was shown by Dechter and Mateescu        that  T HEOREM   A graphical model M has a unique minimal AND OR search graph relative to a pseudo tree T   The minimal AND OR graph of a graphical model G relative to a pseudo tree T is denoted by MT  G   Note that the definition of minimality used in the work of Dechter and Mateescu        is based only on isomorphism reduction  We will extend it here by also including the elimination of redundant nodes  The previous theorem only shows that given an AND OR graph  the merge operator has a fixed point  which is the minimal AND OR graph  We will show in this paper that the AOMDD is a canonical representation  namely that any two equivalent graphical models can be represented by the same unique AOMDD given that they accept the same pseudo tree  and the AOMDD is minimal in terms of number of nodes  Some unifiable nodes can be identified based on their contexts  We can define graph based contexts for both OR nodes and AND nodes  just by expressing the set of ancestor variables in T that completely determine a conditioned subproblem  However  it can be shown that using caching based on OR contexts makes caching based on AND contexts redundant and vice versa  so we will only use OR caching  Any value assignment to the context of X separates the subproblem below X from the rest of the network  D EFINITION     OR context  Given a pseudo tree T of an AND OR search space  context X     X        Xp   is the set of ancestors of X in T   ordered descendingly  that are connected in the primal graph to X or to descendants of X  D EFINITION     context unifiable OR nodes  Given an AND OR search graph  two OR nodes n  and n  are context unifiable if they have the same variable label X and the assignments of their contexts is identical  Namely  if   is the partial assignment of variables along the path to n    and   is the partial assignment of variables along the path to n    then their restriction to the context of X is the same     context X       context X    The depth first search algorithm that traverses the AND OR search tree  can be modified to traverse a graph  if enough memory is available  We could allocate a cache table for each variable X  the scope of the table being context X   The size of the cache table for X is therefore the product of the domains of variables in its context  For each variable X  and for each possible assignment to its context  the corresponding conditioned subproblem is solved only once and the computed value is saved in the cache table  and whenever the same context assignment is encountered again  the value of the subproblem is retrieved from the cache table  Such an algorithm traverses what is called the context minimal AND OR graph  D EFINITION     context minimal AND OR graph  The context minimal AND OR graph is obtained from the AND OR search tree by merging all the context unifiable OR nodes        M ATEESCU   D ECHTER   M ARINESCU  R  F  G  B      C  A J  K   C   H   C   L   CK   A   CH   N   CKL   B   CHA   O   CKLN   P   CKO   H E C  D  L  E   CHAB   R   HAB   J   CHAE   F   AR   D   CEJ   G   AF   M   CD   K M N P O   a  Primal graph   b  Pseudo tree C        K  H  K              L  L  L  L  H        A     A     A  A                                                  N  N  N  N  N  N  N  N  B  B  B  B  B  B  B  B                                                  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O     E        E  E  E        E  E  E        E  E  E  E        E  E  E  E     E           R  R  R        R  R  R  R     R                                                                                      P  P  P  P  P  P  P                                                                                P J  J  J  J  J  J  J  J  J  J  J  J  J  J  J  J                                                                                                   D  D  D  D                   D  D  D  F  F  F  F                   D                   G  G  G  G                  M  M  M  M                    c  Context minimal graph  Figure    AND OR search graph It was already shown  Bayardo   Miranker        Dechter   Mateescu      a        that  T HEOREM   Given a graphical model M  its primal graph G and a pseudo tree T   the size of the context minimal AND OR search graph based on T   and therefore the size of its minimal AND OR  search graph  is O n k wT  G     where wT  G  is the induced width of G over the depth first traversal of T   and k bounds the domain size   Example   Lets look at the impact of caching on the size of the search space by examining a larger example  Figure   a  shows a graphical model with binary variables and Figure   b  a pseudo tree that drives the AND OR search  The context of each node is given in square brackets  The context minimal graph is given in Figure   c   Note that it is far smaller than the AND OR search tree  which has          AND nodes at the level of M alone  because M is at depth   in the pseudo tree   The shaded rectangles show the size of each cache table  equal to the number of OR nodes that appear in each one  A cache entry is useful whenever there are more than one incoming edges into the OR node  Incidentally  the caches that are not useful  namely OR nodes with only one incoming arc   are called dead caches  Darwiche         and can be determined based only on the pseudo       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  tree inspection  therefore a cache table need not be allocated for them  The context minimal graph can also explain the execution of BE along the same pseudo tree  or  equivalently  along its depth first traversal order   The buckets are the shaded rectangles  and the processing is done bottom up  The number of possible assignments to each bucket equals the number of AND nodes that appear in it  The message scope is identical to the context of the bucket variable  and the message itself is identical to the corresponding cache table  For more details on the relationship between AND OR search and BE see the work of Mateescu and Dechter             Weighted AND OR Graphs In the previous subsections we described the structure of the AND OR trees and graphs  In order to use them to solve a reasoning task  we need to define a way of using the input function values during the traversal of an AND OR graph  This is realized by placing weights  or costs  on the OR to AND arcs  dictated by the function values  Only the functions that are relevant contribute to an OR to AND arc weight  and this is captured by the buckets relative to the pseudo tree  D EFINITION     buckets relative to a pseudo tree  Given a graphical model M   hX  D  F  i and a pseudo tree T   the bucket of Xi relative to T   denoted BT  Xi    is the set of functions whose scopes contain Xi and are included in pathT  Xi    which is the set of variables from the root to Xi in T   Namely  BT  Xi      f  F Xi  scope f    scope f    pathT  Xi      A function belongs to the bucket of a variable Xi iff its scope has just been fully instantiated when Xi was assigned  Combining the values of all functions in the bucket  for the current assignment  gives the weight of the OR to AND arc  D EFINITION     OR to AND weights  Given an AND OR graph of a graphical model M  the weight w n m   Xi   xi   of arc  n  m  where Xi labels n and xi labels m  is the combination of all the functions in BT  Xi   assigned by values along the current path to the AND node m  m   Formally  w n m   Xi   xi     f BT  Xi   f  asgn m   scope f      D EFINITION     weight of a solution tree  Given a weighted AND OR graph of a graphical model M  and given a solution tree t having the OR to AND set of arcs arcs t   the weight of t is defined by w t    earcs t  w e   Example   We start with the more straightforward case of constraint networks  Since functions only take values   or    and the combination is by product  join of relations   it follows that any ORto AND arc can only have a weight of   or    An example is given in Figure    Figure   a  shows a constraint graph    b  a pseudo tree for it  and   c  the four relations that define the constraint problem  Figure   d  shows the AND OR tree that can be traversed by a depth first search algorithm that only checks the consistency of the input functions  i e   no constraint propagation is used   Similar to the OBDD representation  the OR to AND arcs with a weight of   are denoted by dotted lines  and the tree is not unfolded below them  since it will not contain any solution  The arcs with a weight of   are drawn with solid lines        M ATEESCU   D ECHTER   M ARINESCU  A B C  A  D  F  B  E   a  Constraint graph A                  B                  B                  C RABC                                  C                  C  E  D  F   b  Pseudo tree  D RBCD                                  A                  B                  E RABE                                  A                  E                  F RAEF                                   c  Relations A              B  B               C  C  E         C  E  C  E  E                                                                                                  D  D  D  F                                         F  D  F                                    D  D  F  F                                                      d  AND OR tree  Figure    AND OR search tree for constraint networks Example   Figure   shows a weighted AND OR tree for a belief network  Figure   a  shows the directed acyclic graph  and the dotted arc BC added by moralization  Figure   b  shows the pseudo tree  and   c  shows the conditional probability tables  Figure   d  shows the weighted AND OR tree  As we did for constraint networks  we can move from weighted AND OR search trees to weighted AND OR search graphs by merging unifiable nodes  In this case the arc labels should be also considered when determining unifiable subgraphs  This can yield context minimal weighted AND OR search graphs and minimal weighted AND OR search graphs      AND OR Multi Valued Decision Diagrams  AOMDDs  In this section we begin describing the contributions of this paper  The context minimal AND OR graph  Definition     offers an effective way of identifying some unifiable nodes during the execution of the search algorithm  Namely  context unifiable nodes are discovered based only on their paths from the root  without actually solving their corresponding subproblems  However  merging based on context is not complete  which means that there may still exist unifiable nodes in the search graph that do not have identical contexts  Moreover  some of the nodes in the context       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  P A   A  A      A  P B   A   P A         A      P C   A  A      B          B          P D   B C   B B  B          C  E E  C D  D   a  Belief network  C          P E   A B  D                D                C          C           b  Pseudo tree  A          B          E                E                 c  CPTs  A                B  B           C        E                       D           D                                   D              C     E                       D  D              E  C                E                                  C                       D        D                    D                     d  Weighted AND OR tree  Figure    Weighted AND OR search tree for belief networks minimal AND OR graph may be redundant  for example when the set of solutions rooted at variable Xi is not dependant on the specific value assigned to Xi  this situation is not detectable based on context   This is sometimes termed as interchangeable values or symmetrical values  As overviewed earlier  Dechter and Mateescu            a  defined the complete minimal AND OR graph which is an AND OR graph whose unifiable nodes are all merged  and Dechter and Mateescu        also proved the canonicity for non weighted graphical models  In this paper we propose to augment the minimal AND OR search graph with removing redundant variables as is common in OBDD representation as well as adopt notational conventions common in this community  This yields a data structure that we call AND OR BDD  that exploits decomposition by using AND nodes  We present the extension over multi valued variables yielding AND OR MDD or AOMDD and define them for general weighted graphical models  Subsequently we present two algorithms for compiling the canonical AOMDD of a graphical model  the first is search based  and uses the memory intensive AND OR graph search to generate the context minimal AND OR graph  and then reduces it bottom up by applying reduction rules  the second is inferencebased  and uses a Bucket Elimination schedule to combine the AOMDDs of initial functions by APPLY operations  similar to the apply for OBDDs   As we will show  both approaches have the same worst case complexity as the AND OR graph search with context based caching  and also the same complexity as Bucket Elimination  namely time and space exponential in the treewidth of the  problem  O n k w    The benefit of each of these generation schemes will be discussed         M ATEESCU   D ECHTER   M ARINESCU  A  A      a  OBDD          k   b  MDD  Figure     Decision diagram nodes  OR  A  A                     a  AOBDD     k                  b  AOMDD  Figure     Decision diagram nodes  AND OR      From AND OR Search Graphs to Decision Diagrams An AND OR search graph G of a graphical model M   hX  D  F  i represents the set of all possible assignments to the problem variables  all solutions and their costs   In this sense  G can be viewed as representing the function f   fi F fi that defines the universal equivalent graphical model u M   Definition     For each full assignment x    x            xn    if x is a solution expressed by the tree tx   then f  x    w tx     earcs tx   w e   Definition      otherwise f  x       the assignment is inconsistent   The solution tree tx of a consistent assignment x can be read from G in linear time by following the assignments from the root  If x is inconsistent  then a dead end is encountered in G when attempting to read the solution tree tx   and f  x       Therefore  G can be viewed as a decision diagram that determines the values of f for every complete assignment x  We will now see how we can process an AND OR search graph by reduction rules similar to the case of OBDDs  in order to obtain a representation of minimal size  In the case of OBDDs  a node is labeled with a variable name  for example A  and the low  dotted line  and high  solid line  outgoing arcs capture the restriction of the function to the assignments A     or A      To determine the value of the function  one needs to follow either one or the other  but not both  of the outgoing arcs from A  see Figure    a    The straightforward extension of OBDDs to multi valued variables  multi valued decision diagrams  or MDDs  was presented by Srinivasan  Kam  Malik  and Brayton         and the node structure that they use is given in Figure    b   Each outgoing arc is associated with one of the k values of variable A  In this paper we generalize the OBDD and MDD representations demonstrated in Figures    a  and    b  by allowing each outgoing arc to be an AND arc  An AND arc connects a node to a set of nodes  and captures the decomposition of the problem into independent components  The number of AND arcs emanating from a node is two in the case of AOBDDs  Figure    a    or the domain size of the variable in the general case  Figure    b    For a given node A  each of its k AND arcs can connect it to possibly different number of nodes  depending on how the problem decomposes based on each particular assignment of A  The AND arcs are depicted by a shaded sector that connects the outgoing lines corresponding to the independent components         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  A                    k             a  Nonterminal meta node         b  Terminal meta node     c  Terminal meta node    Figure     Meta nodes We define the AND OR Decision Diagram representation based on AND OR search graphs  We find that it is useful to maintain the semantics of Figure    especially when we need to express the redundancy of nodes  and therefore we introduce the meta node data structure  which defines small portions of any AND OR graph  based on an OR node and its AND children  D EFINITION     meta node  A meta node u in an AND OR search graph can be either      a terminal node labeled with   or    or     a nonterminal node  that consists of an OR node labeled X  therefore var u    X  and its k AND children labeled x            xk that correspond to the value assignments of X  Each AND node labeled xi stores a list of pointers to child meta nodes  denoted by u childreni   In the case of weighted graphical models  the AND node xi also stores the OR toAND arc weight w X  xi    The rectangle in Figure    a  is a meta node for variable A  that has a domain of size k  Note that this is very similar to Figure     with the small difference that the information about the value of A that corresponds to each outgoing AND arc is now stored in the AND nodes of the meta node  We are not showing the weights in that figure  A larger example of an AND OR graph with meta nodes appears later in Figure     The terminal meta nodes play the role of the terminal nodes in OBDDs  The terminal metanode    shown in Figure    b   indicates inconsistent assignments  while the terminal meta node    shown in figure    c  indicates consistent ones  Any AND OR search graph can now be viewed as a diagram of meta nodes  simply by grouping OR nodes with their AND children  and adding the terminal meta nodes appropriately  Once we have defined the meta nodes  it is easier to see when a variable is redundant with respect to the outcome of the function based on the current partial assignment  A variable is redundant if any of its assignments leads to the same set of solutions  D EFINITION     redundant meta node  Given a weighted AND OR search graph G represented with meta nodes  a meta node u with var u    X and  D X     k is redundant iff   a  u children            u childrenk and  b  w X  x              w X  xk    An AND OR graph G  that contains a redundant meta node u  can be transformed into an equivalent graph G   by replacing any incoming arc into u with its common list of children u children    absorbing the common weight w X  x    by combination into the weight of the parent meta node corresponding to the incoming arc  and then removing u and its outgoing arcs from G  The value X   x  is picked here arbitrarily  because they are all isomorphic  If u is the root of the       M ATEESCU   D ECHTER   M ARINESCU  Procedure RedundancyReduction   AND OR graph G  redundant meta node u  with var u    X  List of meta node parents of u  denoted by P arents u   output   Reduced AND OR graph G after the elimination of u    if P arents u  is empty then   return independent AND OR graphs rooted by meta nodes in u children    and constant w X  x    input    forall v  P arents u   assume var v     Y   do   forall i               D Y     do   if u  v childreni then   v childreni  v childreni    u    v childreni  v childreni  u children    w Y  yi    w Y  yi    w X  x      remove u    return reduced AND OR graph G  Procedure IsomorphismReduction   AND OR graph G  isomorphic meta nodes u and v  List of meta node parents of u  denoted by P arents u   output   Reduced AND OR graph G after the merging of u and v  forall p  P arents u  do if u  p childreni then p childreni  p childreni    u  p childreni  p childreni   v   input             remove u   return reduced AND OR graph G  graph  then the common weight w X  x    has to be stored separately as a constant  Procedure RedundancyReduction formalizes the redundancy elimination  D EFINITION     isomorphic meta nodes  Given a weighted AND OR search graph G represented with meta nodes  two meta nodes u and v having var u    var v    X and  D X     k are isomorphic iff   a  u childreni   v childreni i              k  and  b  wu  X  xi     wv  X  xi   i              k    where wu   wv are the weights of u and v   Procedure IsomorphismReduction formalizes the process of merging isomorphic metanodes  Naturally  the AND OR graph obtained by merging isomorphic meta nodes is equivalent to the original one  We can now define the AND OR Multi Valued Decision Diagram  D EFINITION     AOMDD  An AND OR Multi Valued Decision Diagram  AOMDD  is a weighted AND OR search graph that is completely reduced by isomorphic merging and redundancy removal  namely      it contains no isomorphic meta nodes  and     it contains no redundant meta nodes         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  A  A      k     B  c     d        k  z            z  k       y  c       d  y   b  After eliminating the B meta node   a  Fragment of an AOMDD  Figure     Redundancy reduction A    A      k           k  B    C     d        C         B     k     e             k  C      k         k     y  d   a  Fragment of an AOMDD     k  e       y   b  After merging the isomorphic C meta nodes  Figure     Isomorphism reduction Example    Figure    shows an example of applying the redundancy reduction rule to a portion of an AOMDD  On the left side  in Figure    a   the meta node of variable B is redundant  we dont show the weights of the OR to AND arcs  to avoid cluttering the figure   Any of the values             k  of B will lead to the same set of meta nodes  c  d          y   which are coupled in an AND arc  Therefore  the meta node of B can be eliminated  The result is shown in Figure    b   where the meta nodes  c  d          y  and z are coupled in an AND arc outgoing from A      In Figure    we show an example of applying the isomorphism reduction rule  In this case  the meta nodes labeled with C in Figure    a  are isomorphic  again  we omit the weights   The result of merging them is shown in Figure    b   Examples of AOMDDs appear in Figures        and     Note that if the weight on an OR toAND arc is zero  then the descendant is the terminal meta node    Namely  the current path is a dead end  cannot be extended to a solution  and is therefore linked directly to        Using AND OR Search to Generate AOMDDs In Section     we described how we can transform an AND OR graph into an AOMDD by applying reduction rules  In Section     we describe the explicit algorithm that takes as input a graphi      M ATEESCU   D ECHTER   M ARINESCU  cal model  performs AND OR search with context based caching to obtain the context minimal AND OR graph  and in Section     we give the procedure that applies the reduction rules bottom up to obtain the AOMDD      Algorithm AND OR S EARCH  AOMDD Algorithm    called AND OR S EARCH  AOMDD  compiles a graphical model into an AOMDD  A memory intensive  with context based caching  AND OR search is used to create the context minimal AND OR graph  see Definition      The input to AND OR S EARCH  AOMDD is a graphical model M and a pseudo tree T   that also defines the OR context of each variable  Each variable Xi has an associated cache table  whose scope is the context of Xi in T   This ensures that the trace of the search is the context minimal AND OR graph  A list denoted by LXi  see line      is used for each variable Xi to save pointers to meta nodes labeled with Xi   These lists are used by the procedure that performs the bottom up reduction  per layers of the AND OR graph  one layer contains all the nodes labeled with one given variable   The fringe of the search is maintained on a stack called OPEN  The current node  either OR or AND node  is denoted by n  its parent by p  and the current path by n   The children of the current node are denoted by successors n   For each node n  the Boolean attribute consistent n  indicates if the current path can be extended to a solution  This information is useful for pruning the search space  The algorithm is based on two mutually recursive steps  Forward  beginning at line    and Backtrack  beginning at line      which call each other  or themselves  until the search terminates  In the forward phase  the AND OR graph is expanded top down  The two types of nodes  AND and OR  are treated differently according to their semantics  Before an OR node is expanded  the cache table of its variable is checked  line     If the entry is not null  a link is created to the already existing OR node that roots the graph equivalent to the current subproblem  Otherwise  the OR node is expanded by generating its AND descendants  The OR to AND weight  see Definition     is computed in line     Each value xi of Xi is checked for consistency  line      The least expensive check is to verify that the OR to AND weight is non zero  However  the deterministic  inconsistent  assignments in M can be extracted to form a constraint network  Any level of constraint propagation can be performed in this step  e g   look ahead  arc consistency  path consistency  i consistency etc    The computational overhead can increase  in the hope of pruning the search space more aggressively  We should note that constraint propagation is not crucial for the algorithm  and the complexity guarantees are maintained even if only the simple weight check is performed  The consistent AND nodes are added to the list of successors of n  line      while the inconsistent ones are linked to the terminal   meta node  line      An AND node n labeled with hXi   xi i is expanded  line     based on the structure of the pseudo tree  If Xi is a leaf in T   then n is linked to the terminal   meta node  line      Otherwise  an OR node is created for each child of Xi in T  line      The forward step continues as long as the current node is not a dead end and still has unevaluated successors  The backtrack phase is triggered when a node has an empty set of successors  line      Note that  as each successor is processed  it is removed from the set of successors in line     When the backtrack reaches the root  line      the search is complete  the context minimal AND OR graph is generated  and the Procedure B OTTOM U P R EDUCTION is called  When the backtrack step processes an OR node  line      it saves a pointer to it in cache  and also adds a pointer to the corresponding meta node to the list LXi   The consistent attribute of        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Algorithm    AND OR S EARCH   AOMDD input   M   hX  D  Fi  pseudo tree T rooted at X    parents pai  OR context  for every variable Xi   output   AOMDD of M    forall Xi  X do Initialize context based cache table CacheXi  pai   with null entries     Create new OR node t  labeled with Xi   consistent t   true  push t on top of OPEN   while OPEN     do   n  top OPEN   remove n from OPEN    Forward   successors n      if n is an OR node labeled with Xi then    OR expand if CacheXi  asgn n   pai       null then   Connect parent of n to CacheXi  asgn n   pai         Use the cached pointer                                else forall xi  Di do Create new AN D node t  labeled with hXi   xi i w X  xi     f  asgn n   pai    f BT  Xi    if hXi   xi i is consistent with n then consistent t   true add t to successors n  else consistent t   f alse make terminal   the only child of t                           if n is an AND node labeled with hXi   xi i then if childrenT  Xi       then make terminal   the only child of n else forall Y  childrenT  Xi   do Create new OR node t  labeled with Y consistent t   f alse add t to successors n                      Add successors n  to top of OPEN while successors n      do let p be the parent of n if n is an OR node labeled with Xi then if Xi    X  then Call BottomUpReduction procedure                        Constraint Propagation     AND expand     Backtrack     Search is complete    begin reduction to AOMDD  Cache asgn n   pai     n Add meta node of n to the list LXi consistent p   consistent p   consistent n  if consistent p     f alse then remove successors p  from OPEN successors p            if n is an AND node labeled with hXi   xi i then consistent p   consistent p   consistent n           remove n from successors p  np          Save in cache     Check if p is dead end   M ATEESCU   D ECHTER   M ARINESCU  Procedure BottomUpReduction   A graphical model M   hX  D  Fi  a pseudo tree T of the primal graph  rooted at X    Context minimal AND OR graph  and lists LXi of meta nodes for each level Xi   output   AOMDD of M  Let d    X            Xn   be the depth first traversal ordering of T for i  n down to   do Let H be a hash table  initially empty forall meta nodes n in LXi do if H Xi   n children            n childrenki   wn  Xi   x             wn  Xki   xki    returns a meta node p then merge n with p in the AND OR graph input                              else if n is redundant then eliminate n from the AND OR graph combine its weight with that of the parent else hash n into the table H  H Xi   n children            n childrenki   wn  Xi   x             wn  Xki   xki     n     return reduced AND OR graph  the AND parent p is updated by conjunction with consistent n   If the AND parent p becomes inconsistent  it is not necessary to check its remaining OR successors  line      When the backtrack step processes an AND node  line      the consistent attribute of the OR parent p is updated by disjunction with consistent n   The AND OR search algorithm usually maintains a value for each node  corresponding to a task that is solved  We did not include values in our description because an AOMDD is just an equivalent representation of the original graphical model M  Any task over M can be solved by a traversal of the AOMDD  It is however up to the user to include more information in the meta nodes  e g   number of solutions for a subproblem       Reducing the Context Minimal AND OR Graph to an AOMDD Procedure BottomUpReduction processes the variables bottom up relative to the pseudo tree T   We use the depth first traversal ordering of T  line     but any other bottom up ordering is as good  The outer for loop  starting at line    goes through each level of the context minimal AND OR graph  where a level contains all the OR and AND nodes labeled with the same variable  in other words it contains all the meta nodes of that variable   For efficiency  and to ensure the complexity guarantees that we will prove  a hash table  initially empty  is used for each level  The inner for loop  starting at line    goes through all the metanodes of a level  that are also saved  or pointers to them are saved  in the list LXi   For each new meta node n in the list LXi   in line   the hash table H is checked to verify if a node isomorphic with n already exists  If the hash table H already contains a node p corresponding to the hash key  Xi   n children            n childrenki   wn  Xi   x             wn  Xki   xki     then p and n are isomorphic and should be merged  Otherwise  if the new meta node n is redundant  then it is eliminated from the AND OR graph  If none of the previous two conditions is met  then the new meta node n is hashed into table H         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  A D  G  C  B  F  E  A  H  B C D   a   F E  G  H   b   Figure      a  Constraint graph for C    C            C     where C    F  H  C    A  H  C    A  B  G  C    F  G  C    B  F   C    A  E  C    C  E  C    C  D  C    B  C   b  Pseudo tree  bucket tree  for ordering d    A  B  C  D  E  F  G  H   Proposition   The output of Procedure BottomUpReduction is the AOMDD of M along the pseudo tree T   namely the resulting AND OR graph is completely reduced  Note that we explicated Procedure BottomUpReduction separately only for clarity  In practice  it can actually be included in Algorithm AND OR S EARCH  AOMDD  and the reduction rules can be applied whenever the search backtracks  We can maintain a hash table for each variable  during the AND OR search  to store pointers to meta nodes  When the search backtracks out of an OR node  it can already check the redundancy of that meta node  and also look up in the hash table to check for isomorphism  Therefore  the reduction of the AND OR graph can be done during the AND OR search  and the output will be the AOMDD of M  From Theorem   and Proposition   we can conclude  T HEOREM   Given a graphical model M and a pseudo tree T of its primal graph G  the AOMDD  of M corresponding to T has size bounded by O n k wT  G    and it can be computed by Algorithm  AND OR S EARCH  AOMDD in time O n k wT  G     where wT  G  is the induced width of G over the depth first traversal of T   and k bounds the domain size      Using Bucket Elimination to Generate AOMDDs In this section we propose to use a Bucket Elimination  BE  type algorithm to guide the compilation of a graphical model into an AOMDD  The idea is to express the graphical model functions as AOMDDs  and then combine them with APPLY operations based on a BE schedule  The APPLY is very similar to that from OBDDs  Bryant         but it is adapted to AND OR search graphs  It takes as input two functions represented as AOMDDs based on the same pseudo tree  and outputs the combination of initial functions  also represented as an AOMDD based on the same pseudo tree  We will describe it in detail in Section      We will start with an example based on constraint networks  This is easier to understand because the weights on the arcs are all   or    and therefore are depicted in the figures by solid and dashed lines  respectively  Example    Consider the network defined by X    A  B          H   DA           DH          and the constraints  where  denotes XOR   C    F H  C    AH  C    ABG  C    F G        M ATEESCU   D ECHTER   M ARINESCU  m   A  m  A  A          B          C    C                   C       A     B  B        F  C    B          F          F    B  F              B  C D    D  G  E                      m   G       H             D  E     m   F  H    G  m   m   A       B  C     C    A           D          C  C          F  B           A           G                    H       B  F    G       F  F     F       A  B    B    E  D       B  A     H     H       F    C                m   C   C     E     C  D             E  D     C                   G              C  A       C   C                           B  H          A       H     G  E  C         A     G    G  F  F    B  G  H  m   m      B       C   m   A  A     E  E        C   m   A    D  D  D  m   m            m   C      H       F     F            G  C   C   H  Figure     Execution of BE with AOMDDs A    A     B    B       B     B  C C    C       C       C       F       F       F       C        D     D  E  D    D       E       G       G       H       C  C  F     D  D  E  F  H    D  E  F  F  F     G  G  G  G  H     D     H      a   G      b   Figure      a  The final AOMDD   b  The OBDD corresponding to d C    B  F   C    A  E  C    C  E  C    C  D  C    B  C  The constraint graph is shown in Figure    a   Consider the ordering d    A  B  C  D  E  F  G  H   The pseudo tree  or bucket tree  induced by d is given in Fig     b   Figure    shows the execution of BE with AOMDDs along ordering d  Initially  the constraints C  through C  are represented as AOMDDs and placed in the bucket of their latest variable in d  The scope of any original constraint always appears on a        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Algorithm    BE AOMDD   Graphical model M   hX  D  Fi  where X    X            Xn    F    f            fr     order d    X            Xn   output   AOMDD representing iF fi   T   GeneratePseudoTree G  d     for i    to r do    place functions in buckets   place Gfaomdd in the bucket of its latest variable in d i input    for i  n down to   do message Xi    G aomdd     while bucket Xi       do   pick Gfaomdd from bucket Xi               process buckets    initialize with AOMDD of        combine AOMDDs in bucket of Xi  bucket Xi    bucket Xi      Gfaomdd    message Xi    APPLY message Xi    Gfaomdd   add message Xi   to the bucket of the parent of Xi in T     return message X     path from root to a leaf in the pseudo tree  Therefore  each original constraint is represented by an AOMDD based on a chain  i e   there is no branching into independent components at any point   The chain is just the scope of the constraint  ordered according to d  For bi valued variables  the original constraints are represented by OBDDs  for multiple valued variables they are MDDs  Note that we depict meta nodes  one OR node and its two AND children  that appear inside each gray node  The dotted edge corresponds to the   value  the low edge in OBDDs   the solid edge to the   value  the high edge   We have some redundancy in our notation  keeping both AND value nodes and arc types  dotted arcs from   and solid arcs from     The BE scheduling is used to process the buckets in reverse order of d  A bucket is processed by joining all the AOMDDs inside it  using the APPLY operator  However  the step of elimination of the bucket variable is omitted because we want to generate the full AOMDD  In our example  the messages m    C     C  and m    C     C  are still based on chains  therefore they are OBDDs  Note that they contain the variables H and G  which have not been eliminated  However  the message m    C     m     m  is not an OBDD anymore  We can see that it follows the structure of the pseudo tree  where F has two children  G and H  Some of the nodes corresponding to F have two outgoing edges for value    The processing continues in the same manner  The final output of the algorithm  which coincides with m    is shown in Figure    a   The OBDD based on the same ordering d is shown in Fig     b   Notice that the AOMDD has    nonterminal nodes and    edges  while the OBDD has    nonterminal nodes and    edges      Algorithm BE AOMDD Algorithm    called BE AOMDD  creates the AOMDD of a graphical model by using a BE schedule for APPLY operations  Given an order d of the variables  first a pseudo tree is created based on   the primal graph  Each initial function fi is then represented as an AOMDD  denoted by Gfaomdd i and placed in its bucket  To obtain the AOMDD of a function  the scope of the function is ordered according to d  a search tree  based on a chain  that represents fi is generated  and then reduced by Procedure BottomUpReduction  The algorithm proceeds exactly like BE  with the only difference that the combination of functions is realized by the APPLY algorithm  and variables are not       M ATEESCU   D ECHTER   M ARINESCU  eliminated but carried over to the destination bucket  The messages between buckets are initialized with the dummy AOMDD of    denoted by G aomdd   which is neutral for combination  In order to create the compilation of a graphical model based on AND OR graphs  it is necessary to traverse the AND OR graph top down and bottom up  This is similar to the inward and outward message passing in a tree decomposition  Note that BE AOMDD describes the bottom up traversal explicitly  while the top down phase is actually performed by the APPLY operation  When two AOMDDs are combined  after the top chain portion of their pseudo tree is processed  the remaining independent branches are attached only if they participate in the newly restricted set of solutions  This amounts to an exchange of information between the independent branches  which is equivalent to the top down phase      The AOMDD APPLY Operation We will now describe how to combine two AOMDDs  The APPLY operator takes as input two AOMDDs representing functions f  and f  and returns an AOMDD representing f   f    In OBDDs the apply operator combines two input diagrams based on the same variable ordering  Likewise  in order to combine two AOMDDs we assume that their pseudo trees are identical  This condition is satisfied by any two AOMDDs in the same bucket of BE AOMDD  However  we present here a version of APPLY that is more general  by relaxing the previous condition from identical to compatible pseudo trees  Namely  there should be a pseudo tree in which both can be embedded  In general  a pseudo tree induces a strict partial order between the variables where a parent node always precedes its child nodes  D EFINITION     compatible pseudo trees  A strict partial order d     X       over a set X is consistent with a strict partial order d     Y       over a set Y  if for all x    x   X  Y  if x     x  then x     x    Two partial orders d  and d  are compatible iff there exists a partial order d that is consistent with both  Two pseudo trees are compatible iff the partial orders induced via the parent child relationship  are compatible  For simplicity  we focus on a more restricted notion of compatibility  which is sufficient when using a BE like schedule for the APPLY operator to combine the input AOMDDs  as described in Section     The APPLY algorithm that we will present can be extended to the more general notion of compatibility  D EFINITION     strictly compatible pseudo trees  A pseudo tree T  having the set of nodes X  can be embedded in a pseudo tree T having the set of nodes X if X   X and T  can be obtained from T by deleting each node in X   X  and connecting its parent to each of its descendents  Two pseudo trees T  and T  are strictly compatible if there exists T such that both T  and T  can be embedded in T   Algorithm APPLY  algorithm    takes as input one node from Gfaomdd and a list of nodes from Ggaomdd   Initially  the node from Gfaomdd is its root node  and the list of nodes from Ggaomdd is in fact also made of just one node  which is its root  We will sometimes identify an AOMDD by its root node  The pseudo trees Tf and Tg are strictly compatible  having a target pseudo tree T   The list of nodes from Ggaomdd always has a special property  there is no node in it that can be the ancestor in T of another  we refer to the variable of the meta node   Therefore  the list z            zm       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  APPLY  v    z            zm   input   AOMDDs Gfaomdd with nodes vi and Ggaomdd with nodes zj   based on strictly compatible pseudo trees Tf   Tg that can be embedded in T   var v    is an ancestor of all var z             var zm   in T   var zi   and var zj   are not in ancestor descendant relation in T   i    j  output   v    z          zm    based on T   if H   v    z            zm      null then return H   v    z            zm       is in cache if  any of v    z            zm is    then return   if  v       then return   if  m      then return v     nothing to combine create new nonterminal meta node u var u   var v     call it Xi   with domain Di    x            xki     for j    to ki do u childrenj      children of the j th AND node of u    assign weight from v  wu  Xi   xj    wv   Xi   xj   if    m      and  var v      var z      Xi     then temp Children  z   childrenj    combine input weights wu  Xi   xj    wv   Xi   xj    wz   Xi   xj    Algorithm                                       else                  group nodes from v   childrenj  temp Children in several  v     z             z r   for each  v     z             z r   do y  APPLY v     z             z r   if  y      then u childrenj     break         temp Children   z            zm    else u childrenj  u childrenj   y             if  u children            u childrenki   and  wu  Xi   x              wu  Xi   xki    then promote wu  Xi   x    to parent return u children     redundancy         if  H   Xi   u children            u childrenki   wu  Xi   x             wu  Xki   xki       null  then return H   Xi   u children            u childrenki   wu  Xi   x             wu  Xki   xki       isomorphism     Let H   v    z            zm     u    Let H   Xi   u children            u childrenki   w u  Xi   x             w u  Xki   xki      u    return u     add u to H     add u to H   from g expresses a decomposition with respect to T   so all those nodes appear on different branches  We will employ the usual techniques from OBDDs to make the operation efficient  First  if one of the arguments is    then we can safely return    Second  a hash table H  is used to store the nodes that have already been processed  based on the nodes  v    z            zr    Therefore  we never need to make multiple recursive calls on the same arguments  Third  a hash table H  is used to detect isomorphic nodes  This is typically split in separate tables for each variable  If at the end of the recursion  before returning a value  we discover that a meta node with the same variable  the same children and the same weights has already been created  then we dont need to store it and we simply return the existing node  And fourth  if at the end of the recursion we discover that we created a redundant node  all the children are the same and all the weights are the same   then we dont store it  and return instead one of its identical lists of children  and promote the common weight        M ATEESCU   D ECHTER   M ARINESCU  A                  B                  C                  f ABC                   A                  A B C  A  A        C  A         A   B   A   B      B  B  D  D     D    D  C  A          A  A B  B     B   A     B          g ABC                   A          D                  B     B  A   B                     B      B  A B   B         C    B      A B      A         D  B        B       D  B              Figure     Example of APPLY operation Note that v  is always an ancestor of all z            zm in T   We consider a variable in T to be an ancestor of itself  A few self explaining checks are performed in lines      Line   is specific for multiplication  and needs to be changed for other combination operations  The algorithm creates a new meta node u  whose variable is var v      Xi  recall that var v    is highest  closest to root  in T among v    z            zm   Then  for each possible value of Xi   line    it starts building its list of children  One of the important steps happens in line     There are two lists of meta nodes  one from each original AOMDD f and g  and we will refer only to their variables  as they appear in T   Each of these lists has the important property mentioned above  that its nodes are not ancestors of each other  The union of the two lists is grouped into maximal sets of nodes  such that the highest node in each set is an ancestor of all the others  It follows that the root node in each set belongs to one of the original AOMDD  say v   is from f   and the others  say z             z r are from g  As an example  suppose T is the pseudo tree from Fig     b   and the two lists are  C  G  H  from f and  E  F   from g  The grouping from line    will create  C  E  and  F   G  H   Sometimes  it may be the case that a newly created group contains only one node  This means there is nothing more to join in recursive calls  so the algorithm will return  via line    the single node  From there on  only one of the input AOMDDs is traversed  and this is important for the complexity of APPLY  discussed below  Example    Figure    shows the result of combining two Boolean functions by an AND operation  or product   The input functions f and g are represented by AOMDDs based on chain pseudo trees  while the results is based on the pseudo tree that expresses the decomposition after variables A and B are instantiated  The APPLY operator performs a depth first traversal of the two input AOMDDs  and generates the resulting AOMDD based on the output pseudo tree  Similar to the case of OBDDs  a function or an AOMDD can be identified by its root meta node  In this example the input meta nodes have labels  A    A    B    B    etc    The output meta node labeled by A  B  is       AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  the root of a diagram that represents the function obtained by combining the functions rooted by A  and B        Complexity of APPLY and BE AOMDD We now provide a characterization of the complexity of APPLY  based on different criteria  The following propositions are inspired by the results that govern OBDD apply complexity  but are adapted for pseudo tree orderings  An AOMDD along a pseudo tree can be regarded as a union of regular MDDs  each restricted to a full path from root to a leaf in the pseudo tree  Let T be such a path in T   Based on the definition of strictly compatible pseudo trees  T has corresponding paths Tf in Tf and Tg in Tg   The MDDs from f and g corresponding to Tf and Tg can be combined using the regular MDD apply  This process can be repeated for every path T   The resulting MDDs  one for each path in T need to be synchronized on their common parts  on the intersection of the paths   The algorithm we proposed does all this processing at once  in a depth first search traversal over the inputs  Based on our construction  we can give a first characterization of the complexity of AOMDD APPLY as being governed by the complexity of MDD apply  Proposition   Let             l be the set of paths in T enumerated from left to right and let Gfi and Ggi be the MDDs restricted to path i   then the size of the output of AOMDD apply by P P is bounded i     G i    n  max  G i     G i    The time complexity is also bounded by i     G i     G  G i g g g i f i f f n  maxi  Gfi     Ggi    A second characterization of the complexity can be given  similar to the MDD case  in terms of total number of nodes of the inputs  Proposition   Given two AOMDDs Gfaomdd and Ggaomdd based on strictly compatible pseudo trees  the size of the output of APPLY is at most O   Gfaomdd      Ggaomdd     We can further detail the previous proposition as follows  Given AOMDDs Gfaomdd and Ggaomdd   based on compatible pseudo trees Tf and Tg and the common pseudo tree T   we define the intersection pseudo tree Tf g as being obtained from T by the following two steps      mark all the subtrees whose nodes belong to either Tf or Tg but not to both  the leaves of each subtree should be leaves in T        remove the subtrees marked in step     from T   Steps     and     are applied just once  that is  not recursively   The part of AOMDD Gfaomdd corresponding to the variables in Tf g is denoted by Gff g   and similarly for Ggaomdd it is denoted by Ggf g   Proposition   The time complexity of  Gfaomdd      Ggaomdd      APPLY  and the size of the output are O  Gff g     Ggf g      We now turn to the complexity of the BE AOMDD algorithm  Each bucket has an associated bucket pseudo tree  The top chain of the bucket pseudo tree for variable Xi contains all and only the variables in context Xi    For any other variables that appear in the bucket pseudo tree  their associated buckets have already been processed  The original functions that belong to the bucket of Xi have their scope included in context Xi    and therefore their associated AOMDDs are based       M ATEESCU   D ECHTER   M ARINESCU  on chains  Any other functions that appear in bucket of Xi are messages received from independent branches below  Therefore  any two functions in the bucket of Xi only share variables in the context Xi    which forms the top chain of the bucket pseudo tree  We can therefore characterize the complexity of APPLY in terms of treewidth  or context size of a bucket variable  Proposition   Given two AOMDDs in the same bucket of BE AOMDD  the time and space complexity of the APPLY between them is at most exponential in the context size of the bucket variable  namely the number of the variables in the top chain of the bucket pseudo tree   We can now bound the complexity of BE AOMDD and the output size  T HEOREM   The space complexity of BE AOMDD and the size of the output AOMDD are  O n k w    where n is the number of variables  k is the maximum domain size and w is the treewidth  of the bucket tree  The time complexity is bounded by O r k w    where r is the number of initial functions      AOMDDs Are Canonical Representations It is well known that OBDDs are canonical representations of Boolean functions given an ordering of the variables  Bryant         namely a strict ordering of any CNF specification of the same Boolean function will yield an identical OBDD  and this property extends to MDDs  Srinivasan et al          The linear ordering of the variables defines a chain pseudo tree that captures the structure of the OBDD or MDD  In the case of AOBDDs and AOMDDs  the canonicity is with respect to a pseudo tree  transitioning from total orders  that correspond to a linear ordering  to partial orders  that correspond to a pseudo tree ordering   On the one hand we gain the ability to have a more compact compiled structure  but on the other hand canonicity is no longer with respect to all equivalent graphical models  but only relative to those graphical models that are consistent with the pseudo tree that is used  Specifically  if we start from a strict ordering we can generate a chain AOMDD that will be canonical relative to all equivalent graphical models  If however we want to exploit additional decomposition we can use a partial ordering captured by a pseudo tree and create a more compact AOMDD  This AOMDD however is canonical relative to those equivalent graphical models that can accept the same pseudo tree that guided the AOMDD  In general  AOMDD can be viewed as a more flexible framework for compilation that allows both partial and total orderings  Canonicity is restricted to a subset of graphical models whose primal graph agrees with the partial order but it is relevant to a larger set of orderings which are consistent with the pseudo tree  In the following subsection we discuss the canonicity of AOMDD for constraint networks  The case of general weighted graphical models is discussed in Section        AOMDDs for Constraint Networks Are Canonical Representations The case of constraint networks is more straightforward  because the weights on the OR to AND arcs can only be   or    We will show that any equivalent constraint networks  that admit the same pseudo tree T   have the same AOMDD based on T   We start with a proposition that will help prove the main theorem  Proposition   Let f be a function  not always zero  defined by a constraint network over X  Given a partition  X            Xm   of the set of variables X  namely  Xi  Xj      i    j  and X         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  i i m i   X    if f   f          fm and f   g          gm   such that scope fi     scope gi     X for all i              m   then fi   gi for all i              m   Namely  if f can be decomposed over the given partition  then the decomposition is unique   We are now ready to show that AOMDDs for constraint networks are canonical representations given a pseudo tree  T HEOREM    AOMDDs are canonical for a given pseudo tree  Given a constraint network  and a pseudo tree T of its constraint graph  there is a unique  up to isomorphism  AOMDD that represents it  and it has the minimal number of meta nodes  A constraint network is defined by its relations  or functions   There exist equivalent constraint networks that are defined by different sets of functions  even having different scope signatures  However  equivalent constraint networks define the same function  and we can ask if the AOMDD of different equivalent constraint networks is the same  The following corollary can be derived immediately from Theorem    Corollary   Two equivalent constraint networks that admit the same pseudo tree T have the same AOMDD based on T       Canonical AOMDDs for Weighted Graphical Models Theorem   ensures that the AOMDD is canonical for constraint networks  namely for functions that can only take the values   or    The proof relied on the fact that the OR to AND weights can only be   or    and on Proposition   that ensured the unique decomposition of a function defined by a constraint network  In this section we turn to general weighted graphical models  We can first observe that Proposition   is no longer valid for general functions  This is because the valid solutions  having strictly positive weight  can have their weight decomposed in more than one way into a product of positive weights  Therefore we raise the issue of recognizing nodes that root AND OR graphs that represent the same universal function  even though the graphical representation is different  We will see that the AOMDD for a weighted graphical model is not unique under the current definitions  but we can slightly modify them to obtain canonicity again  We have to note that canonicity of AOMDDs for weighted graphical models  e g   belief networks  is far less crucial than in the case of OBDDs that are used in formal verification  Even more than that  sometimes it may be useful not to eliminate the redundant nodes  in order to maintain a simpler semantics of the AND OR graph that represents the model  The loss of canonicity of AOMDD for weighted graphical models can happen because of the weights on the OR to AND arcs  and we suggest a possible way of re enforcing it if a more compact and canonical representation is needed  Example    Figure    shows a weighted graphical model  defined by two  cost  functions  f  M  A  B  and g M  B  C   Assuming the order  M A B C   Figure    shows the AND OR search tree on the left  The arcs are labeled with function values  and the leaves show the value of the corresponding full assignment  which is the product of numbers on the arcs of the path   We can       M ATEESCU   D ECHTER   M ARINESCU  A  M                  M A  M  B B C  C  A                  B f M A B                                      M                  B                  C g M B C                                      Figure     Weighted graphical model M             A  A  A  A        B     B                        C  C                        C                                        B            C         B         M  C  B           C  C                                                                         B                               C                             B       C        B     C                                   C  C                                         Figure     AND OR search tree and context minimal graph  see that either value of M    or    gives rise to the same function  because the leaves in the two subtrees have the same values   However  the two subtrees can not be identified as representing the same function by the usual reduction rules  The right part of the figure shows the context minimal graph  which has a compact representation of each subtree  but does not share any of their parts  What we would like in this case is to have a method of recognizing that the left and right subtrees corresponding to M     and M     represent the same function  We can do this by normalizing the values in each level  and processing bottom up  In Figure    left  the values on the OR to AND arcs have been normalized  for each OR variable  and the normalization constant was promoted up to the OR value  In Figure    right  the normalization constants are promoted upwards again by multiplication  This process does not change the value of each full assignment  and therefore produces equivalent graphs  We can see already that some of the nodes labeled by C can now be merged  producing the graph in Figure    on the left  Continuing the same process we obtain the AOMDD for the weighted graph  shown in Figure    on the right  We can define the AOMDD of a weighted graphical model as follows  D EFINITION     AOMDD of weighted graphical model  The AOMDD of a weighted graphical model is an AND OR graph  with meta nodes  such that      for each meta node  its weights sum to        the root meta node has a constant associated with it      it is completely reduced  namely it has no isomorphic meta nodes  and no redundant meta nodes         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  M M        A  A        B     B  B                                                                                                                                                       B                           C          B        C            B           C      A  B         C     A    B          C  C                    C        C                                      Figure     Normalizing values bottom up      M         M            A     A A        B           B                     B              B                  C                                   B      B                            C                                       C                   C                         Figure     AOMDD for the weighted graph The procedure of transforming a weighted AND OR graph into an AOMDD is very similar to Procedure B OTTOM U P R EDUCTION from Section    The only difference is that when a new layer is processed  first the meta node weights are normalized and promoted to the parent  and then the procedure continues as usual with the reduction rules  T HEOREM   Given two equivalent weighted graphical models that accept a common pseudo tree T   normalizing arc values together with exhaustive application of reduction rules yields the same AND OR graph  which is the AOMDD based on T   Finite Precision Arithmetic The implementation of the algorithm described in this section may prove to be challenging on machines that used finite precision arithmetic  Since the weights are real valued  the repeated normalization may lead to precision errors  One possible approach  which we also used in our experiments  is to define some  tolerance  for some user defined sufficiently small   and consider the weights to be equal if they are within  of each other      Semantic Treewidth A graphical model M represents a universal function F   fi   The function F may be represented by different graphical models  Given a particular pseudo tree T   that captures some of the structural information of F   we are interested in all the graphical models that accept T as a pseudo tree  namely their primal graphs only contain edges that are backarcs in T   Since the size of the AOMDD for F based on T is bounded in the worst case by the induced width of the graphical model along T   we define the semantic treewidth to be        M ATEESCU   D ECHTER   M ARINESCU    A        B C  C  o B  o        A        o o  C D  A  o  D  B     o  A B                          o o   a  The two solutions  A C                                  A D                                          D B C                          B D                                  C D                           b  First model  A  A B          B  C  B C          D  C D           c  Second model  Figure     The   queen problem D EFINITION     semantic treewidth  The semantic treewidth of a graphical model M relative to a pseudo tree T denoted by swT  M   is the smallest treewidth taken over all models R that are equivalent to M  and accept the pseudo tree T   Formally  it is defined by swT  M    minR u R  u M  wT  R   where u M  is the universal function of M  and wT  R  is the induced width of R along T   The semantic treewidth of a graphical model  M  is the minimal semantic treewidth over all the pseudo trees that can express its universal function  Computing the semantic treewidth can be shown to be NP hard   T HEOREM   Computing the semantic treewidth of a graphical model M is NP hard  Theorem   shows that computing the semantic treewidth is hard  and it is likely that the actual complexity is even higher  However  the semantic treewidth can explain why sometimes the minimal AND OR graph or OBDD are much smaller than the exponential in treewidth or pathwidth upper bounds  In many cases  there could be a huge disparity between the treewidth of M and the semantic treewidth along T   Example    Figure    a  shows the two solutions of the   queen problem  The problem is expressed by a complete graph of treewidth    given in Figure    b   Figure    c  shows an equivalent problem  i e   that has the same set of solutions   which has treewidth    The semantic treewidth of the   queen problem is    Based on the fact that an AOMDD is a canonical representation of the universal function of a graphical model  we can conclude that the size of the AOMDD is bounded exponentially by the semantic treewidth along the pseudo tree  rather than the treewidth of the given graphical model representation  Proposition   The size of the AOMDD of a graphical model M is bounded by O n k swT  M     where n is the number of variables  k is the maximum domain size and swT  M  is the semantic treewidth of M along the pseudo tree T      We thank David Eppstein for the proof         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  A A  B  B  C  C  B  M  D  D  C  N  D  P         a  OBDD representation   b  Primal graph with hidden variables M  N and P    Figure     The parity function Example    Consider a constraint network on n variables such that every two variables are constrained by equality  X   Y    One graph representation is a complete graph  another is a chain and another is a tree  If the problem is specified as a complete graph  and if we use a linear order  the OBDD will have a linear size because there exists a representation having a pathwidth of    rather than n   While the semantic treewidth can yield a much better upper bound on the AOMDD  it can also be a very bad bound  It is well known that the parity function on n variables has a very compact  chain like OBDD representation  Yet  the only constraint network representation of a parity function is the function itself  namely a complete graph on all the variables   whose treewidth and semantic treewidth is its number of variables  n  The OBDD representation of the parity function suggests that the addition of hidden variables can simplify its presentation  We show an example in Figure     On the left side  in Figure    a  we have the OBDD representation of the parity function for four binary variables  A graphical model would represent this function by a complete graph on the four variables  However  we could add the extra variables M  N and P in Figure    b   sometimes called hidden variables  that can help decompose the model  In this case M can form a constraint together with A and B such that M represents the parity of A and B  namely M     if A  B      where  is the parity  XOR  operator  Similarly  N would capture the parity of M and C  and P would capture the parity of N and D  and would also give the parity of the initial four variables  The two structures are surprisingly similar  It would be interesting to study further the connection between hidden variables and compact AOBDDs  but we leave this for future work       Experimental Evaluation Our experimental evaluation is in preliminary stages  but the results we have are already encouraging  We ran the search based compile algorithm  by recording the trace of the AND OR search  and then reducing the resulting AND OR graph bottom up  In these results we only applied the reduction by isomorphism and still kept the redundant meta nodes  We implemented our algorithms in C   and ran all experiments on a    GHz Intel Core   Duo with  GB of RAM  running Windows         M ATEESCU   D ECHTER   M ARINESCU       Benchmarks We tested the performance of the search based compilation algorithm on random Bayesian networks  instances from the Bayesian Network Repository and a subset of networks from the UAI   Inference Evaluation Dataset  Random Bayesian Networks The random Bayesian networks were generated using parameters  n  k  c  p   where n is the number of variables  k is the domain size  c is the number of conditional probability tables  CPTs  and p is the number of parents in each CPT  The structure of the network was created by randomly picking c variables out of n and  for each  randomly picking p parents from their preceding variables  relative to some ordering  The remaining n  c variables are called root nodes  The entries of each probability table were generated randomly using a uniform distribution  and the table was then normalized  It is also possible to control the amount of determinism in the network by forcing a percentage det of the CPTs to have only   and   entries  Bayesian Network Repository The Bayesian Network Repository  contains a collection of belief networks extracted from various real life domains which are often used for benchmarking probabilistic inference algorithms  UAI   Inference Evaluation Dataset The UAI      Inference Evaluation Dataset  contains a collection of random as well as real world belief networks that were used during the first UAI      Inference Evaluation contest  For our purpose we selected a subset of networks which were derived from the ISCAS   digital circuits benchmark   ISCAS   circuits are a common benchmark used in formal verification and diagnosis  Each of these circuits was converted into a Bayesian network by removing flip flops and buffers in a standard way  creating a deterministic conditional probability table for each gate  and putting uniform distributions on the input signals       Algorithms We consider two search based compilation algorithms  denoted by AOMDD BCP and AOMDDSAT  respectively  that reduce the context minimal AND OR graph explored via isomorphism  while exploiting the determinism  if any  present in the network  The approach we take for handling the determinism is based on unit resolution over a CNF encoding  i e   propositional clauses  of the zero probability tuples of the CPTs  The idea of using unit resolution during search for Bayesian networks was first explored by Allen and Darwiche         AOMDD BCP is conservative and applies only unit resolution at each node in the search graph  whereas AOMDD SAT is more aggressive and detects inconsistency by running a full SAT solver  We used the zChaff SAT solver  Moskewicz  Madigan  Zhao  Zhang    Malik        for both unit resolution as well as full satisfiability  For comparison  we also ran an OR version of AOMDD BCP  called MDD BCP  For reference we also report results obtained with the ACE  compiler  ACE compiles a Bayesian network into an Arithmetic Circuit  AC  and then uses the AC to answer multiple queries with respect to the network  An arithmetic circuit is a representation that is equivalent to AND OR graphs  Mateescu   Dechter         Each time ACE compiler is invoked  it uses one of two algorithms as the basis for compilation  First  if an elimination order can be generated for the network having              http   www cs huji ac il compbio Repository  http   ssli ee washington edu bilmes uai  InferenceEvaluation Available at  http   www fm vslib cz kes asic iscas  Available at  http   reasoning cs ucla edu ace        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Network   w   h    n  k   ACE  nodes time  MDD w  BCP AOMDD w  BCP AOMDD w  SAT  meta  cm OR  time  meta  cm OR  time  meta  cm OR  time Bayesian Network Repository alarm                                                                            cpcs                                                                         cpcs                                                                       cpcs   b                                  diabetes                                  hailfinder                                                               mildew                                                                               mm                                                                         munin                                    munin                                    munin                                    pathfinder                                                                                              pigs                                                                                 water                                                                                            UAI   Evaluation Dataset BN                                                                             BN                                                                                       BN                                                                             BN                                                                                 BN                                                                                               BN                                                                                      BN                                                                                    BN                                                                                      BN                                                                                      BN                                                                                BN                                                                                    BN                                                                                              BN                                                                                      BN                                                                                       BN                                                                          BN                                                                         Positive Random Bayesian Networks  n     k    p    c     r                                                                          r                                                                          r                                                                          r                                                                    r                                                                           r                                                                           r                                                                          r                                                                          r                                                                    r                                                                     Deterministic Random Bayesian Networks  n      k    p    c     and det       of the CPTs containing only   and   entries r   d                                                                            r   d                                                                             r   d                                                                                  r   d                                                                             r   d                                                                                  r   d                                                                                  r   d                                                                                  r   d                                                                            r   d                                                                             r   d                                                                               Table    Results for experiments with    Bayesian networks from   problem classes  w   treewidth  h   depth of pseudo tree  n   number of variables  k   domain size  time given in seconds  bold types highlight the best results across rows         M ATEESCU   D ECHTER   M ARINESCU  sufficiently small induced width  then tabular variable elimination will be used as the basis  This algorithm is similar to the one discussed by Chavira and Darwiche         but uses tables to represent factors rather than ADDs  If the induced width is large  then logical model counting will be used as the basis  Tabular variable elimination is typically efficient when width is small but cannot handle networks when the width is larger  Logical model counting  on the other hand  incurs more overhead than tabular variable elimination  but can handle many networks having larger treewidth  Both tabular variable elimination and logical model counting produce ACs that exploit local structure  leading to efficient online inference  When logical model counting is invoked  it proceeds by encoding the Bayesian network into a CNF  Chavira   Darwiche        Chavira  Darwiche    Jaeger         simplifying the CNF  compiling the CNF into a d DNNF  and then extracting the AC from the compiled d DNNF  A dtree over the CNF clauses drives the compilation step  In all our experiments we report the compilation time in seconds  time   the number of OR nodes in the context minimal graph explored   cm   the number of meta nodes of the resulting AOMDD   meta   as well as the size of the AC compiled by ACE   nodes   For each network we specify the number of variables  n   domain size  k   induced width  w   and pseudo tree depth  h   A   stands for exceeding the  GB memory limit by the respective algorithm  The best performance points are highlighted       Evaluation on Bayesian Networks Table   reports the results obtained for experiments with    Bayesian networks  The AOMDD compilers as well as ACE used the min fill heuristic  Kjaerulff        to construct the guiding pseudo tree and dtree  respectively         BAYESIAN N ETWORKS R EPOSITORY We see that ACE is overall the fastest compiler on this domain  outperforming both AOMDD BCP and AOMDD SAT with up to several orders of magnitude  e g   mildew  pigs   However  the diagrams compiled by ACE and AOMDD BCP  resp  AOMDD SAT  are comparable in size  In some cases  AOMDD BCP and AOMDD SAT were able to compile much smaller diagrams than ACE  For example  the diagram produced by AOMDD BCP for the mildew network is    times smaller than the one compiled by ACE  In principle the output produced by ACE and AOMDD should be similar if both are guided by the same pseudo tree dtree  Our scheme should be viewed as a compilation alternative which     extends decision diagrams and     mimics traces of search properties that may make this representation accessible  The OR compiler MDD BCP was able to compile only   out of the    test instances  but their sizes were far larger than those produced by AOMDD BCP  For instance  on the pathfinder network  AOMDD BCP outputs a decision diagram almost   orders of magnitude smaller than MDD BCP         UAI   DATASET For each of the UAI   Dataset instances we picked randomly    variables and instantiated as evidence  We see that ACE is the best performing compiler on this dataset  AOMDD BCP is competitive with ACE in terms of compile time only on   out the    test instances  AOMDD SAT is able to compile the smallest diagrams for   networks only  e g   BN     BN     BN     BN     BN     BN      As before  the difference in size between the compiled data structures produces by MDD BCP and AOMDD BCP is up to   orders of magnitude in favor of the latter        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS         R ANDOM N ETWORKS The problem instances denoted by r     through r      were generated from a class of random belief networks with parameters  n       k      p      c        Similarly  the instances denoted by r   d     through r   d      belong to a class with parameters  n        k      p      c        In the latter case  det       of the CPTs are deterministic  namely they contain only   and   probability tuples  These test instances were compiled without any evidence  We see that on this domain AOMDD BCP AOMDD SAT were able to compile the smallest diagrams  which were on average about   times smaller than those produced by ACE  However  ACE was again the fastest compiler  Notice that the OR compiler MDD BCP ran out of memory in all test cases       The Impact of Variable Ordering As theory dictates  the AOMDD size is influenced by the quality of the guiding pseudo tree  In addition to the min fill heuristic we also considered the hypergraph heuristic which constructs the pseudo tree by recursively decomposing the dual hypergraph associated with the graphical model  This idea was also explored by Darwiche        for constructing dtrees that guide ACE  Since both the min fill and hypergraph partitioning heuristics are randomized  namely ties are broken randomly   the size of the AOMDD guided by the resulting pseudo tree may vary significantly from one run to the next  Figure    displays the AOMDD size using hypergraph and min fill based pseudo trees for   networks selected from Table    over    independent runs  We also record the average induced width and depth obtained for the pseudo trees  see the header of each plot in Figure      We see that the two heuristics do not dominate each other  namely the variance in output size is quite significant in both cases       Memory Usage Table   shows the memory usage  in MBytes  of ACE  AOMDD BCP and AOMDD SAT  respectively  on the Bayesian networks from Table    We see that in some cases the AOMDD based compilers require far less memory than ACE  For example  on the mildew network  both AOMDDBCP and AOMDD SAT use about    MB of memory to compile the AND OR decision diagram  while ACE requires as much as     MB of memory  Moreover  the compiled AOMDD has in this case about one order of magnitude fewer nodes than that constructed by ACE  When comparing the two AND OR search based compilers  we observe that on networks with a significant amount of determinism  such as those from the UAI   Evaluation dataset  AOMDD SAT uses on average two times less memory than AOMDD BCP  The most dramatic savings in memory usage due to the aggressive constraint propagation employed by AOMDD SAT compared with AOMDD BCP can be seen on the BN    network  In this case  the difference in memory usage between AOMDD SAT and AOMDD BCP is about   orders of magnitude in favor of the former       Related Work The related work can be viewed along two directions      the work related to the AND OR search idea for graphical models and     the work related to compilation for graphical models that exploits problem structure  An extensive discussion for     was provided in the previous work of Dechter and Mateescu         Since this is not the focus of the paper  we just mention that the AND OR idea was origi      M ATEESCU   D ECHTER   M ARINESCU  Figure     Effect of variable ordering         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Network  ACE AOMDD w  BCP AOMDD w  SAT  nodes memory  MB   nodes memory  MB   nodes memory  MB  Bayesian Network Repository alarm                                  cpcs                                            cpcs                                          cpcs   b                  diabetes                  hailfinder                                      mildew                                              mm                                           munin                   munin                   munin            n a pathfinder                                        pigs                                               water                                            UAI   Evaluation Dataset BN          n a                              BN           n a                                   BN          n a                              BN           n a                                BN          n a                            BN          n a                           BN          n a                         BN          n a                           BN          n a                           BN          n a                         BN          n a                         BN          n a                             BN          n a                           BN          n a                           BN          n a                             BN          n a                           Positive Random Bayesian Networks with parameters  n     k    p    c     r                                             r                                             r                                             r                                           r                                              r                                              r                                             r                                             r                                           r                                            Deterministic Random Bayesian Networks with parameters  n      k    p    c     r   d                                             r   d                                               r   d                                                 r   d                                               r   d                                                 r   d                                                 r   d                                                 r   d                                              r   d                                              r   d                                                 Table    Memory usage in MBytes of ACE  AOMDD BCP and AOMDD SAT on the    Bayesian networks from Table    Bold types highlight the best performance across rows  The n a indicates that the respective memory usage statistic was not available from ACEs output         M ATEESCU   D ECHTER   M ARINESCU  nally developed for heuristic search  Nilsson         As mentioned in the introduction  the AND OR search for graphical models is based on a pseudo tree that spans the graph of the model  similar to the tree rearrangement of Freuder and Quinn               The idea was adapted for distributed constraint satisfaction by Collin et al               and more recently by Modi et al          and was also shown to be related to graph based backjumping  Dechter         This work was extended by Bayardo and Miranker         Bayardo and Schrag        and more recently applied to optimization tasks by Larrosa et al          Another version that can be viewed as exploring the AND OR graphs was presented recently for constraint satisfaction  Terrioux   Jegou      b  and for optimization  Terrioux   Jegou      a   Similar principles were introduced recently for probabilistic inference  in algorithm Recursive Conditioning  Darwiche        as well as in Value Elimination  Bacchus et al       b      a   and are currently at the core of the most advanced SAT solvers  Sang et al          For direction      there are various lines of related research  The formal verification literature  beginning with the work of Bryant        contains a very large number of papers dedicated to the study of BDDs  However  BDDs are in fact OR structures  the underlying pseudo tree is a chain  and do not take advantage of the problem decomposition in an explicit way  The complexity bounds for OBDDs are based on pathwidth rather than treewidth  As noted earlier  the work of Bertacco and Damiani        on Disjoint Support Decomposition  DSD  is related to AND OR BDDs in various ways  The main common aspect is that both approaches show how structure decomposition can be exploited in a BDD like representation  DSD is focused on Boolean functions and can exploit more refined structural information that is inherent to Boolean functions  In contrast  AND OR BDDs assume only the structure conveyed in the constraint graph  and are therefore more broadly applicable to any constraint expression and also to graphical models in general  They allow a simpler and higher level exposition that yields graphbased bounds on the overall size of the generated AOMDD  The full relationship between these two formalisms should be studied further  McMillan        introduced the BDD trees  along with the operations for combining them  For  w circuits of bounded tree width  BDD trees have a linear space upper bound of O  g  w     where  g  is the size of the circuit g  typically linear in the number of variables  and w is the treewidth  This bound hides some very large constants to claim the linear dependence on  g  when w is bounded  However  McMillan maintains that when the input function is a CNF expression BDD trees have the same bounds as AND OR BDDs  namely they are exponential in the treewidth only  To sketch just a short comparison between McMillans BDD trees and AOMMDs  consider an example where we have a simple pseudo tree with root   left child  and right child   Each of these nodes may stand for a set of variables  In BDD trees  the assignments to  are grouped into equivalence classes according to the cofactors generated by them on the remaining  and   For example assignments   and   are equivalent if they generate the same function on  and   The node  can be represented by a BDD whose leaves are the cofactors  The same is done for   The node  is then represented by a matrix of BDDs  where each column corresponds to a cofactor of  and each line to a cofactor of   By contrast  an AOMDD represents the node  as a BDD whose leaves are the cofactors  the number of distinct functions on  and   and then each cofactor is the root of a decomposition  an AND node  between  and   Moreover  the representations of   as descendants of different cofactor of   are shared as much as possible and the same goes for   This is only a high level description  that becomes slightly more complicated when redundant nodes are eliminated  but the idea remains the same        AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  The AND OR structure restricted to propositional theories is very similar to deterministic decomposable negation normal form  d DNNF   Darwiche   Marquis        Darwiche         More recently  Huang and Darwiche      b  used the trace of the DPLL algorithm to generate an OBDD  and compared with the typical formal verification approach of combining the OBDDs of the input function according to some schedule  The structures that were investigated in that case are still OR  This idea is extended in our present work by the AND OR search compilation algorithm  McAllester  Collins  and Pereira        introduced the case factor diagrams  CFD   which subsume Markov random fields of bounded tree width and probabilistic context free grammars  PCFG   CFDs are very much related to the AND OR graphs  The CFDs target the minimal representation  by exploiting decomposition  similar to AND nodes  but also by exploiting context sensitive information and allowing dynamic ordering of variables based on context  CFDs do not eliminate the redundant nodes  and part of the cause is that they use zero suppression  There is no claim about CFDs being canonical forms  and also no description of how to combine two CFDs  There are numerous variants of decision diagrams that are designed to represent integer valued or real valued functions  For a comprehensive view we refer the reader to the survey of Drechsler and Sieling         Algebraic decision diagrams  ADDs   Bahar et al         provide a compilation for general real valued rather than Boolean functions  Their main drawback is that their size increases very fast if the number of terminals becomes large  There are several approaches that try to alleviate this problem  However the structure that they capture is still OR  and they do not exploit decomposition  Some alternatives introduce edge values  or weights  that enable more subgraph sharing  Edge valued binary decision diagrams  EVBDDs   Lai   Sastry        use additive weights  and when multiplicative weights are also allowed they are called factored EVBDDs  FEVBDDs   Tafertshofer   Pedram         Another type of BDDs called K BMDs  Drechsler  Becker    Ruppertz        also use integer weights  both additive and multiplicative in parallel  ADDs have also been extended to affine ADDs  Sanner   McAllester         through affine transformations that can achieve more compression  The result was shown to be beneficial for probabilistic inference algorithms  such as tree clustering  but they still do not exploit the AND structure  More recently  independently and in parallel to our work on AND OR graphs  Dechter   Mateescu      a      b   Fargier and Vilarem        and Fargier and Marquis              proposed the compilation of CSPs into tree driven automata  which have many similarities to our work  Their main focus is the transition from linear automata to tree automata  similar to that from OR to AND OR   and the possible savings for tree structured networks and hyper trees of constraints due to decomposition  Their compilation approach is guided by a tree decomposition while ours is guided by a variable elimination based algorithms  And it is well known that Bucket Elimination and cluster tree decomposition are in principle the same  Dechter   Pearl         Wilson        extended OBDDs to semi ring BDDs  The semi ring treatment is restricted to the OR search spaces  but allows dynamic variable ordering  It is otherwise very similar in aim and scope to our AOMDD  When restricting the AOMDD to OR graphs only  the two are closely related  except that we express BDDs using the Shenoy Shafer axiomatization that is centered on the two operation of combination and marginalization rather then on the semi ring formulation  Minimality in the formulation of Wilson        is more general allowing merging nodes having different values and therefore it can capture symmetries  called interchangeability   Another framework very similar to AOMDDs  that we became aware of only recently  is Probabilistic Decision Graphs  PDG  of Jaeger         This work preceded most of the relevant work       M ATEESCU   D ECHTER   M ARINESCU  we discussed above  Fargier   Vilarem        Wilson        and went somewhat unnoticed  perhaps due to notational and cultural differences  It is however similar in motivation  framework and proposed algorithms  We believe our AND OR framework is more accessible  We define the framework over multi valued domains  provide greater details in algorithms and complexity analysis  make an explicit connection with search frameworks  fully address the issues of canonicity as well as provide an empirical demonstration  In particular  the claim of canonicity for PDGs is similar to the one we make for AOMDDs of weighted models  in that it is relative to the trees  or forests  that can represent the given probability distribution  There is another line of research by Drechsler and his group  e g  Zuzek  Drechsler    Thornton         who use AND OR graphs for Boolean function representation  that may seem similar to our approach  However  the semantics and purpose of their AND OR graphs are different  They are constructed based on the technique of recursive learning and are used to perform Boolean reasoning  i e  to explore the logic consequences of a given assumption based on the structure of the circuit  especially to derive sets of implicants  The meaning of AND and OR in their case is related to the meaning of the gates functions  while in our case the meaning is not related to the semantic of the functions  The AND OR enumeration tree that results from a circuit according to Zuzek et al         is not related to the AND OR decomposition that we discuss       Conclusion We propose the AND OR multi valued decision diagram  AOMDD   which emerges from the study of AND OR search spaces for graphical models  Dechter   Mateescu      a      b  Mateescu   Dechter        Dechter   Mateescu        and ordered binary decision diagrams  OBDDs   Bryant         This data structure can be used to compile any graphical model  Graphical models algorithms that are search based and compiled data structures such as BDDs differ primarily by their choices of time vs  memory  When we move from regular OR search space to an AND OR search space the spectrum of algorithms available is improved for all time vs  memory decisions  We believe that the AND OR search space clarifies the available choices and helps guide the user into making an informed selection of the algorithm that would fit best the particular query asked  the specific input function and the available computational resources  The contribution of our work is      We formally describe the AOMDD and prove that it is a canonical representation of a constraint network      We extend the AOMDD to general weighted graphical models      We give a compilation algorithm based on AND OR search  that saves the trace of a memory intensive search  the context minimal AND OR graph   and then reduces it in one bottom up pass      We describe the APPLY operator that combines two AOMDDs by an operation and show that its complexity is quadratic in the input  but never worse than exponential in the treewidth      We give a scheduling order for building the AOMDD of a graphical model starting with the AOMDDs of its functions which is based on a Variable Elimination algorithm  This guarantees that the complexity is at most exponential in the induced width  treewidth  along the ordering      We show how AOMDDs relate to various earlier and recent compilation frameworks  providing a unifying perspective for all these methods      We introduce the semantic treewidth  which helps explain why compiled decision diagrams are often much smaller than the worst case bound  Finally      we provide a preliminary empirical demonstration of the power of the current scheme         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  Acknowledgments This work was done while Robert Mateescu and Radu Marinescu were at the University of California  Irvine  The authors would like to thank the anonymous reviewers for their constructive suggestions to improve the paper  David Eppstein for a useful discussion of complexity issues  and Lars Otten and Natasha Flerova for comments on the final version of the manuscript  This work was supported by the NSF grants IIS         and IIS          and the initial part by the Radcliffe fellowship            through the partner program   with Harvard undergraduate student John Cobb   Appendix Proof of Proposition   Consider the level of variable Xi   and the meta nodes in the list LXi   After one pass through the meta nodes in LXi  the inner for loop   there can be no two meta nodes at the level of Xi in the AND OR graph that are isomorphic  because they would have been merged in line    Also  during the same pass through the meta nodes in LXi all the redundant meta nodes in LXi are eliminated in line    Processing the meta nodes in the level of Xi will not create new redundant or isomorphic meta nodes in the levels that have been processed before  It follows that the resulting AND OR graph is completely reduced    Proof of Theorem   The bound on the size follows directly from Theorem    The AOMDD size can only be smaller than  the size of the context minimal AND OR graph  which is bounded by O n k wT  G     To prove the time bound  we have to rely on the use of the hash table  and the assumption that an efficient implementation allows an access time that is constant  The time bound of AND OR S EARCH  AOMDD  is O n k wT  G     from Theorem    because it takes time linear in the output  we assume here that no constraint propagation is performed during search   Procedure B OTTOM U P R EDUCTION  procedure    takes time linear in the size of the context minimal AND OR graph  Therefore  the AOMDD  can be computed in time O n k wT  G     and the result is the same for the algorithm that performs the reduction during the search    Proof of Proposition   The complexity of OBDD  and MDD  apply is known to be quadratic in the input  Namely  the number of nodes in the output is at most the product of number of nodes in the input  Therefore  the number of nodes that can appear along one path in the output AOMDD can be at most the product of the number of nodes in each input  along the same path   Gfi     Ggi    Summing over all the paths in T gives the result    Proof of Proposition   The argument is identical to the case of MDDs  The recursive calls in APPLY lead to combinations of one node from Gfaomdd and one node from Ggaomdd  rather than a list of nodes   The number of total possible such combinations is O   Gfaomdd      Ggaomdd       Proof of Proposition   The recursive calls of APPLY can generate one meta node in the output for each combination of       M ATEESCU   D ECHTER   M ARINESCU  nodes from Gff g and Ggf g   Lets look at combinations of nodes from Gff g and Ggaomdd   Ggf g   The meta nodes from Ggaomdd   Ggf g that can participate in such combinations  lets call this set A  are only those from levels  of variables  right below Tf g   This is because of the mechanics of the recursive calls in APPLY  Whenever a node from f that belongs to Gff g is combined with a node from g that belongs to A  line    of APPLY expands the node from f   and the node  or nodes  from A remain the same  This will happen until there are no more nodes from f that can be combined with the node  or nodes  from A  and at that point APPLY will simply copy the remaining portion of its output from Ggaomdd   The size of A is therefore proportional to   Ggf g    because it is the layer of metanodes immediately below Ggf g    A similar argument is valid for the symmetrical case  And there are no combinations between nodes in Ggaomdd   Ggf g and Ggaomdd   Ggf g   The bound follows from all these arguments    Proof of Proposition   The APPLY operation works by constructing the output AOMDD from root to leaves  It first creates a meta node for the root variable  and then recursively creates its children metanodes by using APPLY on the corresponding children of the input  The worst case that can happen is when the output is not reduced at all  and a recursive call is made for each possible descendant  This corresponds to an unfolding of the full AND OR search tree based on the context variables  which is exponential in the context size  When the APPLY finishes the context variables  and arrives at the first branching in the bucket pseudo tree  the remaining branches are independent  Similar to the case of OBDDs  where one function occupies a single place in memory  the APPLY can simply create a link to the corresponding branches of the inputs  this is what happens in line   in the APPLY algorithm   Therefore  the time and space complexity is at most exponential in the context size    Proof of Theorem   The space complexity is governed by that of BE  Since an AOMDD never requires more space than  that of a full exponential table  or a tree   it follows that BE AOMDD only needs space O n k w    The size of the output AOMDD is also bounded  per layers  by the number of assignments to the context of that layer  namely  by the size of the context minimal AND OR graph   Therefore   because context size is bounded by treewidth  it follows that the output has size O n k w    The time complexity follows from Proposition    and from the fact that the number of functions in a bucket cannot exceed r  the original number of functions    Proof of Proposition   It suffices to prove the proposition for m      The general result can then be obtained by induction  It is essential that the function is defined by a constraint network  i e   the values are only   or     and that the function takes value   at least for one assignment  The value   denotes consistent assignments  solutions   while   denotes inconsistent assignments  Suppose f   f  f    Lets denote by x a full assignment to X  and by x  and x  the projection of x over X  and X    respectively  We can write x   x  x   concatenation of partial assignments   It follows that f  x    f   x     f   x     Therefore  if f  x       it must be that f   x        and f   x         We claim that for any x    f   x        only if there exists some x  such that f  x  x         Suppose by contradiction that there exist some x  such that f   x        and f  x  x        for any other x    Since f is not always zero         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  it follows that f  is not always zero  and therefore there must be some x  for which f   x         This leads to a contradiction  and therefore the functions f  and f  are uniquely defined by f     Proof of Theorem   The proof is by structural induction over the depth of the pseudo tree T   It follows the canonicity proofs for OBDDs  Bryant        and MDDs  Srinivasan et al          but extends them from linear orderings to tree orderings that capture function decomposition according to the pseudo tree T   The depth of T   along each of its paths from root to a leaf  is actually the size of the dependency set  or the set of variables on which the value of the function depends  Remember that the AOMDD is an AND OR graph that is completely reduced  We will use the word function  denoted by f   to refer to the universal relation  or its characteristic function  defined by the constraint network  Assume the depth of T is    This means that the function does not depend on any variable  and must be one of the constants   or    Suppose the function is the constant    Then  it must be that the AOMDD does not contain the terminal meta node    since all the nodes must be reachable along some path  and it would mean that the function can also evaluate to    Suppose the AOMDD contains a nonterminal meta node  say labeled with X  where X can take k different values  It must be that all the k children meta nodes of X are the terminal meta node    If there are more than one terminal    then the AOMDD is not completely reduced  If there is only one    it follows that the meta node labeled with X is redundant  Therefore  from all the above  it follows that the AOMDD representing the constant   is made of only the terminal    This is unique  and contains the smallest number of nodes  A similar argument applies for the constant    Now  suppose that the statement of the theorem holds for any constraint network that admits a pseudo tree of depth strictly smaller than p  and that we have a constraint network with a pseudo tree of depth equal to p  where p      Let X be the root of T   having domain  x            xk    We denote by fi   where i              k   the functions defined by the restricted constraint network for X   xi   namely fi   f  X xi   Let Y            Ym be the children of X in T   Suppose we have two AOMDDs of f   denoted by G and G     We will show that these two AND OR graphs are isomorphic  The functions fi can be decomposed according to the pseudo tree T when the root X is removed  This can in fact be a forest of independent pseudo trees  they do not share any variables   rooted by Y            Ym   Based on Proposition    there is a unique decomposition fi   fiY          fiYm   for all Y i              k   Based on the induction hypothesis  each of the function fi j has a unique AOMDD  In the AND OR graphs G and G     if we look at the subgraphs descending from X   xi   they both are completely reduced and define the same function  fi   therefore there exists an isomorphic mapping i between them  Let v be the root metanode of G and v   the root of G     We claim that G and G   are isomorphic according to the following mapping      v  if u   v   u    i  u   if u is in the subgraph rooted by hX  xi i  To prove this  we have to show that  is well defined  and that it is an isomorphic mapping  If a meta node u in G is contained in both subgraphs rooted by hX  xi i and hX  xj i  Then the AND OR graphs rooted by i  u  and j  u  are isomorphic to the one rooted at u  and therefore to each other  Since G   is completely reduced  it does not contain isomorphic subgraphs  and therefore i  u    j  u   Therefore  is well defined  We can now show that  is a bijection  To show that it is one to one  assume two distinct metanodes u  and u  in G  with  u       u     Then  the subgraphs rooted by u  and u  are isomorphic       M ATEESCU   D ECHTER   M ARINESCU  to the subgraph rooted by  u     and therefore to each other  Since G is completely reduced  it must be that u    u    The fact that  is onto and is an isomorphic mapping follows from its definition and from the fact that each i is onto and the only new node is the root meta node  Since the AOMDDs only contain one root meta node  more than one root would lead to the conclusion that the root meta nodes are isomorphic and should be merged   we conclude that G and G   are isomorphic  Finally  we can show that among all the AND OR graphs representing f   the AOMDD has minimal number of meta nodes  Suppose G is an AND OR graph that represents f   with minimal number of meta nodes  but without being an AOMDD  Namely  it is not completely reduced  Any reduction rule would transform G into an AND OR graph with smaller number of meta nodes  leading to a contradiction  Therefore  G must be the unique AOMDD that represents f     Proof of Corollary   The proof of Theorem   did not rely on the scopes that define the constraint network  As long as the network admits the decomposition induced by the pseudo tree T   the universal function defined by the constraint network will always have the same AOMDD  and therefore any constraint network equivalent to it that admits T will also have the same AOMDD    Proof of Theorem   The constant that is associated with the root is actually the sum of the weights of all solutions  This can be derived from the definition of the weighted AOMDD  The weights of each meta node are normalized  they sum to     therefore the values computed for each OR node by AND OR search is always    when the task is computing P the sum of all solution weights   Therefore  the constant of the weighted AOMDD is always x w x  regardless of the graphical model  We will prove that weighted AOMDDs are canonical for functions that are normalized  Assume we have two different weighted AOMDDs  denoted by G   and G     for the same normalized function f   Let the root variable be A  with the domain  a            ak    Let x denote a full assignment to all the variables  Similar to the above argument for the root constant  P because all the meta nodes have normalized weights  it follows that w   A  a      w   A  a      x A a  f  x   The superscript of w  and w  indicates the AOMDD  and the summation is over all possible assignments restricted to A   a    It follows that the root meta nodes are identical  For each value of the root variable  the restricted functions represented in G   and G   are identical  and we will recursively apply the same argument as above  However  for the proof to be complete  we have to discuss the case when a restricted function is decomposed into independent functions  according to the pseudo tree  Suppose there are two independent components  rooted by B and C  If one of them is the   function  it follows that the entire function is    We will prove that the meta nodes of B in G   and G   are identical  If B has only one value b  extendable to a solution  its weight must be   in both meta nodes  so the meta nodes are identical  If B has more than one value  suppose without loss of generality that the weights are different for the first value b    and w   B  b      w   B  b           Since f       there must be a value C   c  such that B   b    C   c  can be extended to a full solution  The sum of the weights of all these possible extensions is X f  x    w   B  b     w   C  c      w   B  b     w   C  c         x B b   C c         AND OR M ULTI  VALUED D ECISION D IAGRAMS  AOMDD S   FOR G RAPHICAL M ODELS  From Equations   and   and the fact that the weight are non zero  it follows that w   C  c      w   C  c           From Equation    the fact that B has more than one value and the fact that the weights of B are normalized  it follows that there should be a value b  such that w   B  b      w   B  b           From Equations   and    it follows that w   B  b     w   C  c      w   B  b     w   C  c           However  both sides of P the Equation   represent the sum of weights of all solutions when B   b    C   c    namely x B b   C c  f  x   leading to a contradiction  Therefore  it must be that Equation   is false  Continuing the same argument for all values of B  it follows that the metanodes of B are identical  and similarly the meta nodes of C are identical  If the decomposition has more than two components  the same argument applies  when B is the first component and C is a meta variable that combines all the other components    Proof of Theorem   Consider the well known NP complete problem of    COLORING  Given a graph G  is there a   coloring of G  Namely  can we color its vertices using only three colors  such that any two adjacent vertices have different colors  We will reduce    COLORING to the problem of computing the semantic treewidth of a graphical model  Let H be a graph that is   colorable  and has a nontrivial semantic treewidth  It is easy to build examples for H  If G is   colorable  then G  H is also   colorable and will have a non trivial semantic treewidth  because adding G will not simplify the task of describing the colorings of H  However  if G is not   colorable  then G  H is also not   colorable  and will have a semantic treewidth of zero    Proof of Proposition   Since AOMDDs are canonical representations of graphical models  it follows that the graphical model for which the actual semantic treewidth is realized will have the same AOMDD as M  and therefore the AOMDD is bounded exponentially in the semantic treewidth     
 The paper evaluates the power of best first search over AND OR search spaces for solving the Most Probable Explanation  MPE  task in Bayesian networks  The main virtue of the AND OR representation of the search space is its sensitivity to the structure of the problem  which can translate into significant time savings  In recent years depth first AND OR Branch andBound algorithms were shown to be very effective when exploring such search spaces  especially when using caching  Since best first strategies are known to be superior to depth first when memory is utilized  exploring the best first control strategy is called for  The main contribution of this paper is in showing that a recent extension of AND OR search algorithms from depth first Branch and Bound to best first is indeed very effective for computing the MPE in Bayesian networks  We demonstrate empirically the superiority of the best first search approach on various probabilistic networks      INTRODUCTION  Belief networks     are a class of graphical models that provide a formalism for reasoning about partial beliefs under conditions of uncertainty  They are defined by a directed acyclic graph over nodes representing random variables of interest  The arcs signify the existence of direct causal influences between linked variables quantified by conditional probabilities that are attached to each cluster of parentschild nodes in the network  The Most Probable Explanation  MPE  task in belief networks calls for finding a complete assignment to the variables having maximum probability  given the evidence  It is typically tackled with either inference or search algorithms            The AND OR search space for graphical models     is a framework for search that is sensitive to the independencies  in the model  often resulting in reduced search spaces  The impact of the AND OR search to optimization in graphical models and in particular to the MPE task was explored in recent years focusing exclusively on depth first search  The AND OR Branch and Bound first introduced by     traverses the AND OR search tree in a depth first manner  The memory intensive Branch and Bound algorithm     explores an AND OR search graph  rather than a tree  by caching previously computed results and retrieving them when the same subproblems are encountered again  The depth first AND OR search algorithms were shown to outperform dramatically state of the art Branch and Bound algorithms searching the traditional OR space  In a recent paper     we introduced best first AND OR search algorithms for solving     Integer Programming problems  and demonstrated that  given enough memory  they are superior to Branch and Bound algorithms we developed earlier      Subsequently  in     we extended this approach for Weighted CSP  WCSP  problems when using best first AND OR search guided by bounded mini bucket heuristics  We demonstrated  again  that the best first algorithms are more efficient than their Branch and Bound counterparts for various hard WCSP benchmarks  In this paper we shift our attention to probabilistic networks  focusing on the MPE tasks  The extension of bestfirst AND OR search from WCSP to Bayesian networks is straightforward  Hence  the main contribution of the current paper is in its empirical evaluation of the scheme over a wide range of probabilistic networks  including random networks  coding networks as well as hard instances from genetic linkage analysis  We show that this class of algorithms improves on the most competitive complete MPE solvers  thus it can potentially push the landmark of computation further  assuming memory is available  The paper is organized as follows  Section   gives background on belief networks and AND OR search spaces  Section   describes the best first AND OR search algorithm  Section   presents an extensive empirical evaluation and Section   concludes         MARINESCU   DECHTER A  OR  A  OR     AND  A   A   B  OR  C  A  F   CB  C  AND  F  AND  OR  D  B  E   a  Network   D  D   F    b  Pseudo tree     C  OR  E  EA   B     AND  B  AB         C  E        OR  B  B  C  OR  C  E  E                                                  D  D  F  F  D  D  F  F  D  D  F  F  D  D  F  F                                                                         AND     C  E  AND  E        C  E  C  E  C  E  AND                          OR  D  D  F  F  D  D  F  F  AND   c  AND OR search tree             d  AND OR search graph  Figure    AND OR search spaces for belief networks          BACKGROUND Belief Networks  D EFINITION    belief network  A belief  or Bayesian  network is a quadruple P   hX  D  F i  where X    X         Xn   is a set of variables over multi valued domains D    D         Dn    Given a directed acyclic graph DAG over X as nodes  F    Pi    where Pi    P  Xi  pa Xi     are conditional probability tables  CPTs for short  associated with each variable Xi   and pa Xi   are the parents of Xi in the acyclic graph DAG  A belief network representsQa joint probability distribution over X  n P  x         xn     i   P  xi  xpa Xi      An evidence set e is an instantiated subset of variables  The moral graph  or primal graph  of a belief network is the undirected graph obtained by connecting the parent nodes of each variable and eliminating direction  A common optimization query over belief networks is finding the Most Probable Explanation  MPE   namely  finding a complete assignment to all variables having maximum probability  given the evidence  A generalization of the MPE query is Maximum a Posteriori Hypothesis  MAP   which calls for finding the most likely assignment to a subset of hypothesis variables  given the evidence  D EFINITION    most probable explanation  Given a belief network and evidence e  the Most Probable Explanation o o  MPE  task is to find an assignment Qn  x         xn   such that  o o P  x         xn     maxX       Xn k   P  Xk  pa Xk    e   The MPE task appears in applications such as diagnosis  abduction and explanation  For example  given data on clinical findings  MPE can postulate on a patients probable afflictions  In decoding  the task is to identify the most likely message transmitted over a noisy channel given the observed output       AND OR Search Spaces for Graphical Models  The common way to solve the MPE task in belief networks is by search  namely to instantiate variables  following a static or dynamic variable ordering  In the simplest case  this process defines an OR search tree  whose nodes repre   sent partial assignments  This search space does not capture the structure of the underlying graphical model  However  to remedy this problem  AND OR search spaces for graphical models were recently introduced by      They are defined using a backbone pseudo tree      D EFINITION    pseudo tree  Given an undirected graph G    V  E   a directed rooted tree T    V  E     defined on all its nodes is called pseudo tree if any arc of G which is not included in E   is a back arc  namely it connects a node to an ancestor in T   AND OR Search Trees Given a belief network P   hX  D  F i  its primal graph G and a pseudo tree T of G  the associated AND OR search tree  denoted ST   has alternating levels of OR nodes and AND nodes  The OR nodes are labeled Xi and correspond to the variables  The AND nodes are labeled hXi   xi i and correspond to value assignments in the domains of the variables  The root of the AND OR search tree is an OR node  labeled with the root of the pseudo tree T   The children of an OR node Xi are AND nodes labeled with assignments hXi   xi i  consistent along the path from the root  path Xi   xi      hX    x  i       hXi    xi  i   The children of an AND node hXi   xi i are OR nodes labeled with the children of variable Xi in T   Semantically  the OR states represent alternative solutions  whereas the AND states represent problem decomposition into independent subproblems  all of which need be solved  When the pseudo tree is a chain  the AND OR search tree coincides with the regular OR search tree  A solution tree SolST of ST is an AND OR subtree such that   i  it contains the root of ST    ii  if a nonterminal AND node n  ST is in SolST then all its children are in SolST    iii  if a nonterminal OR node n  ST is in SolST then exactly one of its children is in SolST   E XAMPLE   Figures   a  and   b  show a belief network and its pseudo tree together with the back arcs  dotted lines   Figure   c  shows the AND OR search tree based on the pseudo tree  for bi valued variables  Weighted AND OR Search Trees The arcs from OR nodes Xi to AND nodes hXi   xi i in the AND OR search   MARINESCU   DECHTER       tree ST are annotated by weights derived from the conditional probability tables in F    O exp w     where w is the induced width of the underlying pseudo tree       D EFINITION    weight  The weight w n  m  of the arc from the OR node n   Xi to the AND node m   hXi   xi i is the product of all the CPTs whose scope includes Xi and is fully assigned along path Xi   xi    evaluated at the values along the path   E XAMPLE   Consider the context minimal AND OR search graph in Figure   d  of the pseudo tree from Figure   b   the square brackets indicate the context of the variables   Its size is far smaller than that of the AND OR tree from Figure   c      nodes vs     nodes    Given a weighted AND OR search tree  each node can be associated with a value            D EFINITION    value  The value v n  of a node n  ST is defined recursively as follows   i  if n   hXi   xi i is a terminal AND node then v n        ii  Q if n   hXi   xi i is an internal AND node then v n    msucc n  v m    iii  if n   Xi is an internal OR node then v n    maxmsucc n   w n  m   v m    where succ n  are the children of n in ST   It easy to see that the value v n  of a node in the AND OR search tree ST is the most probable explanation of the subproblem rooted at n  subject to the current variable instantiation along the path from the root to n  If n is the root of ST   then v n  is the most probable explanation value of the initial problem  see        for more details   AND OR Search Graphs The AND OR search tree may contain nodes that root identical subtrees  in particular  subproblems with identical optimal solutions  which can be unified  When unifiable nodes are merged  the search tree becomes a graph and its size becomes smaller  Some unifiable nodes can be identified based on their contexts  D EFINITION    context  Given a belief network and the corresponding AND OR search tree ST relative to a pseudo tree T   the context of any AND node hXi   xi i  ST   denoted by context Xi    is defined as the set of ancestors of Xi in T   including Xi   that are connected to descendants of Xi   It is easy to verify that any two nodes having the same context represent the same subproblem  Therefore  we can solve PhXi  xi i   the subproblem rooted at hXi   xi i  once and use its optimal solution whenever the same subproblem is encountered again  The context minimal AND OR search graph based on a pseudo tree T   denoted GT   is obtained from the AND OR search tree by merging all the AND nodes that have the same context  It can be shown     that the size of the largest context is bounded by the induced width w of the problems primal graph  T HEOREM      complexity  The complexity of any search algorithm traversing a context minimal AND OR search graph  by context based caching  is time and space  Searching the AND OR Search Space  Recently  depth first AND OR Branch and Bound  AOBB  search algorithms that explore the context minimal AND OR search graph via full caching were shown to be highly effective for solving the MPE task in belief networks         The efficiency of these algorithms also depends on the accuracy of a static heuristic function which can be either pre compiled or generated during search for each node in the search space  Furthermore  we showed     that AOBB can improve its guiding heuristic function dynamically  by learning from portions of the search space that were already explored  This updated dynamic heuristic evaluation function is guaranteed to be tighter than the static one      and therefore it can prune the search space more effectively  The primary static heuristic function we experimented with  especially in the context of the MPE task was the mini bucket heuristic      The Mini bucket Heuristics is a general scheme for generating heuristic estimates for search that has been investigated in recent years  especially in the context of belief networks            The scheme is parameterized by the mini bucket i bound which controls the trade off between heuristic strength and its computational overhead  The heuristics can be pre compiled from the augmented bucket structure processed by the Mini Bucket algorithm  When compiled before search they are referred to as static minibuckets  hereafter denoted by SMB  and they were shown to be very powerful  especially for relatively large values of the i bound  When the mini bucket heuristics are computed dynamically during search  referred to as dynamic mini buckets  DMB  they are generally more accurate than the static ones  However  due to their computational overhead  they were shown to be cost effective only for relatively small i bounds      BEST FIRST AND OR SEARCH  In this section we direct our attention to a best first rather than depth first control strategy for traversing the contextminimal AND OR graph and describe a best first AND OR search algorithm for solving the MPE task in belief networks  The algorithm uses similar amounts of memory as the depth first AND OR Branch and Bound with full caching and therefore the comparison is warranted         MARINESCU   DECHTER  Algorithm    AOBF Data  A belief network P   hX  D  F i  pseudo tree T   root s  Result  Most Probable Explanation of P     Create explicit graph G T   consisting solely of the start node s  Set v s    h s      until s is labeled SOLVED  do   a  Compute a partial solution tree by tracing down the marked arcs in G T from s and select any nonterminal tip node n   b  Expand node n and add any new successor node ni to G T   For each new node ni set v ni     h ni    Label SOLVED any of these successors that are terminal nodes   c  Create a set S containing node n   d  until S is empty  do  i  Remove from S a node m such that m has no descendants in G T still in S  ii  Revise the value v m  as follows  A  if m isQ an AND node then v m    m succ m  v mj    If all the successor j nodes are labeled SOLVED  then label node m SOLVED  B  if m is an OR node then v m    maxmj succ m   w m  mj    v mj    and mark the arc through which this maximum is achieved  If the marked successor is labeled SOLVED  then label m SOLVED  iii  If m has been marked SOLVED or if the revised value v m  is different than the previous one  then add to S all those parents of m such that m is one of their successors through a marked arc     return v s    to its successors  step   b   The successors of an AND node n   hXj   xj i are Xj s children in the pseudo tree  while the successors of an OR node n   Xj correspond to Xj s domain values  Notice that when expanding an OR node  the algorithm does not generate AND children that are already present in the explicit search graph G T   All these identical AND nodes in G T are easily recognized based on their contexts  so only pointers to the existing nodes are created  The second operation in AOBF is a bottom up  cost revision  arc marking  SOLVE labeling procedure  step   c   Starting with the node just expanded n  the procedure revises its value v n   using the newly computed values of its successors  and marks the outgoing arcs on the estimated best path to terminal nodes  This revised value is then propagated upwards in the graph  The revised cost v n  is an updated estimate of the most probable explanation probability of the subproblem rooted at n  If we assume the monotone restriction on h  the algorithm considers only those ancestors that root best partial solution subtrees containing descendants with revised values  The most probable explanation value of the initial problem is obtained when the root node s is solved  AOBF versus AOBB We describe next the main differences between AOBF and AOBB search    AOBF with the same heuristic function as AOBB is likely to expand the smallest number of nodes       but empirically this depends on how quickly AOBB will find an optimal solution   Best First Search Best first search is a search algorithm which optimizes breath first search by expanding the node whose heuristic evaluation function is the best among all nodes encountered so far  Its main virtue is that it never expands nodes whose cost is beyond the optimal one  unlike depth first search algorithms  and therefore is superior among memory intensive algorithms employing the same heuristic evaluation function       Best First AND OR Graph Search Our best first AND OR graph search algorithm  denoted by AOBF  that traverses the context minimal AND OR search graph is described in Algorithm    It specializes Nilssons AO algorithm      to AND OR spaces in graphical models  in particular to finding the MPE in belief networks  The algorithm maintains a frontier of partial solution trees found so far  and interleaves forward expansion of the best partial solution tree with a cost revision step that updates estimated node values  First  a top down  graph growing operation  step   a  finds the best partial solution tree by tracing down through the marked arcs of the explicit AND OR search graph G T   These previously computed marks indicate the current best partial solution tree from each node in G T   One of the nonterminal leaf nodes n of this best partial solution tree is then expanded  and a static heuristic estimate h ni    overestimating v ni    is assigned    AOBB is able to improve its heuristic function dynamically during search     based on the explicated portion of the search space  while AOBF may not because it uses only the static function h n   which can be precomputed or generated during search    AOBB can use far less memory avoiding dead caches for example  e g   when the search graph is a tree   while AOBF has to keep the explicated search graph in memory prior to termination  All the above points show that the relative merit of best first vs depth first over context minimal AND OR search spaces cannot be determined by the theory in      and empirical evaluation is essential      EXPERIMENTS  We evaluate the performance of the best first AND OR search algorithm on the task of finding the Most Probable Explanation in belief networks      We implemented our algorithms in C   and ran all experiments on a    GHz Pentium IV with  GB of RAM  We consider a class of best first AND OR search algorithms guided by the static and dynamic mini bucket   MARINESCU   DECHTER       heuristics  They are denoted by AOBF SMB i  and AOBF DMB i   respectively  We compare them against the depth first AND OR Branch and Bound algorithms with static dynamic mini bucket heuristics and full caching introduced in     and denoted by AOBB SMB i  and AOBB DMB i  respectively  The parameter i represents the mini bucket i bound and controls the accuracy of the heuristic  All algorithms traverse the context minimal AND OR search graph and are restricted to a static variable ordering determined by the pseudo tree  In our current implementation the AND OR search algorithms do not exploit the determinism present in the networks by using any form of constraint propagation such as generalized arcconsistency or unit propagation  For reference  we include results obtained with the S AM I AM       software package    S AM I AM is a public implementation of Recursive Conditioning      which can also be viewed as an AND OR search algorithm  We report the average CPU time in seconds  t  and number of nodes visited      required for proving optimality of the solution  We also record the number of variables  n   number of evidence variables  e   the depth of the pseudotrees  h  and the induced width of the graphs  w   obtained for the test instances  The pseudo trees were generated using the min fill heuristic  as described in      All competing algorithms were alloted a  GB memory limit  The best performance points are highlighted  In each table   out denotes that the respective algorithm exceeded the time memory limit  Random Belief Networks We have generated a class of random belief networks using the parametric model  n  d  c  p  proposed in      Figure   reports the average time results in seconds and number of nodes visited for    random instances of a network with n       variables  domain size d      c       probability tables  CPTs  and p     parents per CPT  The average induced width and pseudo tree depth were    and     respectively  The minibucket i bound ranged between   and     When comparing the best first versus the depth first algorithms using static mini bucket heuristics  we observe that AOBF SMB i  is better than AOBB SMB i  only for relatively small i bounds  i e   i             which generate relatively weak heuristic estimates  As the ibound increases and the heuristics become strong enough to cut the search space substantially  the difference between Branch and Bound and best first search decreases  because Branch and Bound finds close to optimal solutions fast  and therefore will not explore solutions whose cost is below the optimum  like best first search  When looking at the algorithms using dynamic mini bucket heuristics  we notice that AOBF DMB i  is slightly bet  Available at http   reasoning cs ucla edu samiam  We used the batchtool     provided with the package   Figure    CPU time in seconds and number of nodes visited for solving random belief networks with     nodes  Time limit     seconds  average induced width w        ter than AOBB DMB i  only for the smallest reported ibound  namely i      This is because these heuristics are more accurate compared to the static ones  and the savings in number of nodes caused by best first search do not transform into time savings as well  When comparing the static versus dynamic mini bucket heuristic we observe that the latter is competitive only for relatively small i bounds  i e   i                    At higher levels of the i bound  the accuracy of the dynamic heuristic does not outweigh its computational overhead  For this reason  in the remaining experiments we only consider the algorithms guided by pre compiled mini bucket heuristics  Coding Networks For this domain we experimented with random coding networks from the class of linear block codes  They can be represented as   layer belief networks with n nodes in each layer  i e   the number of input bits   The second and third layers correspond to input information bits and parity check bits respectively  Each parity check bit represents an XOR function of the input bits  The first and last layers correspond to transmitted information and parity check bits respectively  Input information and parity check nodes are binary  while the output nodes are real valued  Given a number of input bits n  number of parents p for each XOR bit  and channel noise variance      a coding network structure is generated by randomly picking parents for each XOR node  Then we simulate an input signal by assuming a uniform random distribution of information bits  compute the corresponding values of the parity        MARINESCU   DECHTER  Figure    CPU time in seconds for solving coding networks with channel noise variance                               Time limit     seconds  average induced width w       check bits  and generate an assignment to the output nodes by adding Gaussian noise to each information and parity check bit  Figure   displays the average time results in seconds for    random coding instances with n       input bits  p     parents for each XOR bit and channel noise variance                               we omitted the number of nodes due to space limitations   The average induced width and depth of the pseudo tree was    and     respectively  The mini bucket i bound varied between    and     We observe that AOBF SMB i  is far better than AOBB SMB i  for this domain  The difference in CPU time between the best first and depth first search approaches is more prominent on the hardest problem instances having higher channel noise variance  i e                      across all reported i bounds  S AM I AM was not able to solve any of these problems due to exceeding the memory limit  Grid Networks In grid networks  the nodes are arranged in an n  n square and each CPT is generated uniformly randomly  We experimented with problem instances developed by      for which n ranged between    and     and     of the CPTs were deterministic  i e   constraints   Table   shows detailed results for experiments with   grid networks of increasing difficulty  For each network e nodes were picked randomly and instantiated as evidence  We notice again the superiority of AOBF SMB i  over AOBB SMB i   especially for relatively weak heuristic estimates which are generated at relatively small i bounds   For example  on          one of the hardest instances  best first search with the smallest reported i bound  i       finds the most probable explanation in about   minutes      seconds  while the depth first Branch and Bound with the same heuristics exceeds the   hour time limit  The best performance point on this test instance is achieved for i       where AOBF SMB     is   times faster than AOBB SMB     and explores a search space    times smaller  Notice that S AM I AM is able to solve relatively efficiently only the first   test instances and runs out of memory on the remaining ones  Genetic Linkage Analysis The maximum likelihood haplotype problem in genetic linkage analysis is the task of finding a joint haplotype configuration for all members of the pedigree which maximizes the probability of data  It is equivalent to finding the most probable explanation of a belief network which represents the pedigree data       Table   displays the results obtained for    hard linkage analysis networks    For comparison  we include results obtained with S UPERLINK      S UPERLINK is currently one the most efficient solvers for genetic linkage analysis  is dedicated to this domain  uses a combination of variable elimination and conditioning  and takes advantage of the determinism in the network  We observe again that AOBF SMB i  is the best performing algorithm  For instance  on the p   linkage instance  AOBF SMB     is    times faster than AOBB SMB        http   bioinfo cs technion ac il superlink    MARINESCU   DECHTER grid                                                                   n e  w  h  SamIam v                                               t   t   t                                                                          t   t   t   t   t                       i    i                                                                                             AOBB SMB i  i                                                i     i     i    i                                                                                                                                                       AOBF SMB i  i     i     i                                                                                                          i     i     i     i     i     i     i     i     i     i     out                                           out  out  out        out                                                                                                           out                                                                                                 out  out                                                                                                                                                                                                                                                                                                                                                           out  Table    CPU time in seconds and number of nodes visited for solving grid networks  Time limit   hour   ped  n  w  h  p        p         p         p         p          p          p         p         p          p         p          p         SamIam v         Superlink v       i    i                                                                                                         i                                 AOBB SMB i  i     i     i     i    i                                                                                                                   out                                            i     i     i     i     i                                                                                                                                     AOBF SMB i  i     i     i                                                                                                i     i     i     i                                                                                                                       t   t   t                 out         out                  t   t    out           out         i     i     i     i     i     i     i     i     i     i                                                 t   t   t   t   t   t   t                       out                                          out  out  out                              out                              out                      out                                                                out out                               out  out  out                                                                                                                                                                                                                                                                          out  out                                              out                                         out     out                                                 out                                                                                                                                             Table    CPU time in seconds and number of nodes visited for genetic linkage analysis  Time limit   hours   bn  n  BN            BN            BN            BN            BN            BN            BN           BN           BN           BN           w  h                                                                    SamIam v        t   t   t   t   t   t   t   t   t   t    out    i                                                                                                                                                                                                                                                                                                    out                                                        out     out out  AOBB SMB i  i     i                      i     i     i     i                                                                                                                                                                                                                                                                                                                                     out                                                                                                                                                                            out              out  AOBF SMB i  i                                                                                                                                             i     i                                                                                                 out                                                                                                                                                                             Table    CPU time in seconds and number of nodes visited for solving UAI    Time limit    minutes         MARINESCU   DECHTER  and explores a search space     times smaller  On some instances  e g   p   p    p    the best first search algorithm AOBF SMB i  is several orders of magnitude faster than S UPERLINK  The performance of S AM I AM was very poor on this dataset and it was able to solve only   instances  UAI   Evaluation Dataset We also experimented with    belief networks from the UAI   Evaluation Dataset    We were not able to obtain the code from the other competitors  i e   Teams   and    in the MPE evaluation  and therefore we only compare against AOBB and SAMIAM  Table   displays a summary of the results  We observe that AOBF SMB i  is the best performing algorithm on this dataset  While on the first   instances AOBF SMB i  improves only slightly causing on average a     speed up over AOBB SMB i   on the remaining   instances  the difference between best first and depth first search is more dramatic  For example  AOBF SMB     solves the BN     instance in less than   minutes  while AOBB SMB     exceeds the    minute time limit  We notice that in some cases  e g  BN      BN       especially for large minibucket i bounds  e g  i       which generate very accurate heuristic estimates  the savings in number of nodes caused by AOBF SMB i  do not outweigh its overhead  Summary of experiments  In summary  best first AND OR search with static dynamic mini bucket heuristics improves dramatically over depth first AND OR Branch and Bound search  especially for relatively weak heuristic estimates which are generated for relatively small mini bucket i bounds  This is significant because it allows the best first search algorithms to push the landmark of computation further as the induced width of the problems increases      CONCLUSION  In this paper we evaluated a best first AND OR search algorithm which extends the classic AO algorithm and traverses a context minimal AND OR search graph for solving the MPE task in belief networks  The algorithm is guided by mini bucket heuristics which can be either pre compiled or assembled dynamically during search  The efficiency of the best first AND OR search approach compared to the depth first AND OR Branch and Bound search is demonstrated empirically on various random and real world benchmarks  including the very challenging ones that arise in the field of genetic linkage analysis  Our approach leaves room for further improvements  The space required by AOBF can be enormous  due to the fact that all the nodes generated by the algorithm have to be saved prior to termination  Therefore  AOBF can be extended to incorporate a memory bounding scheme similar to the one suggested in          http   ssli ee washington edu bilmes uai  InferenceEvaluation  Acknowledgments This work was supported by the NSF grant IIS           
 In this paper  we develop a qualitative theory of influence diagrams that can be used to model and solve sequential decision making tasks when only qualitative  or imprecise  information is available  Our approach is based on an orderof magnitude approximation of both probabilities and utilities and allows for specifying partially ordered preferences via sets of utility values  We also propose a dedicated variable elimination algorithm that can be applied for solving order of magnitude influence diagrams      INTRODUCTION  Influence diagrams have been widely used for the past three decades as a graphical model to formulate and solve decision problems under uncertainty  The standard formulation of an influence diagram consists of two types of information  qualitative information that defines the structure of the problem eg  the set of  discrete  chance variables describing the set of possible world configurations  the set of available decisions  as well as the dependencies between the variables  and quantitative information  also known as the parametric structure  that  together with the qualitative information  defines the model  The parametric structure is composed of the conditional probability distributions as well as the utility functions describing the decision makers preferences  In general  the solution to an influence diagram depends on both types of information  Quite often  however  we may have precise knowledge of the qualitative information but only very rough  or imprecise  estimates of the quantitative parameters  In such cases  the standard solution techniques cannot be applied directly  unless the missing information is accounted for  In this paper  we propose a qualitative theory for influence  This work was supported in part by the Science Foundation Ireland under grant no     PI I      Nic Wilson Cork Constraint Computation Centre University College Cork  Ireland n wilson  c ucc ie  diagrams in which such partially specified sequential decision problems can be modeled and solved  In particular  we introduce the order of magnitude influence diagram model that uses an order of magnitude representation of the probabilities and utilities  The model allows the decision maker to specify partially ordered preferences via finite sets of utility values  In this case  there will typically not be a unique maximal value of the expected utility  but rather a set of them  To compute this set and also the corresponding decision policy we propose a dedicated variable elimination algorithm that performs efficient operations on sets of utility values  Numerical experiments on selected classes of influence diagrams show that as the quantitative information becomes more precise  the qualitative decision process becomes closer to the standard one  The paper is organized as follows  Section   gives background on influence diagrams  In Section   we present the order of magnitude calculus as a representation framework for imprecise probabilities and utilities  Sections   and   describe the main operations over sets of order ofmagnitude values and introduce the order of magnitude influence diagram model  In Section   we present the results of our empirical evaluation  Section   overviews related work  while Section   provides concluding remarks      INFLUENCE DIAGRAMS  An influence diagram is defined by a tuple hX  D  U  Gi  where X    X            Xn   is a set of oval shaped nodes labeled by the chance variables which specify the uncertain decision environment  D    D            Dm   is a set of rectangle shaped nodes labeled by the decision variables which specify the possible decisions to be made in the domain  U    U            Ur   are diamond shaped nodes labeled by the utility functions which represent the preferences of the decision maker  and G is a directed acyclic graph containing all the nodes X  D  U  As in belief networks  each chance variable Xi  X is associated with a conditional probability table  CPT  Pi   P  Xi  pa Xi     where pa Xi    X  D    Xi   are the parents of Xi in   The wildcatter could do a seismic test that will help determine the geological structure of the site  The test results can show a closed reflection pattern  indication of significant oil   an open pattern  indication of some oil   or a diffuse pattern  almost no hope of oil   The probabilistic knowledge consists of the CPTs P  O  and P  S O  T    while the utility function is the sum of U   T   and U   D  O   The optimal policy is to perform the seismic test and to drill only if the test results show an open or a closed pattern  The maximum expected utility of this policy is         Figure    The oil wildcatter influence diagram  G  Similarly  each decision variable Dk  D has a parent set pa Dk    X  D    Dk   in G  denoting the variables whose values will be known at the time of the decision and may affect directly the decision  Non forgetting is typically assumed for an influence diagram  meaning that a decision node and its parents are parents to all subsequent decisions  Finally  each utility node Uj  U is associated with a utility function that depends only on the parents pa Uj   of Uj   The decision variables in an influence diagram are typically assumed to be temporally ordered  Let D    D         Dm be the order in which the decisions are to be made  The chance variables can be partitioned into a collection of disjoint sets I    I            Im   For each k  where     k   m  Ik is the set of chance variables that are observed between Dk and Dk     I  is the set of initial evidence variables that are observed before the first D    Im is the set of chance variables left unobserved when the last decision Dm is made  This induces a partial order  over X  D  as follows  I   D   I       Dm  Im      A decision policy  or strategy  for an influence diagram is a list of decision rules                 m   consisting of one rule for each decision variable  A decision rule for the decision Dk  D is a mapping k   pa Dk    Dk   where for a set S  X  D  S is the Cartesian product of the individual domains of the variables in S  Solving an influence diagram is to find the optimal decision policy that maximizes the expected utility  The maximum expected utility  MEU  is equal to    r n X X X X Y  Pi  max    Uj      max I   D   Im   Dm  Im  i    j    Example   For illustration  consider the influence diagram displayed in Figure   which is based on the classic oil wildcatter decision problem      An oil wildcatter must decide either to drill or not to drill for oil at a specific site   Variable Elimination Several exact methods have been proposed over the past decades for solving influence diagrams using local computations                        These methods adapted classical variable elimination techniques  which compute a type of marginalization over a combination of local functions  in order to handle the multiple types ofPinformation  probabilities and utilities   marginalization   and max  and combination   for probabilities    for utilities  Pinvolved in influence diagrams  Since the alternation of and max in Eq    does not commute in general  it prevents the solution technique from eliminating variables in any ordering  Therefore  the computation dictated by Eq    must be performed along a legal elimination ordering that respects   namely the reverse of the elimination ordering is some extension of  to a total order             FOUNDATIONS  Our approach towards a qualitative theory for influence diagrams is based on the qualitative decision theory proposed by Wilson       Wilsons theory defines a set of abstract quantities called extended reals  denoted by R   that are used to represent qualitative probabilities and utilities  Each extended real is a rational function p q where p and q are polynomials in o with coefficients in the rationals  where o is a very small but unknown quantity so that the extended reals can be used to represent information up to o precision  For example  quantities such as  o and o might be used for qualitative probabilities likely and unlikely respectively  and o  for a high utility  These quantities can then be combined using standard arithmetic operations between polynomials for computing expected qualitative utilities  The resulting utilities are then compared among each other by means of a total order on R that is defined in            ORDER OF MAGNITUDE CALCULUS  Rather than using extended reals explicitly  we adopt a simpler calculus that allows us to reason about the order of magnitude of the extended reals       We start with the definition of an order of magnitude value that represents a qualitative probability or utility value  D EFINITION   An order of magnitude value is a pair   h  ni  where           is called the sign and n  Z is called the order of magnitude  respectively  Intuitively  for each integer n we have an element h   ni meaning of order on   and an element h  ni meaning of order on   Moreover  if we add something of order on to something of order on then the result can be of order om   for any m  n  To ensure closure of the calculus under addition  we therefore add the element h  ni representing this set of possibilities  In the following  we also define O    h  ni   n  Z               h  i   O    h  ni   n  Z      and O     h   ni   n  Z       The element h  i will sometimes be written as    element h    i as    and element h   i as     Standard arithmetic operations such as multiplication    and addition     follow from the semantics of the order ofmagnitude values      and are defined next  D EFINITION    multiplication  Let a  b  O be such that a   h  mi and b   h  ni  We define a  b   h    m   ni  where    n   n       for n  Z     and  is the natural multiplication of signs  namely it is the commutative operation on         such that                      and                   This multiplication is associative and commutative  and a  O  a        and a      a  respectively  Furthermore  for b  O   O   we define b  to be the multiplicative inverse of b  namely h  mi    h  mi for          Given a  O  we define a b   a  b    D EFINITION    addition  Let a  b  O be such that a   h  mi and b   h  ni  We define a   b to be      h  mi if m   n      h  ni if m   n      h    mi if m   n  where                  and otherwise         Addition is associative and commutative  and a       a  a  O  For a  b  O  let b      b and a  b   a  b   Clearly  we can write h  mi   h  mi  where                and        We also have the distributivity  a  b  c  O   a   b   c   a  c   b  c       ORDERING ON SETS OF ORDER OF MAGNITUDE VALUES  We will use the following ordering over the elements of O  which is slightly stronger than that defined in       D EFINITION    ordering  Let a  b  O be such that a   h  mi and b   h  ni  We define the binary relation   on O by a   b if and only if either           and      and m  n  or          and     and m  n  or          and      or         and     and m  n  or         and     and m  n  Given a  b  O  if a   b then we say that a dominates b  For A  B  O  we say that A   B if every element of  B is dominated by some element of A  so that A contains as least as large elements as B   namely if for all b  B there exists a  A with a   b  As usual  we write a  b if and only if a   b and it is not the case that b   a  It is easy to see that   is a partial order on O and the following monotonicity property holds  P ROPOSITION   Let a  b  c  O  If a   b then a   c   b   c  and if a   b and c  O  then a  c   b  c  Any finite set of order of magnitude values can therefore be represented by its maximal elements with respect to    D EFINITION    maximal set  Given a finite set A  O  we define the maximal set of A  denoted by max   A   to be the set consisting of the undominated elements in A  namely max   A     a  A   b  A such that b  a       OPERATIONS ON SETS OF ORDER OF MAGNITUDE VALUES  We introduce now the main operations that can be performed over partially ordered finite sets of order ofmagnitude values  In particular  we extend the addition     and multiplication    operations from singleton to sets of order of magnitude values as well as define a maximization operation over such sets       ADDITION  MULTIPLICATION AND MAXIMIZATION  Given two finite sets A  B  O and q  O    we define the summation and multiplication operations as A   B    a   b   a  A  b  B  and q  A    q  a   a  A   respectively  The maximization operation is defined by max A  B    max   A  B   In order to use the order of magnitude calculus to define a qualitative version of influence diagrams we need to be sure that each of     and max is commutative and associative  and also to give sufficient conditions such that the following distributivity properties hold  q  q    q   O  and A  B  C  O D  q   A   B     q  A     q  B  D   q    q     A    q   A     q   A  D  max A  B    C   max A  C    max B  C  It is easy to see that     and max are commutative and associative  and the distributivity properties  D   and  D   hold as well  Unfortunately  the distributivity property  D   does not always hold for sets of order of magnitude values  To give a simple example  let q    h    i  q    h    i and let A    h   i  h   i   Then   q    q     A yields the set    h   i  h   i   whereas  q   A     q   A  is equal to  h   i  h   i  h   i   This property does however hold for convex sets  as we will show next   We can show now that any finite subset of O is in fact equivalent with a set of order of magnitude values containing one or two elements  namely        T HEOREM   Let A be any finite subset of O  Then either A   a  for some a  O  or  m  n  Z with m   n and           such that A   h  mi  h  ni    CONVEX SETS AND CONVEX CLOSURE  Based on Definition    every element of a finite set A  O is dominated by some maximal element in A  We can therefore define an equivalence relation between finite sets of order of magnitude values  as follows  D EFINITION    relation   Given two finite sets A  B  O  we say that A is  equivalent with B  denoted by A  B  if and only if A   B and B   A  Clearly   is an equivalence relation  namely it is reflexive  symmetric and transitive  We then have that  P ROPOSITION   Let A  B  C  O be finite sets and let q  O    The following properties hold      A  B if and only if max   A    max   B       if A  B then A   C  B   C and q  A  q  B  We introduce next the notions of convex sets and convex closure of sets of order of magnitude values  D EFINITION   A set A  O is said to be convex if q    q   O  with q    q       and a  b  A  we have that  q   a     q   b   A  The convex closure C A  of a set AP O is defined to consist of every element of k the form i    qi  ai    where k is an arbitrary natural Pk number  each ai  A  each qi  O  and i   qi      Consider two elements h  mi and h  ni in O  where we can assume without loss of generality that m  n  Any convex combination of these two elements is of the form h  li where l   m  n  and if l   n then      if l   n then      or       This implies that the convex combination of a finite number of non zero elements is finite  since every element a in the convex combination has its order restricted to be within a finite range   and so  in particular can be represented by its maximal set  In fact  this property holds even if we allow the zero element h  i  We can define now the following equivalence relation  D EFINITION    relation   Given the finite sets A  B  O  we say that A is  equivalent with B  denoted by A  B  if and only if C A   C B   Therefore  two sets of order of magnitude values are considered equivalent if  for every convex combination of elements of one  there is a convex combination of elements of the other which is at least as good  P ROPOSITION   Let A  B  C  O be finite sets and let q  O    The following properties hold      A  B if and only if max   C A     max   C B        if A  B then A   C  B   C  q  A  q  B  and A  C  B  C        OPERATIONS ON EQUIVALENT SETS OF ORDER OF MAGNITUDE VALUES  Theorem   allows us to efficiently perform the required operations  ie  summation  multiplication and maximization  on sets of order of magnitude values  We assume that the subsets O are either singleton sets or are of the form  h  mi  h  ni   where m   n  We need to ensure that the outputs are of this form as well  For a given a  O  we use the notation  a  and a to denote the sign and the order of magnitude of a  respectively  Multiplication Given A  O of the required form  and q  O    we need to generate a set A that is  equivalent with q  A  Write q as h   li  If A    h  mi  then q  A is just equal to the singleton set  h  l   mi   Otherwise  A is of the form  h  mi  h  ni   where m   n  Then q  A equals  h  l   mi  h  l   ni   which is of the required form  since l   m   l   n  Maximization Given the sets A    A            Ak  O  each of them having the required form  we want to compute a set A that is  equivalent to max A            Ak    Let A   A       Ak and  for            we define m and n as follows  if there exists no element a  A with  a     then we say that m and n are both undefined  otherwise we have that m   min l   h  li  A  and n   max l   h  li  A   respectively  The set A is computed as follows      if m  and m are both undefined  there are only negative elements  then A    h  n i       if m  is defined and either m   m or m is undefined then A    h   m  i       if m    m  and both are defined  then A    h  m i  h   m  i       if m  is undefined  no positive elements  and either n  n or n is undefined then A    h  m i  h  n i    and     if m  is undefined  there are no positive elements  and n   n then A    h  m i  h  n i   Summation Given the sets A    A            Ak  O of required form as before  we want to compute a set A that is  equivalent to  A         Ak    We can write Ai as  ai   bi   where if ai    bi then  ai      and ai   bi   Then   A         Ak     a  b  where a   a         ak and b   b         bk   We can write b more explicitly as h b   bi where b   min b            bk    and  b      if and only if all bi with minimum bi have  bi        else  b     if all bi with minimum bi have  bi       else  b      Similarly for a  If  a      then  a  b  reduces to a singleton because a   b    Example   Consider the sets A     h   i  h   i  and A     h   i  h   i   To generate A  max A    A     we first compute m     and n      and then we have that A    h   i  h   i  which corresponds to the extreme points of the input sets  Similarly  we can compute the set A   A    A    as  h   i  h   i        DISTRIBUTIVITY PROPERTIES REVISITED  In summary  we can show now that all three distributivity properties hold with respect to the  equivalence relation between finite sets of order of magnitude values  T HEOREM   q  q    q   O  and A  B  C  O finite sets we have that   D   q   A   B    q  A     q  B   and  D    q    q     A   q   A     q   A   and  D   max A  B    C  max A  C    max B  C       ORDER OF MAGNITUDE INFLUENCE DIAGRAMS  In this section  we introduce a new qualitative version of the influence diagram model based on an order of magnitude representation of the probabilities and utilities       Table    Optimal policies sets for order of magnitude influence diagrams corresponding to the oil wildcatter problem  decision rule Test  Drill   S closed  T yes S open  T yes S diffuse  T yes S closed  T no S open  T no S diffuse  T no order of magnitude MEU  o        yes no  yes yes no yes yes yes h    i  OOM ID o        o          yes  no   yes  no  yes  yes  no  yes  yes  no   yes  no   yes  no  yes  yes  no  yes  yes  no  yes  yes  no  h    i  h   i  h   i   THE QUALITATIVE DECISION MODEL  An order of magnitude influence diagram  OOM ID  is a qualitative counterpart of the standard influence diagram graphical model  The graphical structure of an OOM ID is identical to that of a standard ID  namely it is a directed acyclic graph containing chance nodes  circles  for the random discrete variables X  decision nodes  rectangles  for the decision variables D  and utility nodes  diamonds  for the local utility functions U of the decision maker  The directed arcs in the OOM ID represent the same dependencies between the variables as in the standard model  Each chance node Xi  X is associated with a conditional probability distribution Pio that maps every configuration of its scope to a positive order of magnitude probability value  namely Pio   Xi pa Xi    O    The utility functions Ujo  U represent partially ordered preferences which are expressed by finite sets of order of magnitude values  namely Ujo   Qj   O   where Qj is the scope of Uj   Solving an order of magnitude influence diagram is to find the optimal policy                 mQ  that maximizes Pr the n order of magnitude expected utility i   Pio  j   Ujo   We define the optimal policies set of an order of magnitude influence diagram to be the set of all policies having the same maximum order of magnitude expected utility       Figure    Order of magnitude probability and utility functions corresponding to the oil wildcatter influence diagram   AN EXAMPLE  Figure   displays the order of magnitude probability and utility functions of an OOM ID corresponding to the oil  wildcatter decision problem from Example    For our purpose  we used an extension of Spohns mapping from the original probability distributions and utility functions to their corresponding order of magnitude approximation          Specifically  given a small positive o      the order of magnitude approximation of a probability value p         is h   ki such that k  Z and ok     p  ok   while the order of magnitude approximation of a positive utility value u     is h   ki such that ok  u   o k     the case of negative utilities is symmetric   For example  if we consider o       then the probability P  S   closed O   dry  T   yes         is mapped to h    i  while the utilities U   O   dry  D   yes       and U   O   soaking  D   yes        are mapped to h   i and h    i  respectively  Table   shows the optimal policies sets  including the maximum order of magnitude expected utility  obtained for the order of magnitude influence diagrams corresponding to o                      When o        we can see that there are two optimal policies having the same maximum order of magnitude expected utility  namely    for T   yes  and    for T   no   Therefore  if the seismic test is performed  T   yes  then drilling is to be done only if the test results show an open or closed pattern  Otherwise  T   no   the wildcatter will drill regardless of the test results  Ties like these at the decision variables are expected given that the order of magnitude probabilities and utilities represent abstractions of the real values  The expected utilities of   and   in the original influence diagram are         and        respectively   Algorithm    ELIM OOM ID  When o         we also see that both drilling options are equally possible if the seismic test is performed and the test results show a diffuse pattern  In this case  there are four optimal policies having the same maximum order ofmagnitude expected utility  Finally  when o          we can see that all decision options are possible and the corresponding optimal policies set contains     policies  The explanation is that the order of magnitude influence diagram contains in this case only trivial order of magnitude values such as h    i  h   i and h   i  respectively   Data  An OOM ID hX  D  U  Gi  bucket structure along a legal elimination ordering of the variables o Result  An optimal policy     top down phase for p   t downto   do let p             j   and p             k   be the probability and utility components in buckets p  if Yp is a chance variable then P Q p  Yp ji   i Q P P p   p     Yp    ji   i      kj   j                else if Yp is a decision variable then P if p    then p  maxYp kj   j else Q p  maxYp ji   i Q P p   maxYp    ji   i      kj   j                 VARIABLE ELIMINATION        Theorem   ensures the soundness and correctness of a variable elimination procedure using the summation      multiplication    and maximization  max  operations over partially ordered sets of order of magnitude values  for solving order of magnitude influence diagrams  Therefore  a variable elimination algorithm that computes the optimal policy of an order of magnitude influence diagram  and also the maximum order of magnitude expected utility  is described by Algorithm    The algorithm  called ELIM OOM ID  is based on Dechters bucket elimination framework for standard influence diagrams     and uses a bucket structure constructed along a legal elimination ordering o   Y          Yt of the variables in X  D  The bucket data structure  called buckets  associates each bucket with a single variable  The bucket of Yp contains all input probability and utility functions whose highest variable is Yp   The algorithm processes each bucket  top down from the last to the first  by a variable elimination procedure that computes new probability  denoted by   and utility  denoted by   components which are then placed in corresponding lower buckets  lines       The p of a chance bucket is generated by multiplying all probability components and eliminating by summation the bucket variable  The p of a chance bucket is computed as the average utility of the bucket  normalized by the buckets compiled p   For a decision variable  we compute the p and p components in a similar manner and eliminate the bucket variable by maximization  In this case  the product of the probability components in the bucket is a constant when viewed as a function of the buckets decision variable         and therefore  the compiled p is a constant as well  In the second  bottom up phase  the algorithm computes an optimal policy  The decision buckets are processed in reverse order  from the first variable to the last  Each decision rule is generated by taking the argument of the maximization operator applied over the combination of the probability and utility components in the respective bucket  for each configuration of the variables in the buckets scope  ie  the union of the scopes of all functions in that bucket minus the      place each p and p in the bucket of the highest index variable in its scope    bottom up phase for p     to t do if Yp is a decision variable then P Q p  arg maxYp    ji   i      kj   j        p      return                 bucket variable Yp    T HEOREM    complexity  Given an OOM ID with n variables  algorithm ELIM OOM ID is time and space O n   k wo    where wo is the treewidth of the legal elimination ordering o and k bounds the domain size of the variables      EXPERIMENTS  In this section  we evaluate empirically the quality of the decision policies obtained for order of magnitude influence diagrams  All experiments were carried out on a    GHz quad core processor with  GB of RAM  Methodology We experimented with random influence diagrams described by the parameters hnc   nd   k  p  r  ai  where nc is the number of chance variables  nd is the number of decision variables  k is the maximum domain size  p is the number of parents in the graph for each variable  r is the number of root nodes and a is the arity of the utility functions  The structure of the influence diagram is created by randomly picking nc   nd  r variables out of nc   nd and  for each  selecting p parents from their preceding variables  relative to some ordering  whilst ensuring that the decision variables are connected by a directed path  A single utility node with a parents picked randomly from the chance and decision nodes is then added to the graph  We generated two classes of random problems with parameters hn               i and having either positive utilities only or mixed  positive and negative  utilities  They are   denoted by P   hn               i and M   hn               i  respectively  In each case      of the chance nodes were assigned extreme CPTs which were populated with numbers drawn uniformly at random between     and       whilst ensuring that the table is normalized  The remaining CPTs were randomly filled using a uniform distribution between   and    For class P   the utilities are of the form   u   where u is an integer uniformly distributed between   and    For class M   the utilities are of the form    u or   u   where u is between   and    as before  and we have an equal number of positive and negative utility values  Each influence diagram instance was then converted into a corresponding order of magnitude influence diagram using the mapping of the probabilities and utilities described in Section      for some o      Intuitively  the smaller o is  the coarser the order of magnitude approximation of the exact probability and utility values  ie  more information is lost    Results Figure   displays the distribution of the relative errors med  top  and max  bottom  obtained on orderof magnitude influence diagrams derived from class P  ie  positive utilities   as a function of the problem size  given by the number of variables   for o                      Each data point and corresponding error bar represents the   th   median and   th percentiles obtained over    random problem instances generated for the respective problem size  We can see that med is the smallest  less than      for o        However  as o decreases  the loss of information due to the order of magnitude abstraction increases and the corresponding relative errors med increase significantly  Notice that the best policy max derived from the order of magnitude influence diagram was almost identical to that of the corresponding standard influence diagram  for all o  ie  the error max is virtually zero   Figure   shows the distribution of med  top  and max  bottom  obtained on order of magnitude influence diagrams from class M  ie  mixed utilities   The pattern of the results is similar to that from the previous case  However  in this case  the errors span over two or three orders of  relative error of OOM median policy                                                           variables                 variables                  relative error of OOM best policy      Measures of Performance To measure how close the decision policies derived from the optimal policy set of an order of magnitude influence diagram are to the optimal policy of the corresponding standard influence diagram  we use two relative errors  defined as follows  Let I be an influence diagram and let Io be the corresponding order ofmagnitude approximation  for some o value  We sample s different policies  uniformly at random  from the optimal policies set of Io   and for each sampled policy we compute its expected utility in I  Let med be a policy corresponding to the median expected utility vmed amongst the samples  We define the relative error med     v  vmed   v   where v is the maximum expected utility of the optimal policy in I  Similarly  we define max     v  vmax   v   where max is the best policy having the highest expected utility vmax amongst the samples                                                         Figure    Results for class P influence diagrams  We show the distribution of the relative errors med  top  and max  bottom  for o                        of samples s        magnitude  especially for o        and        This is because the sampled policy space includes policies which are quite different from each other and  although they have the same maximum order of magnitude expected utility  their expected utility in the corresponding standard influence diagram is significantly different  For this reason  we looked in more detail at the distribution of the expected utility values of     policies sampled uniformly at random from the optimal policies set of a class M OOM ID instance with    variables  for o                      As expected  we observed that the smallest sample variance is obtained for o        For o        and o          the samples are spread out even more from the mean  and the variance of the expected utility is significantly larger  This explains the large variations of the relative errors med and max   especially for smaller o values  eg  o        and o               RELATED WORK  Several extensions of the standard influence diagram model have been proposed in recent years to deal with imprecise probabilistic and utility information  Garcia and Sabbadin     introduced possibilistic influence diagrams to model and solve decision making problems under qualitative uncertainty in the framework of possibilistic theory  Pralet et al     considered a generalized influence diagram system   attribute utility allowing trade offs   relative error of OOM median policy               
