
Recent work on approximate linear programming
(ALP) techniques for first-order Markov Decision Processes (FOMDPs) represents the value function linearly w.r.t. a set of first-order basis functions and uses
linear programming techniques to determine suitable
weights. This approach offers the advantage that it
does not require simplification of the first-order value
function, and allows one to solve FOMDPs independent of a specific domain instantiation. In this paper,
we address several questions to enhance the applicability of this work: (1) Can we extend the first-order
ALP framework to approximate policy iteration and if
so, how do these two algorithms compare? (2) Can
we automatically generate basis functions and evaluate their impact on value function quality? (3) How
can we decompose intractable problems with universally quantified rewards into tractable subproblems?
We propose answers to these questions along with a
number of novel optimizations and provide a comparative empirical evaluation on problems from the ICAPS
2004 Probabilistic Planning Competition.

1

Introduction

Markov decision processes (MDPs) have become the de
facto standard model for decision-theoretic planning problems. While classic dynamic programming algorithms for
MDPs require explicit state and action enumeration, recent
techniques for exploiting propositional structure in factored MDPs [4] avoid explicit state and action enumeration.
While such techniques for factored MDPs have proven effective, they cannot generally exploit first-order structure.
Yet many realistic planning domains are best represented
in first-order terms, exploiting the existence of domain objects, relations over these objects, and the ability to express
objectives and action effects using quantification.
As a result, a new class of algorithms has been introduced to explicitly handle MDPs with relational (RMDP)

Craig Boutilier
University of Toronto
Department of Computer Science
Toronto, ON, M5S 3H5, CANADA
cebly@cs.toronto.edu

and first-order (FOMDP) structure.1
Symbolic dynamic programming (SDP) [5], first-order value iteration (FOVIA) [12, 13], and the relational Bellman algorithm (ReBel) [14] are model-based algorithms for solving FOMDPs and RMDPs, using appropriate generalizations of value iteration. Approximate policy iteration [7]
induces rule-based policies from sampled experience in
small-domain instantiations of RMDPs and generalizes
these policies to larger domains. In a similar vein, inductive policy selection using first-order regression [9] uses
regression to provide the hypothesis space over which a
policy is induced. Approximate linear programming (for
RMDPs) [10] is an approximation technique using linear
program optimization to find a best-fit value function over
a number of sampled RMDP domain instantiations.
A recent technique for first-order approximate linear programming (FOALP) [21] in FOMDPs approximates a
value function by a linear combination of first-order basis
functions. While FOALP incorporates elements of symbolic dynamic programming (SDP) [5], it uses a more compact approximation framework and avoids the need for logical simplification. This stands in contrast with exact value
iteration frameworks [5, 12, 13, 14] that prove intractable
in many cases due to blowup of the value function representation and the need to perform complex simplifications. And in contrast to approaches that require sampling
of ground domains [7, 9, 10], FOALP solves a FOMDP
at the first-order level, thus obviating the need for domain
instantiation. However, FOALP is just one of many possible approaches to linear value approximation and this begs
the question of whether we can generalize it to other approaches such as first-order approximate policy iteration
(FOAPI). If so, it would be informative to obtain a comparative empirical evaluation of these algorithms.
However, determining the most effective algorithm for
linear value-approximation is only the first step towards
the development of practical approximation techniques for
1

We use the term relational MDP to refer models that allow
implicit existential quantification, and first-order MDP for those
with explicit existential and universal quantification.

FOMDPs. We address the important issue of automatic basis function generation by extending regression-based techniques originally proposed by Gretton and Thiebaux [9].
In addition, we address issues that arise with universal
rewards—while symbolic dynamic programming is welldefined for FOMDP domains with universal rewards, classical first-order logic is insufficient for defining a compact set of basis functions that can adequately approximate
the value function in such domains. We propose a technique for decomposing problems with universal rewards
while facilitating “coordination” among decomposed subproblems. Finally, we present a number of novel optimizations that enhance the performance of FOALP and FOAPI.
We provide a comparative evaluation of these algorithms
on problems from the ICAPS 2004 International Probabilistic Planning Competition (IPPC).

2

Markov Decision Processes

We first review linear value-approximation of MDPs.
2.1 MDP Representation
An MDP consists of: a finite state space S; a finite set
of actions A; a transition function T , with T (s, a, ·) denoting a distribution over S for all s ∈ S, a ∈ A; and
a reward function R : S × A → R. Our goal is to
find a policy π that maximizes the value function, defined using the infinite
P∞horizon, discounted reward criterion: V π (s) = Eπ [ t=0 γ t · rt |s], where r t is a reward
obtained at time t and 0 ≤ γ < 1 is the discount factor.
For any function V over S and policy π,
define the P
policy backup operator B π
as:
π
The
ac(B V )(s) = γ t T (s, π(s), t)V (t).
tion backup Poperator B a for action a is:
(B a V )(s) = γ t T (s, a, t)V (t).
The function
V π (s) satisfies the fixed point relationship V π (s) =
R(s, π(s)) + (B π V π )(s). Furthermore, the Q-function
Qπ , denoting the expected future discounted reward
achieved by taking action a in state s and following policy
π thereafter, satisfies Qπ (s, a) = R(s, a) + (B a V π )(s).
We define the greedy policy w.r.t. V as follows:
πgre (V )(s) = arg maxa R(s, a) + (B a V )(s). If π ∗
is the optimal policy and V ∗ its value function, we have
the relationship V ∗ (s) = maxa R(s, a) + (B a V ∗ )(s).
Letting Q∗ (s, a) = R(s, a) + (B a V ∗ )(s), we also have
π ∗ (s) = πgre (V ∗ )(s) = arg maxa Q∗ (s, a).
2.2

Linear Value Approximation for MDPs

In a linear value function representation, we represent
V as a linear combination of k basis functions bj :
Pk
V (s) = j=1 wj bj (s). Our goal is to find weights that
approximate the optimal value function as closely as possible. We note that because both backup operators B π and
B a are linear operators, the backup of a linear combination of basis functions is just the linear combination of the

backups of the individual basis functions.
Approximate Linear Programming: One way of finding a good linear approximation is to cast the optimization problem as a linear program that directly solves for the
weights of an L1 -minimizing approximation of the optimal
value function [6]:
Variables: w1 , . . . , wk
Minimize:

k
XX

wj bj (s)

(1)

s∈S j=1

Subject to: 0 ≥ R(s, a) +

k
X

wj [(B a bj )(s) − bj (s)] ; ∀a, s

j=1

While the size of the objective and the number of constraints in this LP is proportional to the number of states
(and therefore exponential), recent solution techniques use
compact, factored basis functions and exploit the reward
and transition structure of factored MDPs [11, 22], making
it possible to avoid generating an exponential number of
constraints (and rendering the entire LP compact).
Approximate Policy Iteration: Likewise, we can generalize policy iteration to the approximate case by calculating
(i)
successive iterations of weights wj that represent the best
approximation of the fixed point value function for policy
π (i) at iteration i. We do this by performing the following two steps at each iteration: (1) deriving the greedy polPk
(i)
icy: π (i+1) ← πgre ( j=1 wj bj (s)) and (2) using the following LP to determine the weights for the Bellman-errorminimizing approximate value function:
(i+1)

Variables: w1

(i+1)

, . . . , wk

Minimize: φ(i+1)

(2)

Subject to: φ(i+1) ≥ R(s, π(s)) +

k
X

(i+1)

[wj

(B π

(i+1)

bj )(s)]

j=1

−

k
X

(i+1)

[wj

bj (s)] ; ∀a, s

j=1

If policy iteration converges (i.e., if w
~ (i+1) = w
~ (i+1) ), then
Guestrin et al. [11] provide the following bound on the
loss of V (i+1) w.r.t. the optimal value function V ∗ (since
the Bellman error is bounded by the objective φ(i+1) of the
optimal LP solution at iteration i + 1):
kV ∗ − V (i+1) (s)k∞ ≤

3
3.1

2γφ(i+1)
1−γ

(3)

First-Order MDPs
The Situation Calculus

The situation calculus [19] is a first-order language for axiomatizing dynamic worlds. Its basic ingredients consist
of actions, situations, and fluents. Actions are first-order
terms involving action function symbols. For example, the
action of driving a truck t from city c1 to city c2 might

be denoted by the action term drive(t, c1 , c2 ). A situation
is a first-order term denoting the occurrence of a sequence
of actions. These are represented using a binary function
symbol do: do(α, s) denotes the situation resulting from
doing action α in situation s. In a logistics domain, the
situation term do(drive(t, c2 , c3 ), do(drive(t, c1 , c2 ), S0 ))
denotes the situation resulting from executing sequence
[drive(t, c1 , c2 ),drive(t, c2 , c3 )] in S0 . Relations whose
truth values vary between states are called fluents, and are
denoted by predicate symbols whose last argument is a situation term. For example, TAt(t, paris, s) is a relational
fluent meaning that truck t is in paris in situation s.2
A domain theory is axiomatized in the situation calculus with four classes of axioms [19]. The most important of these are successor state axioms (SSAs). There
is one SSA for each fluent F (~x, s), with syntactic form
F (~x, do(a, s)) ≡ ΦF (~x, a, s) where ΦF (~x, a, s) is a formula with free variables among a, s, ~x. These characterize
the truth values of the fluent F in the next situation do(a, s)
in terms of the current situation s, and embody a solution
to the frame problem for deterministic actions [19].
The regression of a formula ψ through an action a is a formula ψ 0 that holds prior to a being performed iff ψ holds
after a. We refer the reader to [5, 21] for a formal definition
and discussion of the Regr(·) operator. Here we simply
note that it is defined compositionally and that regression
of a formula reduces to the regression of all fluents in a
way that is naturally supported by the format of the SSAs.
3.2

Case Representation and Operators

Prior to generalizing the situation calculus to permit a firstorder representation of MDPs, we introduce a case notation to allow first-order specifications of the rewards, probabilities, and values required for FOMDPs (see [5, 21] for
formal details):
t =

φ1 : t 1
: : :
φn : t n

≡

W

i≤n {φi

∧ t = ti }

Here the φi are state formulae (whose situation term does
not use do) and the ti are terms. Often the ti will be constants and the φi will partition state space. For example,
using Dst(t, c) to indicate the destination of truck t is city
c, we may represent our reward function rCase(s, a) as:
a = noop ∧ ∀t, c TAt(t, c, s) ⊃ Dst(t, c) : 10
rCase(s, a) = a 6= noop ∧ ∀t, c TAt(t, c, s) ⊃ Dst(t, c) : 9
∃t, c TAt(t, c, s) ∧ ¬Dst(t, c)
: 0

Here, we receive a reward of 10 (9) if all trucks are at their
destination and a noop is (not) performed. In all other cases
we receive 0 reward. We use vCase(s) to represent value
functions in exactly the same manner.
2
In contrast to states, situations reflect the entire history of
action occurrences. However, the specification of dynamics is
Markovian and allows recovery of state properties from situation
terms.

Intuitively, to perform an operation on two case statements,
we simply take the cross-product of their partitions and perform the corresponding operation on the resulting paired
partitions. Letting each φi and ψj denote generic first-order
formulae, we can perform the “cross-sum” ⊕ of two case
statements in the following manner:
φ1 : 10
φ2 : 20

⊕

ψ1 : 1
ψ2 : 2

=

φ1 ∧ ψ 1
φ1 ∧ ψ 2
φ2 ∧ ψ 1
φ2 ∧ ψ 2

: 11
: 12
: 21
: 22

Likewise, we can perform and ⊗ by, respectively, subtracting or multiplying partition values (as opposed to
adding them) to obtain the result. Some partitions resulting
from the application of the ⊕, , and ⊗ operators may be
inconsistent; we simply discard such partitions since they
can obviously never correspond to any world state.
We define four additional operators on cases [5, 21]:
Regr(·), ∃~x, max, and ∪. Regression Regr(C) and existential quantification ∃~xC can both be applied directly to
the individual partition formulae φi of case C. The maximization operation max C sorts the partitions of case C
from largest to smallest, rendering them disjoint in a manner that ensures each portion of state space is assigned the
highest value. The union operation C1 ∪ C2 denotes a simple union of the case partitions from cases C1 and C2 .
3.3

Stochastic Actions and the Situation Calculus

To generalize the classical situation calculus to stochastic
actions required by FOMDPs, we decompose stochastic
“agent” actions into a collection of deterministic actions,
each corresponding to a possible outcome of the stochastic
action. We then specify a distribution according to which
“nature” may choose a deterministic action from this set
whenever that stochastic action is executed. As a consequence we need only formulate SSAs using the deterministic nature’s choices [1, 5], thus obviating the need for a
special treatment of stochastic actions in SSAs.
Letting A(~x) be a stochastic action with nature’s choices
(i.e., deterministic actions) n1 (~x), · · · , nk (~x), we represent the distribution over ni (~x) given A(~x) using the notation pCase(nj (~x), A(~x), s). Continuing our logistics example, if the effect of driving a truck depends on whether
it is snowing in the city of origin, then we decompose
the stochastic drive action into two deterministic actions
driveS and driveF , denoting success and failure, respectively, and specify a distribution over nature’s choice:
pCase( driveS (t, c1 , c2 ),
drive(t, c1 , c2 ), s)

=

snow (c1 , s) : 0.6
¬snow (c1 , s) : 0.9

pCase( driveF (t, c1 , c2 ),
drive(t, c1 , c2 ), s)

=

snow (c1 , s) : 0.4
¬snow (c1 , s) : 0.1

Next, we define the SSAs in terms of these deterministic

choices.3 Assuming that nature’s choice of deterministic
actions for stochastic action drive(t, c1 , c2 ) decomposes as
above, we can express an SSA for TAt:
TAt(t, c, do(a, s)) ≡
∃c1 TAt(t, c1 , s) ∧ a = driveS (t, c1 , c)∨
TAt(t, c, s) ∧ ¬(∃c2 c 6= c2 ∧ a = driveS (t, c, c2 ))

Intuitively, the only actions that can change the fluent TAt
are successful drive actions. If a successful drive action
does not occur then the fluent remains unchanged.
3.4

Symbolic Dynamic Programming

Backing up a value function vCase(s) through an action
A(~x) yields a case statement containing the logical description of states that would give rise to vCase(s) after doing action A(~x), as well as the values thus obtained (i.e., a
Q(s, a) function in classical MDPs). There are in fact three
types of backups that we can perform. The first, B A(~x) , regresses a value function through an action and produces a
case statement with free variables for the action parameters. The second, B A , existentially quantifies over the free
A
applies the max opvariables ~x in B A(~x) . The third, Bmax
A
erator to B which results in a case description of the regressed value function indicating the best value that could
be achieved by executing any instantiation of A(~x) in the
pre-action state. To define the backup operators, we first
define a slightly modified version of the first-order decision theoretic regression (FODTR) operator [5]:
F ODT R(vCase(s), A(~x)) =
γ [⊕j {pCase(nj (~x), s) ⊗ Regr(vCase(do(nj (~x), s)))}]

We next next define the three backup operators:
B A(~x) (vCase(s)) = rCase(s, a) ⊕ FODTR(vCase(s), A(~x))
(4)
B A (vCase(s)) = ∃~x B A(~x) (vCase(s))
A
Bmax
(vCase(s))

(5)

A

= max(B (vCase(s)))

Previous work [21] provides examples of B

(6)
A(~
x)

and

A
Bmax
.

additive structure inherent in many real-world problems
(e.g., additive reward functions or problems with independent subgoals). Unlike exact solution methods where value
functions can grow exponentially in size during the solution process and must be logically simplified [5], here we
maintain the value function in a compact form that requires
no simplification, just discovery of good weights.
We can easily apply the backup operator B A to this representation and obtain some simplification as a result of the
structure in Eq. 7. We simply substitute the value function expression in Eq. 7 into the definition B A(~x) (Eq. 4).
Exploiting the properties of the Regr and ⊕ operators, we
find that the backup B A(~x) of a linear combination of basis
functions is simply the linear combination of the FODTR
of each basis function:
B A(~x) (⊕i wi bCase i (s)) =
(8)
rCase(s, a) ⊕ (⊕i wi FODTR(bCase i (s), A(~x)))

Given the definition of B A(~x) for a linear combination of
A
basis functions, corresponding definitions of B A and Bmax
follow directly from Eqs. 5 and 6. It is important to note
that during the application of these operators, we never explicitly ground states or actions, in effect achieving both
state and action space abstraction.
4.2

First-order Approximate Linear Programming

Now we have all of the building blocks required to define
first-order approximate linear programming (FOALP) and
first-order approximate policy iteration (FOAPI). For now
we simply focus on the algorithm definitions; we will address efficient implementation in a subsequent section.
FOALP was introduced by Sanner and Boutilier [21]. Here
we present a linear program (LP) with first-order constraints that generalizes Eq. 1 from MDPs to FOMDPs:
Variables: wi ; ∀i ≤ k
Minimize:

k
X
i=1

4

Linear Value Approximation for FOMDPs

4.1

Following [21], we represent a value function as a weighted
sum of k first-order basis functions, denoted bCase i (s),
each containing a small number of formulae that provide a
first-order abstraction of state space:
(7)

Using this format, we can often achieve a reasonable approximation of the exact value function by exploiting the
3

X
hφj ,tj i∈bCase i

A
Bmax
(⊕ki=1

(⊕ki=1

Value Function Representation

vCase(s) = ⊕ki=1 wi · bCase i (s)

Subject to: 0 ≥

wi

SSAs can often be compiled from “effect” axioms that specify action effects [19] and effect axioms can be compiled from
PPDDL probabilistic planning domain specifications [25].

tj
|bCase i |

wi · bCase i (s))

wi · bCase i (s)) ; ∀ A, s

(9)

The objective of this LP requires some explanation. If we
were to directly generalize the objective for MDPs to that
of FOMDPs, the objective would be ill-defined (it would
sum over infinitely many situations). To remedy this, we
suppose that each basis function partition is chosen because
it represents a potentially useful partitioning of state space,
and thus sum over each case partition.
This LP also contains a first-order specification of constraints, which somewhat complicates the solution. Before
tackling this, we introduce a general first-order LP format

πCase(s). Consequently, we define an action restricted
policy πCase Ai (s) as follows:

that we can reuse for FOAPI:
Variables: v1 , . . . , vk ;
Minimize: f (v1 , . . . , vk )
Subject to: 0 ≥ case1,1 (s) ⊕ . . . ⊕ case1,n (s) ; ∀ s
:
0 ≥ casem,1 (s) ⊕ . . . ⊕ casem,n (s) ; ∀ s

πCase Ai (s) = {hφ, ti|hφ, ti ∈ πCase(s) and hφ, ti → Ai }
(10)

The variables and objective are as defined in a typical
LP, the main difference being the form of the constraints.
While there are an infinite number of constraints (i.e., one
for every situation s), we can work around this since case
statements are finite. Since the value ti for each case partition hφi (s), ti i is piecewise constant over all situations
satisfying φi (s), we can explicitly sum over the casei (s)
statements in each constraint to yield a single case statement. For this “flattened” case statement, we can easily verify that the constraint holds in the finite number of
piecewise constant partitions of the state space. However,
generating the constraints for each “cross-sum” can yield
an exponential number of constraints. Fortunately, we can
generalize constraint generation techniques [22] to avoid
generating all constraints. We refer to [21] for further details. Taken together, these techniques yield a practical
FOALP solution to FOMDPs.
4.3

First-order Approximate Policy Iteration

We now turn to the first contribution of this paper, a novel
generalization of approximate policy iteration from the
classical MDP case (Eq. 1) to FOMDPs.
Policy iteration requires a suitable first-order policy representation. Given a value function vCase(s) it is easy to derive a greedy policy from it. Assuming we have m parameterized actions {A1 (~x), . . . , Am (~x)}, we can represent the
policy πCase(s) as:
πCase(s) = max(

[

B Ai (vCase(s)))

(11)

i=1...m

Here, B Ai (vCase(s)) represents the values that can be
achieved by any instantiation of the action Ai (~x). The max
case operator enforces that each portion of pre-action state
space is assigned the maximal Q-function partition. For
bookkeeping purposes, we require that each partition hφ, ti
in B Ai (vCase(s)) maintain a mapping to the action Ai
that generated it, which we denote as hφ, ti → Ai . Then,
given a particular world state s, we can evaluate πCase(s)
to determine which policy partition hφ, ti → Ai is satisfied in s and thus, which action Ai should be applied. If
we retrieve the bindings of the existentially quantified action variables in φ (recall that B Ai existentially quantifies
these), we can easily determine the parameterization of action Ai that should apply according to the policy.
For our algorithms, it is useful to define a set of case
statements for each action Ai that is satisfied only in the
world states where Ai should be applied according to

Following the approach to approximate policy iteration for
factored MDPs provided by Guestrin et al. [11], we can
generalize approximate policy iteration to the first-order
(i)
case by calculating successive iterations of weights wj
that represent the best approximation of the fixed point
value function for policy πCase (i) (s) at iteration i. We do
this by performing the following two steps at every iteration
i: (1) Obtaining the policy πCase(s) from the current value
Pk
(i)
function and weights ( j=1 wj bCase j (s)) using Eq. 11,
and (2) solving the following LP in the format of Eq. 10 that
determines the weights of the Bellman-error-minimizing
approximate value function for policy πCase(s):
(i+1)

Variables: w1

(i+1)

, . . . , wk

Minimize: φ(i+1)
Subject to: φ

(i+1)

(12)
≥ πCase A (s) ⊕
(i+1)

⊕kj=1 wj

(i+1)
⊕kj=1 [wj
bCase j (s)]

A
(Bmax
bCase j )(s) ; ∀A, s

We’ve reached convergence if π (i+1) = π (i) . If the policy
iteration converges, then we note that the loss bounds for
API (Eq. 3) generalize directly to the first-order case.

5

Greedy Basis Function Generation

The use of linear approximations requires a good set of
basis functions that span a space that includes a good approximation to the value function. While some work has
addressed the issue of basis function generation [18, 16],
none has been applied to RMDPs or FOMDPs. We consider a basis function generation method that draws on the
work of Gretton and Thiebaux [9], who use inductive logic
programming (ILP) techniques to construct a value function from sampled experience. Specifically, they use regressions of the reward as candidate building blocks for
ILP-based construction of the value function. This technique has allowed them to generate fully or k-stage-to-go
optimal policies for a range of Blocks World problems.
We leverage a similar approach for generating candidate
basis functions for use in the FOALP or FOAPI solution
techniques. Fig. 1 provides an overview of our basis function generation algorithm. The motivation for this approach
is as follows: if some portion of state space φ has value
v > τ in an existing approximate value function for some
nontrivial threshold τ , then this suggests that states that can
reach this region (i.e., found by Regr(φ) through some action) should also have reasonable value. However, since
we have already assigned value to φ, we want the new basis function to focus on the area of state space not covered
by φ so we negate it and conjoin it with Regr(φ). This “orthogonality” of newly generated basis functions also allows
for computation optimizations (see Sec. 7).

Input: A first-order MDP specification, a value threshold τ , an
iteration limit n, and a solution method (FOALP or FOAPI).
Output: Weights wi and basis functions bCase i (s) for
an approximated value function containing all regressions of
rCase(s) having value at least value τ .
1. Begin with the reward rCase(s) as the initial candidate
basis function. (We note that rCase(s) can be a sum of
cases, so we can start with many basis functions.)
2. For every basis function partition hφi (s), ti i and action Ai ,
derive ¬φi ∧ ∃~x Regr(φi (do(Ai (~x), s))), adding a new
basis function consisting of it and its negation having respective values 1 and 0. (Redundant basis functions are not
inserted.)
3. Solve for the weights wi using FOALP or FOAPI.
4. If the weight of any basis function is below a threshold τ ,
discard the partition and ensure that it is not regenerated in
the future.
5. If new basis functions were generated on this step and the
iteration limit n has not been reached, return to step 2.

Figure 1: The basis function generation algorithm.

6

Handling Universal Rewards

In first-order domains, we are often faced with universal reward expressions that assign some positive value to
the world states satisfying a formula of the general form
∀y φ(y, s), and 0 otherwise. For instance, in our logistics example a reward may be given for having all trucks at
their assigned destination: ∀t, cDst(t, c) → TAt(t, c, s).
One difficulty with such rewards is that our basis function approach provides a piecewise constant approximation
to the value function (i.e., each basis function aggregates
state space into regions of equal value, with the linear combination simply providing constant values over somewhat
smaller regions). However, the value function for problems with universal rewards typically depends (often in a
linear or exponential way) on the number of domain objects of interest. For instance, in our example, value at a
state depends on the number of trucks not at their proper
destination (since that impacts the time it will take to obtain the reward). Unfortunately, this cannot be represented
concisely using the piecewise constant decomposition offered by first-order basis functions. As noted by Gretton
and Thiebaux [9], effectively handling universally quantified rewards is one of the most pressing issues in the practical solution of FOMDPs.
To address this problem we adopt a decompositional approach, motivated in part by techniques for additive rewards in MDPs [3, 23, 17, 18]. Intuitively, given a goaloriented reward that assigns positive reward if ∀yG(y, s) is
satisfied, and zero otherwise, we can decompose it into a
set of ground goals {G(y~1 ), . . . , G(y~n )} for all possible y~j
in a ground domain of interest. If we reach a state where
all ground goals are true, then we have satisfied ∀yG(y, s).
Of course, our methods solve FOMDPs without knowledge

Input: (1) For each action template Ai (~x), a set of Q-functions
QG(~y∗ ) (Ai (~x), s) for a specific ground instantiation ~
y ∗ of a goal
G. (2) A set of n unsatisfied goals {G(y~1 ), . . . , G(y~n ))} to
achieve. (3) A ground state s to find the best action for.
Output: The optimal ground action A(~x∗ ) to execute w.r.t. to
the given state and additive
decomposition of unsatisfied goals:
P
x), s)
A(~x∗ ) = arg maxi,~x n
j=1 QG(y~j ) (Ai (~
1. For each action template Ai (~x) and goal G(y~j ), replace
all occurrences of ~
y ∗ in QG(~y∗ ) (Ai (~x), s) with y~j to obtain a set of goal-specific Q-functions for each Ai (~x):
{QG(y~1 ) (Ai (~x), s), . . . , QG(y~n ) (Ai (~x), s)}.
2. Initialize an empty hash table h whose entries A(~x) → v
map ground actions A(~x) to their corresponding value v.
3. For j = 1 . . . n do:
For all Ai and case partitions p in QG(y~j ) (Ai (~x), s):
• NOTE: By construction from the B A operator, a case
partition p for a Q-function QG(y~j ) (Ai (~x), s) has
the format h∃~x φ(x) : ti where we obtain the value
t when Ai (~x) is performed if the ground binding ~x is
one satisfying ∃~x φ(x).
• For each ground binding ~x satisfying ∃x φ(x):
– If A(x) → v is already in h then: update h to
contain A(x) → (v + nt ).
– Else: update h to contain A(x) → nt ).

Figure 2: Policy evaluation algorithm for universal rewards.
of the specific domain, so the set of ground goals that will
be faced at run-time is unknown. So in the offline solution
of the MDP we assume a a generic ground goal G(~y ∗ ) for
a “generic” object vector ~y ∗ . It is easy to construct an instance of the reward function rCase(s) for this single goal,
and solve for this simplified generic goal using FOALP or
FOAPI. This produces a value function and policy that assumes that ~y ∗ is the only object vector of interest (i.e., satisfying relevant type constraints and preconditions) in the domain. From this, we can also derive the optimal Q-function
for the simplified “generic” domain (and action template
Ai (~x)): QG(~y∗ ) (Ai (~x), s) = B Ai (vCase(s)).4 Intuitively,
given a ground state s, the optimal action for this generic
goal can be determined by finding the ground Ai (~x∗ ) for
this s with max Q-value.
With the solution (i.e., optimal Q-function) of a generic
goal FOMDP in hand, we address the online problem of
action selection for a specific domain instantiation. Assume a set of ground goals {G(y~1 ), . . . , G(y~n )} corresponding to a specific domain given at run-time. If we
assume that (typed) domain objects are treated uniformly
in the uninstantiated FOMDP, as is the case in many logistics and planning problems, then we obtain the Qfunction for any goal G(y~j ) by replacing all ground terms
~y ∗ with the respective terms y~j in QG(~y∗ ) (Ai (~x), s) to obSince the B A operator can often retain much of the additive
structure in the linear approximation of vCase(s) [21], representation and computation with this Q-function is very efficient.
4

tain QG(y~j ) (Ai (~x), s).
Action selection requires finding an action that maximizes
value w.r.t. the original universal reward. Following [3, 17],
we do this by treating the sum of the Q-values of any
action in the subgoal MDPs as a measure of its Q-value
in the joint (original) MDP. Specifically, we assume that
each goal contributes uniformly and additively to the reward, so the Q-function for an entire set of ground goals
{G(y~1 ), . . . , G(
Pyn~n )} determined by our domain instantiation is just j=1 n1 QG(y~j ) (Ai (~x), s). Action selection
(at run-time) in any ground state is realized by choosing
that action with maximum joint Q-value. Naturally, we do
not want to explicitly create the joint Q-function, but instead use an efficient scoring technique that evaluates potentially useful actions by iterating through the individual
Q-functions as described in Fig. 2. While this additive and
uniform decomposition may not be appropriate for all domains with goal-oriented universal rewards, we have found
it to be highly effective for the two domains examined in
this paper. And while this approach can only currently handle rewards with universal quantifiers, this reflects the form
of many planning problems. Nonetheless, there are potential extensions of this technique for more complex universal rewards, the general question being how to assign credit
among the constituents of such a reward.

7

Optimizations

Following are a few novel additional optimizations that
provided substantial performance enhancements of our
FOALP and FOAPI implementations. First, and most importantly, the style of generating orthogonal basis functions
in Fig. 1 has some very nice computational properties that
we can exploit. In short, when searching for the maximum
partition among n disjoint basis functions, one need only
consider taking 1 of n true partitions (each basis function
has φ and ¬φ) setting the other n − 1 basis functions to
its false partition. Clearly any other setting would result in
an inconsistent state due to the disjointness of the n basis
functions. Consequently, the search for a consistent state
reduces from an exponential complexity of 2n combinations down to a polynomial complexity of n combinations
(trying each true partition of a basis function in turn).
A
Second, one can replace the Bmax
operators in the constraints for FOALP and FOAPI with the much simpler B A
operator that does not introduce the blowup that occurs
A
from enforcing disjointness in the Bmax
operator. Since
we know that we only use the constraints when searching for a max (i.e., during constraint generation [21]), the
max over B A will implicitly enforce the max constraint of
A
Bmax
. While we omit a proof, it is straightforward to show
that the maximal value and therefore the maximally violated constraint that we need during constraint generation
A
is the same whether we use Bmax
or B A .

Third, while first-order simplification techniques are not required to perform FOALP or FOAPI, some simplification
can save a substantial amount of theorem proving time. We
used a simple BDD-based simplification technique as follows: Given a first-order formula, we rearrange and push
quantifiers down into subformulae as far as possible. This
exposes a propositional super-structure (very common in
FOMDP problems) that can be mapped into a BDD. This
BDD structure is useful because it reduces propositional
redundancy in the formula representation by removing duplicate or inconsistent closed first-order formulae that are
repeated frequently due to the naive conjunction of the case
operators (mainly ⊕, , and ⊗).

8

Empirical Results

We applied FOALP and FOAPI to the Box World logistics
and Blocks World probabilistic planning problems from the
ICAPS 2004 IPPC [15]. In the Box World logistics problem, the domain objects consists of trucks, planes, boxes,
and cities. The number of boxes and cities varies in each
problem instance, but there were always 5 trucks and 5
planes. Trucks and planes are restricted to particular routes
between cities in a problem-specific manner. The goal in
Box World is to deliver all boxes to their destination cities,
despite the fact that trucks and planes may stochastically
fail to reach their specified destination. Blocks World is just
a stochastic version of the standard domain where blocks
are moved between the table and other stacks of blocks to
form a goal configuration. In this version, a block may be
dropped while picking it up or placing it on a stack.
We used the Vampire [20] theorem prover and the CPLEX
9.0 LP solver in our FOALP and FOAPI implementations
and applied the basis function generation algorithm given
in Fig. 1 to a FOMDP version of these domains. It is important to note that we generate our solution to the Box
World and Blocks World domains offline. Since each of
these domains has a universally quanitified reward, our offline solution is for a generic instantiation of this reward.
Then at evaluation time when we are given an actual problem instance (i.e., a set of domain objects and initial state
configuration), we decompose the value function for each
ground instantiation of the reward and execute a policy using the approach outlined in Sec. 6. We do not enhance
or otherwise modify our offline solution once given actual
domain information (this is an avenue for future research).
We set an iteration limit of 7 in our offline basis function
generation algorithm and recorded the running times per iteration of FOALP and FOAPI; these are shown in Fig. 3.
There appears to be exponential growth in the running time
as the number of basis functions increases; this reflects the
results of previous work [21]. However, we note that if we
were not using the “orthogonal” basis function generation
technique described in Sec. 5 and associated optimizations

Problem

Offline Solution Time for Each FOALP/FOAPI Basis Gen. Iteration
9000
FOAPI BlocksWorld
FOALP BlocksWorld
FOALP BoxWorld
FOAPI BoxWorld

8000

bx c10 b5
bx c10 b10
bx c10 b15
bw b5
bw b11
bw b15
bw b18
bw b21

Running Time (s)

7000

6000

5000

4000

3000

2000

1000

0

1

2

3

4

5

6

7

Iteration # of Basis Fn Generation Algorithm

Figure 3: FOAPI and FOALP solution times for the Box World
and Blocks World Domains vs. the iteration of basis function
generation.

in Sec. 7, we would not get past iteration 2 of basis function
generation due to the prohibitive amount of time required
by FOALP and FOAPI (> 10 hours). Consequently, we
can conclude that our basis function generation algorithm
and optimizations have substantially increased the number
of basis functions for which FOALP and FOAPI remain viable solution options. In terms of a comparison of the running times of FOALP and FOAPI, it is apparent that each
performs better in different settings. In Box World, FOAPI
takes fewer iterations of constraint generation than FOALP
and thus is slightly faster. In Blocks World, the policies tend
to grow more quickly in size because the Vampire theorem
prover has difficulty refuting inconsistent partitions on account of the use of equality in this FOMDP domain. This
impacts not only the solution time of FOAPI, but also its
performance as we will see next.
We applied the policies generated by the FOALP and
FOAPI versions of our basis function function generation
algorithm to three Box World and five Blocks World problem instances from the ICAPS 2004 IPC. We compared
our planning system to the three other top-performing planners on these domains: G2 is a temporal logic planner with
human-coded control knowledge [8]; P is an RTDP-based
planner [2]; J1 is a human-coded planner, J2 is an inductive policy iteration planner, and J3 is a deterministic replanner [24]. Results for all of these planners are given in
Table 1.
We make four overall observations: (1) FOALP and FOAPI
produce the same basis function weights and therefore the
same policies for the Box World domain. (2) We only used
7 iterations of basis function generation and this effectively
limits the lookahead horizon of our basis functions to 7
steps. It appears that a lookahead of 8 is required to properly plan in the final Box World problem instance and thus
both FOALP and FOAPI failed on this instance.5 (3) Due
5

We could not increase the number of iterations to 8 to test this

G2
438
376
0
495
479
468
352
286

Prob. Planning System
P
J1
J2
J3
184 419 376 425
0
317
0
346
–
129
0
279
494 494 495 494
466 480 480 481
397 469 468
0
–
462
0
0
–
456 455 459

FO–
ALP API
433
433
366
366
0
0
494
490
480
0
470
0
464
0
456
0

Table 1: Cumulative reward of 5 planning systems and the
FOALP and FOAPI (100 run avg.) on the Box World and
Blocks World probabilistic planning problems from the ICAPS
2004 IPPC [15] (– indicates no data). Box World problems
are indicated by a prefix of bx and followed by the number of
cities c and boxes b used in the domain. Blocks World problems are indicated by a prefix of bw and followed by the number of blocks b used in the domain. All domains are available
from http://www.cs.rutgers.edu/˜mlittman/topics/ipc04-pt. See
Section 8 for an explanation of the domains and planners.
to aforementioned problems with the inability of FOAPI to
detect inconsistency of policy partitions in the Blocks World
domain, its performance is severely degraded on these
problem instances in comparison to FOALP. FOALP does
not use a policy representation and thus does not encounter
these problems. (4) It is important to note that in comparing FOALP and FOAPI to the other planners, G2 and J1
used hand-coded control knowledge and J3 was a very efficient search-based deterministic planner that had a significant advantage because the probabilities in these domains
were inconsequential. The only fully autonomous stochastic planners were P and J2, and FOALP performs comparably to both of these planners and outperforms them by a
considerable margin on a number of problem instances.

9

Concluding Remarks

We have introduced a novel algorithm for performing firstorder approximate policy iteration, as well as new basis function generation techniques that allow FOALP and
FOAPI to efficiently exploit their structure, leading to a
substantial increase in the number of basis functions that
these algorithms can handle. Additionally, we have addressed the intractability of solving problems with universal rewards by automatically decomposing the task into independent subgoals that can be solved and then recombined
to determine a policy that facilitates “coordination” among
the subgoals. Taken together, these techniques have enabled us to evaluate FOALP and FOAPI solutions to logistics problems from the ICAPS 2004 Probabilistic Planning Competition. Empirically we have shown that FOALP
performs better than other autonomous stochastic planners
on these problems and outperforms FOAPI when the polhypothesis due to memory constraints. We are currently working
on additional optimizations to remedy this problem.

icy representation requires first-order logic constructs that
pose difficulties for a state-of-the-art theorem prover. Our
approach is competitive on these domains even with planners that exploit (hand-coded) domain-specific knowledge.
One pressing issue for future work is to extend our reward
decomposition techniques to a wider range of universally
quantified formulae. In addition, we note that many domains including the Box World logistics domain covered
in this paper have an underlying topological structure that
is not exploited in current solution algorithms. The ability to directly exploit topological structure in the problem
representation and basis function formulation could potentially help with the limited-horizon lookahead issues that
we experienced on Box World. The ability to exploit additional reward and domain structure will help push fully
lifted and automated first-order solution techniques further
into probabilistic planning domains that previously could
not be handled.

