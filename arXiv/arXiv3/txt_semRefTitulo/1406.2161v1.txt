. The Dynamic Logic for Propositional Assignments (DL-PA) has recently been studied as an alternative to Propositional Dynamic Logic (PDL). In
DL-PA, the abstract atomic programs of PDL are replaced by assignments of
propositional variables to truth values. This makes DL-PA enjoy some interesting
meta-logical properties that PDL does not, such as eliminability of the Kleene
star, compactness and interpolation. We define and analytic tableaux calculus for
DL-PA and show that it matches the known complexity results.
Keywords: Modal Logic; Propositional Dynamic Logic; Dynamic Logic of Propositional Assignments; analytic tableaux.

1 Introduction
Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been
studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL)
[7]. In a series of papers, it was shown that DL-PA is a useful tool to analyse various
kinds of dynamic systems, such as normative systems [10], fusion operators [11], update
and revision operators [9], or the evolution of argumentation frameworks [4]. While, in
PDL, one can write formulas of the form [a]ϕ, meaning “after every possible execution
of the abstract atomic program a, formula ϕ is true”, in DL-PA, one can write formulas
of the form [+p]ϕ, meaning “after assigning the truth value of p to true, formula ϕ is
true”. The atomic program +p is an assignment that maps the propositional variable p
to true. In fact, the atomic programs of DL-PA are sets of such assignments, that are
viewed as partial functions from the set of propositional variables to {⊤, ⊥}. From these
atomic programs, complex programs are built just as in PDL. For example, one can
write in DL-PA the formula [¬p?; +p]p, which means “if p is false then p is true after
its truth value be assigned to true”.
While the models of PDL are transition systems, the models of DL-PA are much
smaller: valuations of classical propositional logic, i.e., nothing but sets of propositional
variables. Due to that, DL-PA enjoys some interesting meta-logical properties that PDL
lacks, such as eliminability of the Kleene star, compactness and interpolation.
The complexity of the satisfiability problem in DL-PA is the same as in PDL: it is
in EXPTIME for the full language and PSPACE complete for the star-free fragment.
EXPTIME membership of the full language is proved by a polynomial embedding
of DL-PA into PDL, and PSPACE membership of the star-free fragment of DL-PA is

proved via NPSPACE membership of its model checking problem, exploiting the fact
that NPSPACE = PSPACE. However, these reductions lead to suboptimal theorem proving methods. Our aim in this paper is to define tableaux theorem proving procedures for
DL-PA that are both direct and more efficient.
The paper is organized as follows. We start by recalling DL-PA (Section 2). Then,
we provide a tableaux method for its star-free fragment (Section 3) and show an algorithm implementing it that works in polynomial space (Section 4). After that, we
extend the tableaux method to the full language of DL-PA (Section 5) and then show
an algorithm implementing it and that works in time exponential (Section 6). Section 7
discusses some issues and concludes the paper.3

2 Dynamic Logic of Propositional Assignments
2.1 Syntax
The vocabulary of DL-PA contains a countable set P of propositional variables. From
this set, we build the set A of propositional assignments, which are the atomic programs
of the language. Each propositional assignment is a non-empty finite partial function
from P to {⊥, ⊤}.4
The language L of DL-PA is the the set of formulas ϕ defined by the BNF:
ϕ F p | ¬ϕ | ϕ ∧ ϕ | [π]ϕ
π F α | π; π | π ∪ π | π∗ | ϕ?
where p ranges over P and α ranges over A.
To ease notation and readability of programs, we write +p for (p, ⊤) and −p for
(p, ⊥). Moreover, we sometimes “forget” some parentheses and curly braces when writing propositional assignments. As a result, the formula [{(p, ⊤), (q, ⊥)}]ϕ is rather noted
[+p, −q]ϕ. In some places, we use the expression ±p to talk economically about +p and
−p at the same time.
The complex programs of DL-PA are constructed as in Dynamic Propositional
Logic (PDL) [8]. As well as in PDL, formulas of the form [π]ϕ are read “after every
possible execution of π, ϕ is true”.
We also use the common abbreviations for the connectives ⊤, ⊥, ∨, → and ↔. The
formula hπiϕ abbreviates ¬[π]¬ϕ. The star-free fragment of L is the fragment without
the Kleene star operator ∗ and is noted L−∗ .
The length of a formula or a program, given by the function len, is the number of
atoms and connectives in the formula or the program. Table 1 defines it formally.
The closure of ϕ is the set cl(ϕ) defined in Table 2. This is almost the same as the
Fisher-Ladner closure [5], which is used to show decidability and complexity results
for PDL. But since the atomic programs of DL-PA are sets of assignments, there is a
difference here in the definition of cl ([α]ϕ). It takes into account the assignments by
adding the domain of the atomic program α.
3
4

Proofs of the important theorems are in the appendix.
We note that the original language in [2] is slightly more restrictive: α only assigns a single
propositional variable. But, as shown in this paper, it does not change the known decidability
and complexity results.

2

len(α) = | dom(α)|

len(p) = 1

len(π1 ; π2 ) = 1 + len(π1 ) + len(π2 )

len(¬ϕ) = 1 + len(ϕ)

len(π1 ∪ π2 ) = 1 + len(π1 ) + len(π2 )

len(ϕ1 ∧ ϕ2 ) = 1 + len(ϕ1 ) + len(ϕ2 )

len(π∗ ) = 1 + len(π)

len([π]ϕ) = 1 + len(π) + len(ϕ)

len(ϕ?) = 1 + len(ϕ)
Table 1. Length

cl ([α]ϕ) = {[α]ϕ} ∪ dom(α)

cl(p) = {p}


cl ([π1 ; π2 ]ϕ) = {[π1 ; π2 ]ϕ} ∪ cl ([π1 ][π2 ]ϕ)

cl(¬ϕ) = {¬ϕ} ∪ cl(ϕ)
cl(ϕ1 ∧ ϕ2 ) = {ϕ1 ∧ ϕ2 } ∪ cl(ϕ1 ) ∪ cl(ϕ2 )

cl ([π1 ∪ π2 ]ϕ) = {[π1 ∪ π2 ]ϕ} ∪ cl ([π1 ]ϕ) ∪ cl ([π2 ]ϕ)
cl ([π∗ ]ϕ) = {[π∗ ]ϕ} ∪ cl ([π][π∗ ]ϕ)



cl([π]ϕ) = cl ([π]ϕ) ∪ cl(ϕ)

cl ([ϕ1 ?]ϕ2 ) = {[ϕ1 ?]ϕ2 } ∪ cl(ϕ1 )
Table 2. Closure

The extended closure of ϕ is the set cl+ (ϕ) containing cl(ϕ) and the negations of its
formulas, i.e., cl+ (ϕ) = cl(ϕ) ∪ {¬ψ : ψ ∈ cl(ϕ)}. To ease notation, we sometimes use Pϕ
to denote the set of propositional variables occurring in ϕ, i.e. Pϕ = P ∩ cl(ϕ).
The lemma below can be proved with an easy induction on the length of formulas
and programs.
Lemma 1.
1. card(cl ([π]ϕ)) ≤ len([π]ϕ)
2. card(cl(ϕ)) ≤ len(ϕ).
3. card(cl+ (ϕ)) ≤ 2 len(ϕ).
Intuitively, the set of execution traces of π is the set exe(π) of sequences of assignments that corresponds to all possible executions of program π. The set exe(ϕ) corresponds to all possible executions of all programs in ϕ. These are defined by a mutual
recursion, as displayed in Table 3. We use the symbol ‘()’ to denote the empty sequence.
The length of execution traces, also given by the function len, is just the number of
atomic programs in it. That is: len(()) = 0, len(α) = 1 and len(σα) = len(σ) + len(α).
The lemma below can also be proved with an easy induction on the length of programs and formulas:
Lemma 2.
1. If π does not contain the Kleene star then len(σ) ≤ len(π), for all σ ∈ exe(π).
2. If ϕ ∈ L−∗ then len(σ) ≤ len(ϕ), for all σ ∈ exe(ϕ).
Note, however, that each σ ∈ exe(π∗ ) is infinite.
3

exe(α) = {α}

exe(p) = {()}
exe(¬ϕ) = exe(ϕ)
exe(ϕ ∧ ψ) = exe(ϕ) ∪ exe(ψ)
exe([π]ϕ) = exe(π) ∪ exe(ϕ)

exe(π1 ; π2 ) = {σ1 σ2 : σ1 ∈ exe(π1 ), σ2 ∈ exe(π2 )}
exe(π1 ∪ π2 ) = exe(π1 ) ∪ exe(π2 )
[
{σ1 . . . σn : σ1 , . . . , σn ∈ exe(π)}
exe(π∗ ) =
n∈N0

exe(ϕ?) = exe(ϕ)
Table 3. Execution traces

2.2 Semantics
A DL-PA model is a set V ⊆ P of propositional variables. When p ∈ V then p is true,
and when p < V then p is false.
The interpretation of an assignment α is in terms of a model update. The update of
a model V by an assignment α is the new model V α such that:
V α = {p : V |= α(p)}
where we suppose that when p is not in the domain of α then α(p) equals p. In particular, for the assignment +p we have V +p = V ∪ {p}. Given a sequence of assignments
α1 . . . αn , for the sake of readability, we sometimes write V α1 ···αn instead of (· · · (V α1 ) · · · )αn .
Formulas ϕ are interpreted as sets of models ||ϕ||, while programs π are interpreted
by means of a (unique) relation between valuations ||π||. Just as in PDL, the formal
definition is by a mutual recursion. It is given in Table 4.

||α|| = {hV, V ′ i : V ′ = V α }

||p|| = {V : p ∈ V}
P

||¬ϕ|| = 2 \ ||ϕ||

||π1 ; π2 || = ||π1 || ◦ ||π2 ||

||ϕ ∧ ψ|| = ||ϕ|| ∩ ||ψ||

||π1 ∪ π2 || = ||π1 || ∪ ||π2 ||
[
(||π||)n
||π∗ || =

||[π]ϕ|| = {V : if hV, V ′ i ∈ ||π|| then V ′ ∈ ||ϕ||}

n∈N0

||ϕ?|| = {hV, Vi : V ∈ ||ϕ||}
Table 4. Interpretation of the DL-PA connectives

As usual, we also write V |= ϕ to mean that V ∈ ||ϕ||. Moreover, given a formula ϕ,
we say that ϕ is DL-PA valid (noted |= ϕ) if and only if ||ϕ|| = 2P , and we say that ϕ is
DL-PA satisfiable if and only if ||ϕ|| , ∅.
For example, the formulas [+p]⊤, [+p]ϕ ↔ ¬[+p]¬ϕ, [π]⊤, [+p]p and [−p]¬p are
all DL-PA valid.
4

2.3 Existing Proof Methods
We now recall the existing methods for both model checking and satisfiability checking in DL-PA. They either use a non-elementary reduction to propositional logic or
a quadratic embedding into PDL. We then provide a linear reduction of satisfiability
checking to model checking. This justifies our focus on a tableaux method for model
checking in the rest of the paper. But first, let us recall some valid principles in DL-PA.
Proposition 1 ([10]). The following principles are valid in DL-PA:
1.
2.
3.
4.
5.
6.
7.
8.

[α]p ↔ α(p)
[ψ?]ϕ ↔ (ψ → ϕ)
[π]¬ϕ ↔ ¬[π]ϕ
[π](ϕ ∧ ψ) ↔ ([π]ϕ ∧ [π]ψ)
[π1 ; π2 ]ϕ ↔ [π1 ][π2 ]ϕ
[π1 ∪ π2 ]ϕ ↔ ([π1 ]ϕ ∧ [π2 ]ϕ)
[π∗ ]ϕ ↔ (ϕ ∧ [π][π∗]ϕ)
From ψ → (ϕ ∧ [π∗ ]ψ) infer ψ → [π∗ ]ϕ

It follows from Proposition 1.1–1.6 plus the rule of substitution of valid equivalences that the star-free fragment of DL-PA is reducible to propositional logic. This
however fails to provide an efficient theorem proving method because the reduced formula might be exponentially longer than the original formula. In [2], it is also shown
that the Kleene star can be eliminated in DL-PA, i.e., there is an algorithm that translates every formula in L to an equivalent formula in L−∗ . Such translation, however,
also leads to much longer formulas. In fact, this is a non-elementary reduction because
it starts from the innermost Kleene star operator.
Satisfiability checking in DL-PA is shown to be in EXPTIME in [2]. The proof is
given via a translation to satisfiability checking in PDL. For every DL-PA formula ϕ, the
translation tr returns a PDL formula which is obtained by just replacing each assignment
±p by an abstract PDL program a±p . To guarantee that the abstract programs behave
the same way as the original assignment, the following set of formulas Γϕ is also used:
Γϕ = {[a+p ]p : p ∈ Pϕ } ∪
{[a−p ]¬p : p ∈ Pϕ } ∪
{ha±p i⊤ : ±p ∈ Pϕ } ∪
{q → [a±p ]q : p, q ∈ Pϕ , p , q} ∪
{¬q → [a±p ]¬q : p, q ∈ Pϕ , p , q}
S
Proposition 2 ([2]). Let Uϕ be the PDL program ( p∈Pϕ (a+p ∪a−p ))∗ . For every DL-PA
formula ϕ, ϕ is DL-PA satisfiable if and only if
^ 
tr(ϕ) ∧ [Uϕ ]
Γϕ
is PDL satisfiable.
5

Note that, even though this reduction is polynomial, a quadratically longer formula
is produced. Precisely, the size of Γϕ is bounded by 5 len(ϕ)2 . Moreover, if we consider
the star-free fragment of DL-PA, this transformation is sub-optimal, because of the
Kleene star operator in Uϕ .5
If follows from the next result that satisfiability checking in DL-PA can be linearly
reduced to model checking in DL-PA.
Proposition 3. Let a formula ϕ ∈ L be given. Let Pϕ = {p1 , . . . , pn }. and let Mϕ be the
DL-PA program (+p1 ∪ −p1 ); . . . ; (+pn ∪ −pn ). Formula ϕ is satisfiable if and only if
V |= hMϕ iϕ for any model V.
Proof. It suffices to see that the interpretation of the program Mϕ relates all possible
valuations in the vocabulary of ϕ, while leaving the other variables unchanged.
⊔
⊓
The operation [Mϕ ] works as a master modality and thus hMϕ i works as its dual.
Because it does not contain the Kleene star operator, the length of hMϕ iϕ is bounded by
3 len(ϕ). Also note that, in particular, ϕ is satisfiable if and only if V = ∅ satisfies hMϕ iϕ.
This means that the input (V, hMϕ iϕ) for the model checking problem is also linear
on the length of ϕ. Therefore, in order to perform satisfiability checking in DL-PA,
one could take advantage of an efficient algorithm for model checking in DL-PA. This
motivates the tableaux methods presented in the next section.
Before concluding this section, let us recall that, in DL-PA, model checking has the
same computational complexity as satisfiability checking. This follows from Proposition 3 above and Proposition 4 below.
Proposition 4 ([2]). For every valuation V and formula ϕ, V ∈ ||ϕ|| if and only if the
formula

 


 ^   ^



¬p
p ∧ 
ϕ ∧ 
p∈Pϕ ∩V

p∈Pϕ \V

is DL-PA satisfiable.

3 A Tableaux Method for Star-Free DL-PA
In this section, we define a model checking procedure for the star-free fragment of
DL-PA using analytic tableaux. We start with some useful definitions.
A labeled formula is a pair λ = hσ, ϕi, where σ = α1 . . . αn is a (possibly empty) sequence of propositional assignments and ϕ ∈ L. A branch is a set of labelled formulas.
Definition 1 (Tableau). Let V ⊆ P and ϕ0 ∈ L−∗ . The initial branch for (V, ϕ0 ) is the
the set b0 = {h(), pi : p ∈ Pϕ0 ∩ V} ∪ {h(), ¬pi : p ∈ Pϕ0 \ V} ∪ {h(), ϕ0 i}. A tableau for
(V, ϕ0 ) is a set of branches T that satisfies one of the following two conditions:
1. T = {b0 }, which is called the initial tableau for (V, ϕ0 ).
5

For the star-free fragment, a transformation without the Kleene star operator is also possible.
S
In this case, the program p∈Pϕ (a+p ∪ a−p ) must be iterated up to len(ϕ), but this leads to an
even longer formula.

6

2. T = (T ′ \ {b}) ∪ B, where T ′ is a tableau for (V, ϕ0 ) containing the branch b and B
is a set of k branches {b ∪ b1 , . . . , b ∪ bk } generated by one of the following tableau
rules below:6
(R¬) hσ, ¬¬ϕi ∈ b implies k = 1 and b1 = {hσ, ϕi}.
(R∧) hσ, ϕ ∧ ψi ∈ b implies k = 1 and b1 = {hσ, ϕi, hσ, ψi}.
(R∨) hσ, ¬(ϕ ∧ ψ)i ∈ b implies k = 2, b1 = {hσ, ¬ϕi} and b2 = {hσ, ¬ψi}.
(R[α]) hσ, [α]ϕi ∈ b implies k = 1 and
b1 = {hσα, ϕi} ∪ {hσα, pi : α(p) = ⊤} ∪ {hσα, ¬pi : α(p) = ⊥}.
(Rhαi) hσ, ¬[α]ϕi ∈ b implies k = 1 and
b1 = {hσα, ¬ϕi} ∪ {hσα, pi : α(p) = ⊤} ∪ {hσα, ¬pi : α(p) = ⊥}.
(R[?]) hσ, [ψ?]ϕi ∈ b implies k = 2, b1 = {hσ, ¬ψi} and b2 = {hσ, ϕi}.
(Rh?i) hσ, ¬[ψ?]ϕi ∈ b implies k = 1 and b1 = {hσ, ψi, hσ, ¬ϕi}.
(R[;]) hσ, [π1 ; π2 ]ϕi ∈ b implies k = 1 and b1 = {hσ, [π1 ][π2 ]ϕi}.
(Rh;i) hσ, ¬[π1 ; π2 ]ϕi ∈ b implies k = 1 and b1 = {hσ, ¬[π1 ][π2 ]ϕi}.
(R[∪]) hσ, [π1 ∪ π2 ]ϕi implies k = 1 and b1 = {hσ, [π1 ]ϕi, hσ, [π2 ]ϕi}.
(Rh∪i) hσ, ¬[π1 ∪π2 ]ϕi ∈ b implies k = 2, b1 = {hσ, ¬[π1 ]ϕi} and b2 = {hσ, ¬[π2 ]ϕi}.
(RP1) {hσ, pi, hσα, ψi} ⊆ b for some ψ and p < dom(α) implies k = 1 and
b1 = {hσα, pi}.
(RP2) {hσ, ¬pi, hσα, ψi} ⊆ b for some ψ and p < dom(α) implies k = 1 and
b1 = {hσα, ¬pi}.
The initial tableau corresponds to the input of the problem in the tableau. Rules
R¬, R∧ and R∨ are the standard tableaux rules for Boolean connectives. RP1 and RP2
(propagation rules) propagate literals whose the truth value is not changed by assignments: if the model updated by σ satisfies p and α does not change the truth value of
p then the model updated by σα also satisfies p. The other rules just reflect the semantic definition of the corresponding programs. For instance, for the rule R[α], if the
model updated by the sequence of assignments σ satisfies [α]ϕ then the model updated
by the sequence σα satisfies ϕ. Note that they also correspond to the validities 1–6 in
Proposition 1.
A branch b is blatantly inconsistent if and only if b contains both hσ, ϕi and hσ, ¬ϕi,
for some σ and ϕ. A branch b is closed if and only if it is blatantly inconsistent. A
tableau is closed if and only if all its branches are closed. A tableau is open if and only
if it is not closed.
The idea is that, if there is a closed tableau for the input (V, ϕ0 ) then V 6|= ϕ0 . On the
other hand, if there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
Example 1. Table 5 shows how the method can be used to prove that the model V =
{p, q} does not satisfy the formula ϕ0 = ¬[+p∪−p]q. In the table, lines 1–3 consist of the
initial tableau for the input (V, ϕ0 ). Rule applications are indicated between parentheses
on the left of each line. Line 4 is generated by the application of R[∪] to line 3. This
generates two different branches. The rule applications continue until both branches are
closed.
6

Some of these rules are also presented in the more traditional numerator-denominator form in
Table 10 of the Appendix.

7

4.
5.
6.
7.
8.

1. () p
2. () q
3. () ¬[+p ∪ −p]q
()
¬[+p]q (Rh∪i: 3) 4. ()
+p p
(Rhαi: 4) 5. −p
+p ¬q
(Rhαi: 4) 6. −p
+p q
(RP1: 2, 5) 7. +p
(closed) (6, 7)
8.

¬[−p]q
¬p
¬q
q
(closed)

(Rh∪i: 3)
(Rhαi: 4)
(Rhαi: 4)
(RP1: 2, 5)
(6, 7)

Table 5. Tableau for V = {p, q} and ϕ0 = ¬[+p ∪ −p]q

Example 2. Table 6 shows how the method can be used to prove that the model V = ∅
satisfy the formula ϕ0 = [¬p?; +p]p. Note that RP2 is not applicable to the labelled
formulas in lines 1 and 5 because p ∈ dom(+p). Thus, the branch on the right remains
open, which means that V |= ϕ0 .

() ¬p
() [¬p?; +p]p
() [¬p?][+p]p (R[;]: 2)
() ¬¬p
(R[?]: 3) 4. ()
[+p]p
() p
(R¬: 4) 5. +p p
(closed) (1, 5)
(open)
1.
2.
3.

4.
5.

(R[?]: 3)
(R[α]: 4)

Table 6. Tableau for V = ∅ and ϕ0 = [¬p?; +p]p

In the sequel, we show the soundness of the method. The idea is to show that, if
V |= ϕ0 , then successive rule applications can never close the tableau. But first, a useful
definition and a lemma are presented.
Definition 2 (Consistent Branch). A branch b is consistent if and only if V σ |= ϕ for
every hσ, ϕi ∈ b.
Lemma 3 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Theorem 1 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
We now address the completeness of the method. The idea is to show that, if the
tableau remains open after all possible applications of the tableau rules, then V |= ϕ0 .
But first, some useful definitions are presented.
Definition 3 (Witness). A witness to rule ρ in branch b is a labelled formula hσ, ϕi ∈ b
allowing the application of ρ.
8

For example, h(), ¬¬pi is a witness to R¬, and hβ, ¬[+p, −q]pi is a witness to Rhαi.
Moreover, the formula hσ, pi is a witness to RP1 in b if there is a formula hσα, ψi ∈ b
and p < dom(α).
Definition 4 (Saturated Tableau). The label σ in the branch b is saturated under the
tableau rule ρ if and only if for each witness hσ, ϕi to ρ in b, b contains some bi generated by the application of ρ to b. The branch b is saturated under the tableau rule
ρ if and only if all its labels are saturated. A branch is saturated if and only if it is
saturated under all tableau rules. A tableau is saturated if and only if all its branches
are saturated.
Theorem 2 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .

4 An Optimal Procedure for Star-Free DL-PA
In this section we define an algorithm to check whether V |= ϕ0 , for ϕ0 ∈ L−∗ . Such an
algorithm is displayed in Table 7. It implements the tableaux method using the recursive
function mcTableau. It takes as argument a tableau branch b and returns whether b is
consistent. When called with the initial tableau for (V, ϕ0 ) it returns whether V |= ϕ0 .
The execution of mcTableau explores in a depth-first manner a tree whose nodes are
tableau branches and each child is generated by the application of a tableau rule to its
parent.
The rules are applied in a specific order and, after the application of a rule, the
witness is marked ‘non-applicable’, thus avoiding an infinite loop. Lines 8–21 perform
what is called ‘local saturation’. That is, only rules that do not create labelled formulas
with different labels than that of the witness are applied. Its first part (lines 8–11) applies
rules that do not create more than one branch in the tableau. Its second part (lines 12–
21) apples rules that create more than one branch in the tableau. At the end of the
local saturation, only witnesses to rules R[α], Rhαi remain. Note that no new label is
created in the local saturation part, which means that there can be no witnesses to rules
RP1 and RP2. Then, in lines 22–38 the algorithm performs what is called ‘successor
creation’. First (line 22), it tests whether there is a successor to be created, i.e., if there
is a witness λ to R[α] or Rhαi. It creates the successor (line 23) and then marks the
witness as ‘non-applicable’ (line 24). After that (lines 25–34), it propagates the suitable
formulas to the successor, as follows: assume that the witness is λ = hσ, [α]ψi. Then,
for every labelled formula hσ, [α]ψ′ i and hσ, hαiψ′ i there must be a labelled formula
hσα, ψ′ i in the successor. This is done in lines 25–29. And also, every labelled formula
hσ, pi (resp. hσ, ¬pi) must be propagated, i.e., there must be a labelled formula hσα, pi
(resp. hσα, ¬pi) in the successor b1 . This is done in lines 30–34. The last part (lines 35–
37) makes a recursive call to mcTableau with the b1 . The current branch is considered
satisfiable if all recursive calls return true.
This algorithm has two important features. First, its successor creation part guarantees that each time mcTableau is called with branch b as argument, all the labelled
formulas in b have the same label. Second, the first feature implies that the list of successors created during successive recursive calls of mcTableau corresponds to one execution trace from input formula ϕ0 . These are the key arguments used in the proof of
complexity result below.
9

1: input: (V,
 ϕ0 )


true, if b is satisfiable
2: output: 

false, otherwise
3: begin
4:
mcTableau(b0 )
5: end
6: function mcTableau(b)
7: begin
8:
if b contains an applicable witness λ to a rule ρ ∈ {R¬, R∧, Rh?i, R[;], Rh;i, R[∪]} then
9:
b1 ← the branch generated by the application of ρ to b using λ as witness
10:
mark λ as ‘non-applicable’
11:
return mcTableau(b ∪ b1 )
12:
else if b contains an applicable witness λ to a rule ρ ∈ {R∨, R[?], Rh∪i, RC} then
13:
B ← the set of branches {b1 , . . . , bn } generated by the application of ρ to b using λ as witness
14:
mark λ as ‘non-applicable’
15:
for each bi ∈ B do
16:
if mcTableau(b ∪ bi ) = true then
17:
return true
18:
end if
19:
end for
20:
return false
21:
end if
22:
while there is an atomic program α such that b contains an applicable witness
λ = hσ, ϕi to rule ρ ∈ {R[α], Rhαi}, where ϕ = [α]ψ or ϕ = hαiψ do
23:
b1 ← the branch generated by the application of ρ to b using λ as witness
24:
mark λ as ‘non-applicable’
25:
while b contains an applicable witness λ′ = hσ, ϕ′ i to rule ρ ∈ {R[α], Rhαi},
where ϕ′ = [α]ψ′ or ϕ′ = hαiψ′ do
26:
b′1 ← the branch generated by the application of ρ to b using λ′ as witness
27:
mark λ′ as ‘non-applicable’
28:
b1 ← b1 ∪ b′1
29:
end while
30:
while b ∪ b1 contains an applicable witness λ′′ to rule ρ ∈ {RP1 , RP2 } do
31:
b′1 ← the branch generated by the application of ρ to b using λ′′ as witness
32:
mark λ′′ as ‘non-applicable’
33:
b1 ← b1 ∪ b′1
34:
end while
35:
if mcTableau(b1 ) = false then
36:
return false
37:
end if
38:
end while
39:
return true
40: end
Table 7. Algorithm implementing the tableaux method for star-free DL-PA

10

Theorem 3 (Termination). The algorithm in Table 7 halts for every input (V, ϕ0 ).
Theorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is
a polynomial function of the length of the input (V, ϕ0 ).
Therefore, the algorithm in Table 7 works in space polynomial in the length of the
input. This is an optimal algorithm, given that the satisfiability problem in star-free
DL-PA is PSPACE-complete [10].

5 A Tableaux Method for Full DL-PA
In this section, we define an extension of the tableaux method that also takes into account the Kleene star operator.
Definition 5 (Tableau). Let (V, ϕ0 ) be the input under concern (thus, the initial tableau
is the same as in Definition 1). The tableau rules for full DL-PA are those of Definition 1
plus the following ones:
(R[∗]) hσ, [π∗ ]ϕi ∈ b implies k = 1 and b1 = {hσ, ϕi, hσ, [π][π∗ ]ϕi}.
(Rh∗i) hσ, ¬[π∗ ]ϕi ∈ b implies k = 2, b1 = {hσ, ¬ϕi} and b2 = {hσ, ϕi, hσ, ¬[π][π∗ ]ϕi}.
The two rules above reflect the fix point property of Proposition 1.7. For instance,
if the model V σ |= [π∗ ]ϕ then V σ |= ϕ and also V σ |= [π][π∗ ]ϕ.
Definition 6 (Fulfillment). An eventuality hσ, ¬[π∗ ]ϕi) is fulfilled in a tableau branch
b if and only if there is a (possibly empty) execution trace σ′ ∈ exe(π) such that
hσσ′ , ¬ϕi ∈ b.
Definition 7 (Closed Branch). A branch b is closed if and only if (1) b is blatantly
inconsistent or (2) b is saturated and contains an unfulfilled eventuality.
Example 3. Table 8 shows how the method can be used to prove that model V = {p, q}
does not satisfy the formula ϕ0 = ¬[(+p∪−p)∗ ]q. The leftmost branch is closed because
it is blatantly inconsistent. In the branch of the middle, the same pattern will be repeated
indefinitely. Thus, it is an infinite brunch, but it is saturated. Since the eventuality in line
3 is not fulfilled, it is also closed. The right-most branch is analogous to the one in the
middle.
If the input formula contains a sub-formula of the form ¬[π∗ ]ϕ, the method invariably creates tableaux with infinite branches that repeat the same pattern over and over
again, as in Example 3. The repetition can be detected and it is possible to provide a
terminating algorithm. This is presented in Section 6. Here, we show the correctness of
the method presented so far.
Lemma 4 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Theorem 5 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
Theorem 6 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
11

1.
2.
3.
4.
5.

()

¬q
(blat. inc.)

(Rh∗i: 3)
(2, 4)

5.
6.
7.
8.

() p
() q
() ¬[(+p ∪ −p)∗ ]q
4. () ¬[+p ∪ −p][(+p ∪ −p)∗ ]q (Rh∗i: 3)
..
.
()
¬[+p][(+p ∪ −p)∗ ]q (Rh∪i: 3)
(closed)
+p p
(Rhαi: 5)
+p ¬[(+p ∪ −p)∗ ]q
(Rhαi: 5)
+p q
(RP1: 2, 6)
..
.
(closed)

Table 8. Tableau for V = {p, q} and ϕ0 = ¬[(+p ∪ −p)∗ ]q

6 An EXPTIME Procedure for Full DL-PA
In this section, we define a procedure to model check formulas in L. As before, we
define an algorithm. Here, it must detect the aforementioned repetitions of the applications of Rh∗i in the tableau. This is done by performing equality tests. A label σ1 is said
to be equal to a label σ2 if and only if the set of formulas labelled by σ1 and σ2 are the
same. More formally we have:
Definition 8 (Equality). Let σ1 and σ2 be two labels in the tableau T . Label σ1 is
equal to label σ2 (noted σ1 = σ2 ) if and only if there are two branches b1 , b2 ∈ T such
that {ϕ : hσ1 , ϕi ∈ b1 } = {ϕ : hσ2 , ϕi ∈ b2 }.
An equality test between labels can prevent the tableau to enter in an infinite loop.
Then one can try to provide an algorithm that is similar to the one in Section 4, by
first adding rules R[∗] and Rh∗i in their suitable places and the equality test just before
the exploration of a new successor. Such an algorithm works, but is not optimal. For
instance, the application of the method to the formula [(+p1 ∪ −p1 ∪ · · · ∪ +pn ∪ −pn )∗ ]p
creates 2n different successors from a single tableau branch. Then such a method may
len(ϕ )
explore a tree whose the number of nodes is bounded by 22 0 . However, satisfiability
in DL-PA is proven to be in EXPTIME.
A different technique than that in Section 4 must be employed in order to obtain a
more efficient method for full DL-PA. Such a technique is implemented in the algorithm
of Table 9. It is somewhat similar to the algorithm in Section 4, but there are some
important differences. The most important ones are the addition of the equality test
in lines 17–19 and the fact that this algorithm now maintains the entire tableau T in
memory. It does not uses a recursive function anymore, for it now uses the tableau T as
the search tree. Once the initial tableau for (V, ϕ0 ) is created in line 4, it enters a loop
that finishes when T is closed or saturated (recall that a branch is also considered to
be closed if it is saturated and contains an unfulfilled eventuality). As before, there is a
‘local saturation’ part (lines 9–16) and a ‘successor creation’ part (lines 20–33). In lines
36–40, the algorithm tests whether T is still open to return the right answer.
12

1: input: (V,
 ϕ0 )


true, if ϕ0 is satisfiable
2: output: 

false, otherwise
3: begin
4:
T ← {b0 }
5:
while T is open and unsaturated do
6:
pick an open and unsaturated branch b ∈ T
7:
while b is open and unsaturated do
8:
pick an open unsaturated label σ of b
9:
if λ = hσ, ϕi ∈ b is an applicable witness to a rule ρ ∈ {R¬, R∧, Rh?i, R[;], Rh;i, R[∪], R[∗]} then
10:
b1 ← the branch generated by the application of ρ to b using λ as witness
11:
mark λ as ‘non-applicable’
12:
T ← (T \ {b}) ∪ {b ∪ b1 }
13:
else if λ = hσ, ϕi ∈ b is an applicable witness to a rule ρ ∈ {R∨, R[?], Rh∪i, Rh∗i, RC} then
14:
{b1 , b2 } ← the branches generated by the application of ρ to b using λ as witness
15:
mark λ as ‘non-applicable’
16:
T ← (T \ {b}) ∪ {b ∪ b1 , b ∪ b2 }
17:
else if there is a label σ′ in T such that σ = σ′ then
18:
mark all formulas in b labelled by σ as ‘non-applicable’
19:
if σ′ is closed then close branch b end if
20:
else if there is an atomic program α such that b contains an applicable witness
λ = hσ, ϕi to rule ρ ∈ {R[α], Rhαi}, where ϕ = [α]ψ or ϕ = hαiψ do
21:
b1 ← the branch generated by the application of ρ to b using λ as witness
22:
mark λ as ‘non-applicable’
23:
while b contains an applicable witness λ′ = hσ, ϕ′ i to rule ρ ∈ {R[α], Rhαi},
where ϕ′ = [α]ψ′ or ϕ′ = hαiψ′ do
24:
b′1 ← the branch generated by the application of ρ to b using λ′ as witness
25:
mark λ′ as ‘non-applicable’
26:
b1 ← b1 ∪ b′1
27:
end while
28:
while b ∪ b1 contains an applicable witness λ′′ to rule ρ ∈ {RP1 , RP2 } do
29:
b′1 ← the branch generated by the application of ρ to b using λ′′ as witness
30:
mark λ′′ as ‘non-applicable’
31:
b1 ← b1 ∪ b′1
32:
end while
33:
T ← (T \ {b}) ∪ {b ∪ b1 }
34:
end if
35:
end while
36:
end while
37:
if T is open then
38:
return true
39:
else
40:
return false
41:
end if
42: end
Table 9. Algorithm implementing the tableaux method for L

13

Theorem 7 (Termination). The algorithm in Table 9 halts for every input (V, ϕ0 ).
Theorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an
exponential function of the length of the input (V, ϕ0 ).
Thus, the algorithm in Table 9 works in time exponential on len(ϕ0 ). This is as
expected, given that the model checking problem in full DL-PA is in EXPTIME [10].

7 Discussion and Conclusion
In this paper, we have defined a linear reduction of satisfiability checking into model
checking in DL-PA. We also define analytic tableaux methods for model checking formulas in the star-free fragment and in full DL-PA. The complexity of these methods
match the complexity class of their respective problems. In the sequel, we compare
such methods to similar approaches and discuss possible improvements and extensions.
Comparisons. The methods presented in this paper have been inspired by others already proposed in the literature. For instance, De Giacomo and Massacci [3] (see also
[12]) inspired the technique for the Kleene star. As already mentioned, the naive strategy would generate tableau branches with size exponential in the length of the input
formula. The idea of keeping the tree in memory and perform equality tests comes from
that work.
Assignments of Propositional Variables to Formulas. DL-PA can be extended with assignments α to formulas in L, instead of the simpler {⊤, ⊥}. The corresponding tableau
rule R[α] would be as follows:
σ : ψ1
σ : ψ2
..
.

σ : [α]ϕ
σ : ¬ψ1
σ : ψ2
..
.

σ : ¬ψ1
σ : ¬ψ2
..
.

σ : ψn
σα : p1
σα : p2
..
.

σα : ψn
σα : ¬p1 . . .
σα : p2
..
.

σ : ¬ψn
σα : ¬p1
σα : ¬p2
..
.

σα : pn σα : pn
σα : ϕ σα : ϕ

σα : ¬pn
σα : ϕ

where we assume that the domain of α is {p1 , . . . , pn } and let α(pi ) = ψi .
In spite of the apparent complexity of this tableau rule, we believe that the complexity of the method is not affected in the star-free fragment. For the full language, we
have to include a cut rule that ranges over all sub-formulas of the input formula ϕ0 . The
reason is to permit the equality test to work also with all formulas ψi that are included
in the tableau when the new rule R[α] is applied. Again, we believe that the complexity
remains the same.
14

Other PDL Connectives. The integration of converse, complement, intersection and
other PDL program connectives is also on our agenda. For instance, we believe that we
can apply techniques similar to the ones in [13,6,1] for the converse. In this case though,
it is not clear whether complexity (or even decidability) results remain the same. This
is subject of future work.

