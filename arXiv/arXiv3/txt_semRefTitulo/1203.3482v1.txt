
Computing the probability of a formula given
the probabilities or weights associated with other
formulas is a natural extension of logical inference to the probabilistic setting. Surprisingly,
this problem has received little attention in the literature to date, particularly considering that it includes many standard inference problems as special cases. In this paper, we propose two algorithms for this problem: formula decomposition
and conditioning, which is an exact method, and
formula importance sampling, which is an approximate method. The latter is, to our knowledge, the first application of model counting to
approximate probabilistic inference. Unlike conventional variable-based algorithms, our algorithms work in the dual realm of logical formulas. Theoretically, we show that our algorithms
can greatly improve efficiency by exploiting the
structural information in the formulas. Empirically, we show that they are indeed quite powerful, often achieving substantial performance
gains over state-of-the-art schemes.

1 Introduction
The standard task in the field of automated reasoning is to
determine whether a set of logical formulas (the knowledge
base KB) entails a query formula Q. (The formulas could
be propositional or first-order; in this paper we focus on
the propositional case.) Logic’s lack of a representation for
uncertainty severely hinders its ability to model real applications, and thus many methods for adding probability to it
have been proposed. One of the earliest is Nilsson’s probabilistic logic (Nilsson, 1986), which attaches probabilities
to the formulas in the KB and uses these to compute the
probability of the query formula. One problem with this
approach is that the formula probabilities may be inconsistent, yielding no solution, but consistency can be verified

and enforced (Nilsson, 1986). Another problem is that in
general a set of formula probabilities does not completely
specify a distribution, but this is naturally solved by assuming the maximum entropy distribution consistent with the
specified probabilities (Nilsson, 1986; Pietra et al., 1997).
A more serious problem is the lack of efficient inference
procedures for probabilistic logic. This contrasts with the
large literature on inference for graphical models, which
always specify unique and consistent distributions (Pearl,
1988). However, the representational flexibility and compactness of logic is highly desirable, particularly for modeling complex domains. This issue has gained prominence in
the field of statistical relational learning (SRL) (Getoor and
Taskar, 2007), which seeks to learn models with both logical and probabilistic aspects. For example, Markov logic
represents knowledge as a set of weighted formulas, which
define a log-linear model (Domingos and Lowd, 2009).
Formulas with probabilities with the maximum entropy assumption and weighted formulas are equivalent; the problem of converting the former to the latter is equivalent to
the problem of learning the maximum likelihood weights
(Pietra et al., 1997). In this paper we assume weighted formulas, but our algorithms are applicable to formulas with
probabilities by first performing this conversion.
Another reason to seek efficient inference procedures for
probabilistic logic is that inference in graphical models can
be reduced to it (Park, 2002). Standard inference schemes
for graphical models such as junction trees (Lauritzen
and Spiegelhalter, 1988) and bucket elimination (Dechter,
1999) have complexity exponential in the treewidth of the
model, making them impractical for complex domains.
However, treewidth can be overcome by exploiting structural properties like determinism (Chavira and Darwiche,
2008) and context-specific independence (Boutilier, 1996).
Several highly efficient algorithms accomplish this by encoding a graphical models as sets of weighted formulas and
applying logical inference techniques to them (Sang et al.,
2005; Chavira and Darwiche, 2008).
All of these algorithms are variable-based, in that they explore the search space defined by truth assignments to the

variables. In this paper, we propose a new class of algorithms that explore the search space defined by truth assignments to arbitrary formulas, including but not necessarily those contained in the original specification. Our
formula-based schemes generalize variable-based schemes
because a variable is a special case of a formula, namely a
unit clause. For deriving exact answers, we propose to exhaustively search the space of truth assignments to formulas, yielding the formula decomposition and conditioning
(FDC) scheme. FDC performs AND/OR search (Dechter
and Mateescu, 2007) or recursive conditioning (Darwiche,
2001), with and without caching, over the space of formulas, utilizing several Boolean constraint propagation and
pruning techniques.
Even with these techniques, large complex domains will
still generally require approximate inference. For this, we
propose to compute an importance distribution over the formulas, yielding formula importance sampling (FIS). Each
sample in FIS is a truth assignment to a set of formulas.
To compute the importance weight of each such sampled
assignment, we need to know its model count (or number
of solutions). These model counts can either be computed
exactly, if it is feasible, or approximately using the recently
introduced approximate model counters such as SampleCount (Gomes et al., 2007) and SampleSearch (Gogate and
Dechter, 2007b). To the best of our knowledge, this is the
first work that harnesses the power of model counting for
approximate probabilistic inference. We prove that if the
model counts can be computed accurately, formula importance sampling will have smaller variance than variablebased importance sampling and thus should be preferred.
We present experimental results on three classes of benchmark problems: random Markov networks, QMR-DT networks from the medical diagnosis domain and Markov
logic networks. Our experiments show that as the number of variables in the formulas increases, formula-based
schemes not only dominate their variable based counterparts but also state-of-the-art exact algorithms such as
ACE (Chavira and Darwiche, 2008) and approximate
schemes such as MC-SAT (Poon and Domingos, 2006) and
Gibbs sampling (Geman and Geman, 1984).
The rest of the paper is organized as follows. Section 2
describes background. Section 3 presents formula decomposition and conditioning. Section 4 presents formula importance sampling. Experimental results are presented in
Section 5 and we conclude in Section 6.

2 Background
2.1 Notation
Let X = {X1 , . . . , Xn } be a set of propositional variables that can be assigned values from the set {0, 1} or
{False,True}. Let F be a propositional formula over X.

A model or a solution of F is a 0/1 truth assignment to
all variables in X such that F evaluates to True. We will
assume throughout that F is in CNF, namely it is a conjunction of clauses, a clause being a disjunction of literals.
A literal is a variable Xi or its negation ¬Xi . A unit clause
is a clause with one literal. Propositional Satisfiability or
SAT is the decision problem of determining whether F has
any models. This is the canonical NP-complete problem.
Model Counting is the problem of determining the number
of models of F , it is a #P-complete problem.
We will denote formulas by letters F , G, and H, the set
of solutions of F by Sol(F ) and its number of solutions
by #(F ). Variables are denoted by letters X and Y . We
denote sets by bold capital letters e.g., X, Y etc. Given a
set X = {X1 , . . . , Xn } of variables, x denotes a truth assignment (x1 , . . . , xn ), where Xi is assigned the value xi .
Clauses are denoted by the letters C, R, S and T . Discrete
functions are denoted by small Greek letters, e.g. φ, ψ, etc.
The variables involved in a function φ, namely the scope of
φ is denoted by V (φ). Similarly, the variables of a clause C
are denoted by V (C). Given an assignment x to a superset
X of Y, xY denotes the restriction of x to Y.
The expected value of a random
P variable X with respect to
a distribution Q is EP
Q [X] =
x∈X xQ(x). The variance
of x is V arQ [X] = x∈X (x − EQ [X])2 Q(x).

In this paper, we advocate using a collection of weighted
propositional formulas instead of the conventional tabular
representations to encode the potentials in Markov random
fields (MRFs) or conditional probability tables in Bayesian
networks. Specifically, we will use the following representation, which we call as propositional MRF or PropMRF in
short. A PropMRF is a Markov logic network (Richardson
and Domingos, 2006) in which all formulas are propositional. It is known that any discrete Markov random field or
a Bayesian network can be encoded as a PropMRF (Park,
2002; Sang et al., 2005; Chavira and Darwiche, 2008).

D EFINITION 1 (Propositional MRFs). A propositional
MRF (PropMRF), denoted by M is a triple (X, C, R)
where X is a set of n Boolean variables, C =
{(C1 , w1 ), . . . , (Cm , wm )} is a set of m soft (weighted)
clauses and R = {R1 , . . . , Rp } is a set of p hard clauses.
Each soft clause is a pair (Ci , wi ) where Ci is a clause and
wi is a real number. We will denote by FM = R1 ∧. . .∧Rp ,
the CNF formula defined by the hard clauses of M. The
primal graph of a PropMRF has variables as its vertices
and an edge between any two nodes that are involved in the
same hard or soft clause.
We can associate a discrete function φi with each soft
clause (Ci , wi ), defined as follows:

exp(wi ) If x evaluates Ci to True
φi (xV (Ci ) ) =
1
Otherwise

The probability distribution associated with M is given by:
PM (x) =



Qm

1
ZM

i=1

0

φi (xV (φi ) )

If x ∈ Sol(FM )
Otherwise

(1)

where ZM is the normalization constant; often referred to
as the partition function. ZM is given by:
m
Y

X

ZM =

φi (xV (φi ) )

Note that if M has no soft clauses, then ZM equals the
number of models of the formula FM . Thus, model counting is a special case of computing ZM .
We will focus on the query of finding the probability of a
CNF formula G, denoted by P (G). By definition:
X
PM (x)
P (G) =
x∈Sol(FM ∧G)

1
Z

=

X

=

m
Y

φi (xV (φi ) )

(4)

x∈Sol(FM ∧G) i=1
′
. Because
From Equations 3 and 4, we get P (G) = ZZM
M
computing P (G) is equivalent to computing a ratio of two
partition functions, in the sequel, we will present formulabased algorithms for computing ZM only.

3 Exact Formula-based Inference
We first explain how to perform inference by variablebased conditioning and then show how it can be generalized via formula-based conditioning. Consider the expression for ZM (See Equation 2). Given assignments Xj and
¬Xj , we can express ZM as:
ZM

X

=

m
Y

φi (xV (φi ) )

x∈Sol(FM ∧Xj ) i=1

+

X

m
Y

φi (xV (φi ) )

(5)

x∈Sol(FM ∧¬Xj ) i=1

= ZMXj + ZM¬Xj

Figure 1: An example PropMRF.
(AVBVCVDVE, w1)
(AVBVCVFVG,w2)
(DVEVH,w3)
(FVGVJ,w4)
Left arcs are True
arcs and right arcs
are False arcs

exp(w1+w2) .22
(DVEVH,w3)
(FVGVJ,w4)

A

(DVEVH,w3) (FVGVJ,w4) ¬A
(BVCVDVE, w1) (BVCVFVG,w2)

Decompose
(DVEVH,w3)

(FVGVJ,w4)

Figure 2: Figure demonstrating the simplification steps after con-

(3)

x∈Sol(FM ∧G) i=1

X

weight
w1
w2
w3
w4

ditioning on variable A for the PropMRFgiven in Figure 1.

φi (xV (φi ) )

If we add all the clauses of G to the hard clauses of M
yielding another PropMRF M′ , then the partition function
ZM′ of M′ is given by:
Z M′

Clause
A∨B∨C ∨D∨E
A∨B∨C ∨F ∨G
D∨E∨H
F ∨G∨J

(2)

x∈Sol(FM ) i=1

m
Y

ClauseID
S1
S2
S3
S4

(6)

where MX and M¬X are PropMRFs obtained by adding
X and ¬X to the set of hard clauses of M respectively.
Then, one can perform conditioning to compute ZMXj and
ZM¬Xj , recursively for each PropMRF until all variables

in X have been instantiated. Conditioning by itself is not
that useful. For example, if the PropMRF has no hard
clauses, then conditioning would perform 2n summations.
However, one can augment it with various simplification
schemes such as Boolean constraint propagation, and utilize problem decomposition, yielding powerful schemes in
practice. These and other ideas form the backbone of many
state-of-the-art schemes such as ACE (Chavira and Darwiche, 2008) and Cachet (Sang et al., 2005). To simplify a
PropMRF, we can apply any parsimonious operators - operators which do not change its partition function. In particular, we can remove all clauses which evaluate to True
from the set of hard clauses. These clauses are redundant.
Examples of operations that aid in identifying such hard
clauses are unit propagation, resolution and subsumption
elimination. For example, given a hard clause A, the hard
clause A ∨ B is redundant and can be removed because it
is subsumed within A. Similarly, A could be removed after unit propagation, because it always evaluates to True.
We can simplify the soft clauses based on the hard clauses
by removing all soft clauses which evaluate to either True
or False, multiplying the partition function with an appropriate constant to account for their removal. For example,
given a hard clause A, the soft clause A ∨ B having weight
w is always satisfied and can be removed, by multiplying
the partition function by exp(w)1 .
Another advancement that we can use is problem decomposition (Darwiche, 2001; Dechter and Mateescu, 2007).
The idea here is that if the soft and hard clauses of a
PropMRF can be partitioned into k > 1 sets such that any
two clauses in any of the k sets have no variables in com1
Note that if we remove a variable that is not a unit clause
from all the hard and soft clauses, then we have to multiply the
partition function by 2.

(AVBVCVDVE, w1)
(AVBVCVFVG,w2)
(DVEVH,w3)
(FVGVJ,w4)
Left arcs are True
arcs and right arcs
are False arcs

Algorithm 1: Formula Decomposition and Conditioning
(FDC)
Input: A PropMRF M
Output: ZM
begin
w = 0;
1. Simplify
begin
Simplify the hard and soft clauses;
Add the weights of all soft clauses which evaluate to
True to w;
Remove all soft clauses which evaluate to either True or
False from M. Update w to account for variables
completely removed from all formulas;
if FM has an empty clause then
return 0
if FM has only unit clauses then
return exp(w)

AVBVC

(DVE, w1) (FVG,w2), ¬A, ¬ B, ¬ C
(DVEVH,w3) (FVGVJ,w4)

(DVEVH,w3)
(FVGVJ,w4)
A VBVC

Decompose
Decompose
(DVEVH,w3)

(FVGVH,w4)

A VBVC

(DVE,w1)
(DVEVH,w3)
DVE

DVE

(FVG,w2)
(FVGVJ,w4)
FVG

(H,w3)
¬D
¬E

FVG

(J,w4)
¬F
¬G

end
2. Decompose
begin
if the primal graph of M is decomposable into k
components then
Let M1 , M2 , ..., Mk be the PropMRF’s
corresponding to the k components;
return exp(w) × F DC(M1 ) × . . . × F DC(Mk )

Figure 3: Search space of Formula Decomposition and
Conditioning for an example PropMRF
mon, then the partition function equals the product of the
partition functions of the k PropMRFs induced by each set.
The following example demonstrates simplification and decomposition on an example PropMRF.
E XAMPLE 1. Consider the PropMRF shown in Figure 1.
After conditioning on A and simplifying using Boolean
constraint propagation, we get two PropMRFs shown under the True (left) and false (right) branches of A in Figure
2. The PropMRF at the True branch contains only two soft
clauses which have no variables in common. Thus, they
could be decomposed into two PropMRFs as shown. The
contribution to the partition function due to the True branch
of A is then simply a product of the partition functions of
the two PropMRFs and exp(w1 + w2 ) × 22 .
Our main observation is that we can condition on arbitrary
formulas instead of variables. Formally, given an arbitrary
formula Hj , we can express ZM as:
ZM

X

=

m
Y

φi (xV (φi ) )

x∈Sol(FM ∧Hj ) i=1

+

X

m
Y

φi (xV (φi ) )

(7)

x∈Sol(FM ∧¬Hj ) i=1

= ZMHj + ZM¬Hj

(8)

When combined with Boolean constraint propagation and
problem decomposition, this seemingly simple idea is quite
powerful because it can yield a smaller search space, as we
demonstrate in the following example. In some cases, these
reductions could be significant.
E XAMPLE 2. Consider again the PropMRF shown in Figure 1. The first two clauses share a sub-clause A ∨ B ∨ C.
If we condition first on A ∨ B ∨ C, we get the search space
shown in Figure 3, which has only 7 leaf nodes. One can

end
3. Condition
begin
Heuristically choose a formula R to condition on;
Add hard clauses logically equivalent to R and ¬R to
M yielding MR and M¬R respectively;
return exp(w) × (F DC(MR ) + F DC(M¬R ))
end
end

verify that if we condition only on the variables instead of
arbitrary formulas, the best ordering scheme will explore
12 leaf nodes. (This search space is not shown because of
lack of space. It can be worked out using Figure 2.)
Algorithm Formula Decomposition and Conditioning
(FDC) is presented as Algorithm 1. It takes as input a
PropMRF M. The first step is the simplification step
in which we reduce the size of the hard and the soft
clauses using techniques such as unit propagation, resolution and subsumption elimination. In the decomposition step (Step 2), we decompose M into independent
PropMRFs if its primal graph is decomposable. Each of
them are then solved independently. Note that this is a
very important step and is the primary reason for efficiency
of techniques such as recursive conditioning (Darwiche,
2001) and AND/OR search (Dechter and Mateescu, 2007).
In fact, the whole idea in performing simplification and
heuristic conditioning is to split the PropMRF into several
PropMRF’s that can be solved independently. Finally, in
the conditioning step, we heuristically select a formula R
to condition on and then recurse on the true and the false
assignments to R.

We summarize the dominance of FDC over VDC (where
VDC is same as FDC except that we condition only on unit
clauses in Step 3) in the following proposition.
P ROPOSITION 1. Given a PropMRF M, let SM,F and
SM,V be the number of nodes in the smallest search space
explored by FDC and VDC respectively. Then SM,F ≤
SM,V . Sometimes, this inequality can be strict.
Improvements
We consider two important improvements. First, note that
if we are not careful, the algorithm as presented may yield
a super-exponential search space. For example, if we condition on a set of arbitrary formulas, none of which simplify the PropMRF, we may end up conditioning on a
super-exponential number of formulas. Trivially, to guarantee at least an exponential search space in the size of the
clausal specification, the formula selected for conditioning
must reduce/simplify at least one soft clause or at least one
hard clause. Second, we can augment FDC with component caching and clause learning as in Cachet (Sang et al.,
2005) and use w-cutset conditioning (Dechter, 1999) in a
straight forward manner. We omit the details.
3.1 Related work
FDC generalizes variable-based conditioning schemes such
as recursive conditioning (Darwiche, 2001), AND/OR
search (Dechter and Mateescu, 2007) and value elimination (Bacchus et al., 2003) because all we have to do is
restrict our conditioning to unit clauses. FDC also generalizes weighted model counting (WMC) approaches such
as ACE (Chavira and Darwiche, 2008) and Cachet (Sang
et al., 2005). These weighted model counting approaches
introduce additional Boolean variables to model each soft
clause. Conditioning on these Boolean variables is equivalent to conditioning on the soft clauses present in the
PropMRF. Thus, FDC can simulate WMC by restricting
its conditioning to not only the unit clauses but also the soft
clauses already present in the PropMRF. Finally, FDC is
related to streamlined constraint reasoning (SCR) approach
of (Gomes and Sellmann, 2004). The idea in SCR is to add
a set of streamlining formulas to the input formula in order
to cut down the size of its solution space in a controlled
manner. The goal of streamlining is solving a Boolean Satisfiability (or a Constraint Satisfaction) problem while FDC
uses (streamlined) formulas for weighted model counting.

4 Formula Importance Sampling
In this section, we generalize conventional variable-based
importance sampling to formula importance sampling and
show that our generalization yields new sampling schemes
having smaller variance. We first present background on
variable-based importance sampling.

4.1 Variable-Based Importance Sampling
Importance sampling (Rubinstein, 1981) is a general
scheme which can be used to approximate any quantity
such as ZM which can be expressed as a sum of a function over a domain. The main idea is to use an importance
distribution Q, which satisfies PM (x) > 0 ⇒ Q(x) > 0
and express ZM as follows:
ZM

=
=

X

m
Y

Q(x)
Q(x)
x∈Sol(F ) i=1
Q


I(x) m
i=1 φi (xV (φi ) )
EQ
Q(x)
φi (xV (φi ) ) ×

(9)

where I(x) is an indicator function which is 1 if x is a solution of FM and 0 otherwise.
Given N independent and identical (i.i.d.) samples
(x(1) , . . . , x(N ) ) drawn from Q, we can estimate ZM usbN , defined below:
ing Z
(i)
(i) Qm
N
1 X I(x ) j=1 φj (xV (φj ) )
b
ZN =
N i=1
Q(x(i) )

(10)

bN ] = ZM ,
It is known (Rubinstein, 1981) that EQ [Z
namely it is unbiased. The mean squared error (MSE) of
bN is given by:
Z
Q
i
h
I(x) m
i=1 φi (xV (φi ) )
V arQ
Q(x)
bN ) =
M SE(Z
(11)
N
Thus, we can reduce the mean squared error by either reducing the variance (given in the numerator) or by increasing the number of samples N (or both).

4.2 Formula-based Importance Sampling
Importance sampling can be extended to the space of
clauses (or formulas) in a straight forward manner. Let
H = {H1 , . . . , Hr } be a set of arbitrary formulas over the
variables X of M, and let h = (h1 , . . . , hr ) be a truth assignment to all the clauses in H. Let H be such that every consistent truth assignment h evaluates all soft clauses
to either True or False. Note that this condition is critical. Trivially, if H equals the set of soft clauses, then the
condition is satisfied. Let Fh be the formula corresponding to conjunction (H1 = h1 ∧ . . . ∧ Hr = hr ) and let
xh ∈ Sol(Fh ). Given a function φ, let xh,V (φ) be the restriction of xh to the scope of φ. Then, given an importance
distribution U (H), we can rewrite ZM as:
Q
X #(Fh ∧ FM ) × m
i=1 φi (xh,V (φi ) )
U (h)
ZM =
U (h)
h∈H
Qm


#(Fh ∧ FM ) × i=1 φi (xh,V (φi ) )
(12)
= EU
U (h)

Algorithm 2: Formula Importance Sampling (FIS)

4.3 Variance Reduction

Input: A PropMRFM and an importance distribution U (H)
over a set of clauses H = {H1 , . . . , Hr }
Output: An unbiased estimate of ZM
begin
e = 0, N = 0
Z
repeat
qb = 1 (Backtrack-free probability is stored here),
G = FM and h = φ
for i = 1 to |H| do
Let G1 = G ∧ Hi and G0 = G ∧ ¬Hi
if G0 and G1 have a solution (Checked using a SAT
solver) then
Sample hi from U (Hi |h)
h = h ∪ hi
qb = qb × U (Hi = hi |h)
G = G ∧ (Hi = hi )
else
if G0 is Satisfiable then
h = h ∪ (Hi = 0)
G = G ∧ (Hi = 0)
else
h = h ∪ (Hi = 1)
G = G ∧ (Hi = 1)

eN output by Algorithm 2 is likely to have
The estimate Z
bN given in Equation 10.
smaller mean squared error than Z
In particular, given a variable-based importance distribution Q(X), we can always construct a formula based importance distribution U (H) from Q(X), such that the variance
eN is smaller than that of Z
bN . Define:
of Z
X
Q(xh )
(14)
U (h) =

end

w = sum of weights of soft clauses satisfied by h
s = Estimate of model counts of G
e=Z
e + s × exp(w)/qb
Z
N =N +1
until timeout
e = Z/N
e
Z
e
return Z

Given N samples h(1) , . . . , h(N ) generated from U (H), we
eN , where:
can estimate ZM as Z
Qm
N
1 X #(Fh(i) ∧ FM ) × j=1 φj (xh(i) ,V (φj ) )
e
ZN =
N i=1
U (h(i) )

(13)

There are two issues that need to be addressed in order
to use Equation 13 for any practical purposes. First, the
importance distribution U (h) may suffer from the rejection problem (Gogate and Dechter, 2007a) in that we may
generate truth assignments (to clauses) which are inconsistent, namely their model count is zero. Note that this
could happen even if there are no hard clauses in M because the formula combinations considered may be inconsistent. Fortunately, if we ensure that U (h) = 0 whenever h is inconsistent, namely make U (h) backtrack-free
(Gogate and Dechter, 2007a), we can avoid this problem
altogether. Algorithm 2 outlines a procedure for constructing such a distribution using a complete SAT solver (for example Minisat (Sorensson and Een, 2005)). Second, computing #(Fh(j) ∧ FM ) exactly may be too time consuming. In such cases, we can use state-of-the-art approximate
counting techniques such as ApproxCount (Wei and Selman, 2005), SampleCount (Gomes et al., 2007) and SampleSearch (Gogate and Dechter, 2007b).

xh ∈Sol(Fh ∧FM )

Intuitively, each sample from U (H) given by Equation 14
is heavy in the sense that it corresponds to #(FM ∧ Fh )
samples from Q(xh ). Because of this larger sample size,
eN is smaller than that of Z
bN (assuming
the variance of Z
that #(FM ∧ Fh ) can be computed efficiently). The only
caveat is that generating samples from U (H) is more expensive. Formally (the proof is provided in the extended
version of the paper available online),
T HEOREM 1. Given a PropMRF M, a proposal distribution Q(X) defined over the variables of M, a set of formulas H = {H1 , . . . , Hr } and a distribution U (H) defined as
eN is less than or equal to
in Equation 14, the variance of Z
bN .
that of Z

We can easily integrate FIS with other variance reduction schemes such as Rao-Blackwellisation (Casella
and Robert, 1996) and AND/OR sampling (Gogate and
Dechter, 2008). These combinations can lead to interesting
time versus variance tradeoffs. We leave these improvements for future work. We describe how U (H) can be constructed in practice in the next section.

5 Experiments
5.1 Exact Inference
We compared “Formula Decomposition and Conditioning
(FDC)” against “Variable Decomposition and Conditioning (VDC)”, variable elimination (VE) (Dechter, 1999) and
ACE (Chavira and Darwiche, 2008) (which internally uses
the C2D compiler (Darwiche, 2004)) for computing the
partition function on benchmark problems from three domains: (a) Random networks, (b) medical diagnosis networks and (c) Relational networks. ACE, FDC and VDC
use the same clausal representation while VE uses tabular
representation. Note that the domains are deliberately chosen to elucidate the properties of FDC, in particular, to verify our intuition that as size of the clauses increases, FDC
is likely to dominate VDC.
We implemented FDC and VDC on top of RELSAT
(Roberto J. Bayardo Jr. and Pehoushek, 2000), which is
a SAT model counting algorithm. As mentioned earlier,
after conditioning on a formula, we use various Boolean

Problem
Random
40-40-3
40-40-5
40-40-7
40-40-9
50-50-3
50-50-5
50-50-7
50-50-9
60-60-3
60-60-5
60-60-7
60-60-9
QMRDT
40-40-5
40-40-7
40-40-9
40-40-11
50-50-5
50-50-7
50-50-9
50-50-11
60-60-5
60-60-7
60-60-9
60-60-11
FS
fs-25-5
fs-27-5
fs-29-5
fs-31-5
Cora
Cora2
Cora3

w

FDC

VDC

ACE

VE

10.80
23.00
29.80
33.40
12.60
28.40
36.00
42.20
15.00
33.80
44.00
49.60

0.08
11.81
11.77
1.71
0.02
278.25
167.79
20.97
0.08
X
X
218.28

0.08
10.57
245.63
326.42
0.02
257.45
1139.06
1187.28
0.11
X
X
X

0.60
108.37
13.37
14.37
0.73
56.94
294.30
113.52
0.58
X
X
X

0.01
1.69
X
X
0.02
X
X
X
0.04
X
X
X

16.80
22.20
24.00
25.20
22.80
30.00
34.00
33.00
26.00
34.60
40.40
45.00

2.03
6.39
22.20
18.20
14.53
545.23
33.30
28.43
244.05
56.40
97.20
72.10

1.26
6.73
44.51
69.00
14.96
517.71
883.04
554.01
203.32
1096.62
1180.94
X

1.17
3.87
9.40
10.08
9.14
379.41
357.06
495.96
310.37
637.23
554.01
488.10

1.17
7.93
X
X
3.63
X
X
X
X
X
X
X

22.80
24.80
26.60
29.40

30.93
151.56
391.65
1312.90

26.86
135.22
371.74
892.20

333.20
353.64
119.23
357.65

8.53
X
X
X

12.00
32.00

0.17
3902.20

0.14
X

1.84
X

0.04
X

Table 1: Average runtime in seconds of the four algorithms used
in our study over 10 random instances for each problem. We gave
each solver a time-bound of 3 hrs and a memory bound of 2GB.
X indicates that either the memory or time bound was exceeded.
The second column gives the average treewidth.

propagation, pruning techniques such as unit propagation, clause learning, subsumption elimination and resolution. Also, similar to Cachet (Sang et al., 2005), we use
component caching and similar to w-cutset conditioning
(Dechter, 1999), we invoke bucket elimination at a node
if the treewidth of the (remaining) PropMRF at the node is
less than 16.
Since FDC is a DPLL-style backtracking search scheme,
its performance is highly dependent upon a good branching heuristic (that selects the next clause to condition on).
In our implementation, we used a simple dynamic heuristic of conditioning on the largest sub-clause (unit clause in
case of VDC) that is common to most hard and soft clauses,
ties broken arbitrarily. The main intuition for this heuristic
is that branching on the largest common sub-clause would
cause the most propagation, yielding the most reduction in
the search space size. We also tried a few other heuristics,
both static and dynamic, such as (i) conditioning on a subclause C (and its negation) that causes the most unit propa-

gations (but one has to perform unit propagations for each
candidate clause, which can be quite expensive in practice)
(ii) graph partitioning heuristics based on the min-fill, mindegree and hmetis orderings; these heuristics are used by
solvers such as ACE (Chavira and Darwiche, 2008) and
AND/OR search (Dechter and Mateescu, 2007) and (iii)
Entropy-based heuristics. The results for these heuristics
show a similar trend as the results for the heuristic used in
our experiments, with the latter performing better on an average. We leave the development of sophisticated formulaordering heuristics for future work.
Table 1 shows the results. For each problem, we generated
10 random instances. For each instance, we set 5% of randomly chosen variables as evidence. Each row shows the
average time in seconds for each problem.
5.1.1 Random networks
Our first domain is that of random networks. The networks are generated using the model (n, m, s), where n
is the number of (Boolean) variables, m is the number
of weighted clauses and s is the size of each weighted
clause. Given n variables X = {X1 , . . . , Xn }, each clause
Ci (for i = 1 to m) is generated by randomly selecting
s (distinct) random variables from X and negating each
with probability 0.5. For our experiments, we set n = m
and experimented with three values for n and m: n, m ∈
{40, 50, 60}. s was varied from 3 to 9 in increments of 2.
A random problem (n, m, s) is designated as n − m − s in
Table 1. We see that FDC dominates VDC as s increases.
ACE is often inferior to FDC and often inferior to VDC. As
expected, variable elimination which does not take advantage of the structure of the formulas is the fastest scheme
when the treewidth is small but is unable to solve any problems having treewidth greater than 24.
5.1.2 Medical Diagnosis
Our second domain is a version of QMR-DT medical diagnosis networks (Shwe et al., 1991) as used in Cachet (Sang
et al., 2005). Each problem can be specified using a two
layer bipartite graph in which the top layer consists of diseases and the bottom layer consists of symptoms. If a disease causes a symptom, there is an edge from the disease
to the symptom. We have a weighted unit clause for each
disease and a weighted clause for each symptom, which is
simply a logical OR of the diseases that cause it (in (Sang
et al., 2005), this clause was hard. We attach an arbitrary
weight to it to make the problem harder). For our experiments, we varied the numbers of diseases and symptoms
from 40 to 60. For each symptom, we varied the number of
diseases that can cause it from 5 to 11 in increments of 2.
The diseases for each symptom are chosen randomly.
A QMR-DT problem (d, f, s) is designated as d − f − s in
Table 1. We can see that as the size of the clauses increases,

FDC performs better than VDC. FDC also dominates ACE
as the problem size increases.
5.1.3 Relational networks
Our final domain is that of relational networks. We experimented with the Friends and Smokers networks and the
Entity resolution networks.
In the friends and smokers networks (FS), we have
three first order predicates smokes(x), which indicates
whether a person smokes, cancer(x), which indicates
whether a person has cancer, and f riends(x, y), which
indicates who are friends of whom. The probabilistic
model is defined by assigning weights to two logical constraints, f riends(x, y) ∧ smokes(x) ⇒ smokes(y) and
smokes(x) ⇒ cancer(x). Given a domain for x and
y, a PropMRF can be generated from these two logical
constraints by considering all possible groundings of each
predicate. We experimented with different domain sizes for
x and y ranging from 25 to 34. From Table 1, we can see
that the time required by FDC is almost the same as VDC.
This is because the size of the clauses is small (≤ 3). ACE
dominates both FDC and VDC.
Entity resolution is the problem of determining which
observations correspond to the same entity. In our experiments, we consider the problem of matching citations of scientific papers.
We used the CORA
Markov logic network given in the Alchemy tutorial (Kok et al., 2004).
This MLN has ten predicates such as Author(bib, author), T itle(bib, title),
SameAuthor(author, author), SameT itle(title, title)
etc. and clauses ranging from size 2 to 6. The clauses
express relationship such as: if two fields have high similarity, then they are (probably) the same; if two records are
the same, their fields are the same, and vice-versa; etc. We
experimented with domain sizes of 2 and 3 for each of the
5 first-order variables present in the domain. The problems
are denoted as cora2 and cora3 respectively. From Table
1, we can see that FDC is the only algorithm capable of
solving the largest instance.
5.2 Approximate Inference
We compared “Formula importance sampling (FIS)”
against “Variable importance sampling (VIS)” and stateof-the-art schemes such as MC-SAT (Poon and Domingos, 2006) and Gibbs sampling available in Alchemy (Kok
et al., 2004) on the three domains described above. For both
VIS and FIS, we chose to construct the importance distribution Q from the output of a Belief propagation scheme
(BP), because BP was shown to yield a better importance
function than other approaches in previous studies (Yuan
and Druzdzel, 2006; Gogate and Dechter, 2005).
We describe next, how the method described in (Gogate

and Dechter, 2005) can be adapted to construct an importance distribution over formulas. Here, we first run BP
(or Generalized Belief Propagation (Yedidia et al., 2004))
over a factor (or region) graph in which the nodes are the
variables and the factors are the hard and the soft clauses.
Let (C1 , . . . , Cm ) be an ordering over the soft clauses.
Given a truth assignment to the first i − 1 soft clauses
ci−1 = (c1 , . . . , ci−1 ), we compute U (Ci |ci−1 ) as follows.
We first simplify the formula F = FM ∧ Fci−1 , possibly
deriving new unit clauses. Let φCi be the marginal distribution at the factor corresponding to the clause Ci in the
output of BP. Then, U (Ci |ci−1 ) is given by:
X
U (Ci = T rue|ci−1 ) ∝
(15)
IF,Ci (y)φCi (y)
y∈φCi

where IF,Ci (y) = 1 if y evaluates Ci to True but does not
violate any unit clause in F , and 0 otherwise. Note that the
importance distribution Q over the variables is a special
case of the scheme described above in which we construct
a distribution over all the unit clauses.
We implemented Algorithm 2 as follows. Notice that the
algorithm requires a SAT solver and a model counter. We
used Minisat (Sorensson and Een, 2005) as our SAT solver.
For model counting, we use the RELSAT model counter
whenever exact counting was feasible2 and the approximate solver SampleSearch (Gogate and Dechter, 2007b)
whenever it wasn’t.
We measure the performance of the sampling schemes using the sum Kullback-Leibler divergence (KLD) between
the exact and the approximate posterior marginals for each
variable given evidence. Time versus sum KLD plots for
two representative problems from each domain are shown
in Figures 4, 5 and 6. We can clearly see that as the size of
the clauses increases, FIS outperforms VIS, MC-SAT and
Gibbs sampling.

6 Summary and Conclusion
In this paper, we introduced a new formula-based approach
for performing exact and approximate inference in graphical models. Formula-based inference is attractive because:
(a) it generalizes standard variable-based inference, (b) it
yields several new efficient algorithms that are not possible
by reasoning just over the variables and (c) it fits naturally
within the recent research efforts in combining logical and
probabilistic Artificial Intelligence.
Our empirical evaluation shows that formula-based approach is especially suitable for domains having large
clauses. Such clauses are one of the main reasons for using logic instead of tables for representing potentials or
2

Exact counting was invoked if the number of variables was
less than 100, which was the case for most networks that we experimented with, except the relational benchmarks.

10

10
1
0.1

0.1

Sum KLD

Sum KLD

1

0.01
0.001

0.01
0.001
0.0001

0.0001

1e-05

1e-05

1e-06
0

200

400

600

800

1000

1200

0

200

Time in seconds
MC-SAT
Gibbs sampling

600

800

1000

1200

Time in seconds

FormulaIS
VariableIS

MC-SAT
Gibbs sampling

(a) Random problem (n = 50, m = 50, s = 5)

FormulaIS
VariableIS

(a) QMR-DT problem (d = 50, f = 50, s = 5)

100

100

10

10
1

Sum KLD

1

Sum KLD

400

0.1
0.01
0.001

0.1
0.01
0.001
0.0001

0.0001

1e-05

1e-05

1e-06
0

200

400

600

800

1000

1200

0

Time in seconds
MC-SAT
Gibbs sampling

400

600

800

1000

1200

Time in seconds

FormulaIS
VariableIS

(b) Random problem (n = 50, m = 50, s = 7)

200

MC-SAT
Gibbs sampling

FormulaIS
VariableIS

(b) QMR-DT problem (d = 50, f = 50, s = 11)

Figure 4: Time versus Sum KLD plots for 2 Random instances.

Figure 5: Time versus Sum KLD plots for 2 QMR-DT networks.

CPTs in graphical models. In particular, conventional tabular representations require space exponential in the number of variables in the scope of the potential, while if the
potential can be summarized using a constant number of
clauses, we only require linear space. Since an efficient
inference scheme is one of the main bottleneck in learning PropMRFs having large clauses, we believe that our
formula-based approach to inference can lead to new structure and weight learning schemes that learn large weighted
clauses from data.

D030010, NSF grants IIS-0534881 and IIS-0803481, and
ONR grant N00014-08-1-0670. The views and conclusions contained in this document are those of the authors
and should not be interpreted as necessarily representing
the official policies, either expressed or implied, of ARO,
DARPA, NSF, ONR, or the United States Government.

Our work can be extended in several ways. In particular,
we envision formula-based versions of various inference
schemes such as variable elimination, belief propagation
and Markov Chain Monte Carlo (MCMC) sampling. One
of these schemes, namely formula elimination trivially follows from this work, as it is known that conditioning works
along the reverse direction of elimination (Dechter, 1999).
Also, we envision the development of lifted versions of all
the formula-based schemes proposed in this paper.
Acknowledgements
This research was partly funded by ARO grant W911NF08-1-0242, AFRL contract FA8750-09-C-0181, DARPA
contracts
FA8750-05-2-0283,
FA8750-07-D-0185,
HR0011-06-C-0025, HR0011-07-C-0060 and NBCH-

