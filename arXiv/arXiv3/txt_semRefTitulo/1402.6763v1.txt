
We consider the problem of controlling a Markov decision process (MDP) with a large state
space, so as to minimize average cost. Since it is intractable to compete with the optimal
policy for large scale problems, we pursue the more modest goal of competing with a lowdimensional family of policies. We use the dual linear programming formulation of the MDP
average cost problem, in which the variable is a stationary distribution over state-action pairs,
and we consider a neighborhood of a low-dimensional subset of the set of stationary distributions
(defined in terms of state-action features) as the comparison class. We propose two techniques,
one based on stochastic convex optimization, and one based on constraint sampling. In both
cases, we give bounds that show that the performance of our algorithms approaches the best
achievable by any policy in the comparison class. Most importantly, these results depend on
the size of the comparison class, but not on the size of the state space. Preliminary experiments
show the effectiveness of the proposed algorithms in a queuing application.

1

Introduction

We study the average loss Markov decision process problem. The problem is well-understood when
the state and action spaces are small (Bertsekas, 2007). Dynamic programming (DP) algorithms,
such as value iteration (Bellman, 1957) and policy iteration (Howard, 1960), are standard techniques
to compute the optimal policy. In large state space problems, exact DP is not feasible as the
computational complexity scales quadratically with the number of states.
A popular approach to large-scale problems is to restrict the search to the linear span of a small
number of features. The objective is to compete with the best solution within this comparison class.
Two popular methods are Approximate Dynamic Programming (ADP) and Approximate Linear
1

Programming (ALP). This paper focuses on ALP. For a survey on theoretical results for ADP see
(Bertsekas and Tsitsiklis, 1996, Sutton and Barto, 1998), (Bertsekas, 2007, Vol. 2, Chapter 6), and
more recent papers (Sutton et al., 2009b,a, Maei et al., 2009, 2010).
Our aim is to develop methods that find policies with performance guaranteed to be close to
the best in the comparison class but with computational complexity that does not grow with the
size of the state space. All prior work on ALP either scales badly or requires access to samples
from a distribution that depends on the optimal policy.
This paper proposes a new algorithm to solve the Approximate Linear Programming problem
that is computationally efficient and does not require knowledge of the optimal policy. In particular,
we introduce new proof techniques and tools for average cost MDP problems and use these techniques to derive a reduction to stochastic convex optimization with accompanying error bounds.
We also propose a constraint sampling technique and obtain performance guarantees under an
additional assumption on the choice of features.

1.1

Notation

Let X and A be positive integers. Let X = {1, 2, . . . , X} and A = {1, 2, . . . , A} be state and action

spaces, respectively. Let ∆S denote probability distributions over set S. A policy π is a map from
the state space to ∆A : π : X → ∆A . We use π(a|x) to denote the probability of choosing action a

in state x under policy π. A transition probability kernel (or transition kernel) P : X × A → ∆X

maps from the direct product of the state and action spaces to ∆X . Let P π denote the probability

transition kernel under policy π. A loss function is a bounded real-valued function over state and
action spaces, ℓ : X × A → [0, 1]. Let Mi,: and M:,j denote ith row and jth column of matrix M
P
respectively. Let kvk1,c = i ci |vi | and kvk∞,c = maxi ci |vi | for a positive vector c. We use 1 and

0 to denote vectors with all elements equal to one and zero, respectively. We use ∧ and ∨ to denote

the minimum and the maximum, respectively. For vectors v and w, v ≤ w means element-wise
inequality, i.e. vi ≤ wi for all i.

1.2

Linear Programming Approach to Markov Decision Problems

Under certain assumptions, there exist a scalar λ∗ and a vector h∗ ∈ RX that satisfy the Bellman
optimality equations for average loss problems,
"

λ∗ + h∗ (x) = min ℓ(x, a) +
a∈A

X

x′ ∈X

′

#

P(x,a),x′ h∗ (x )

.

The scalar λ∗ is called the optimal average loss, while the vector h∗ is called a differential value
function. The action that minimizes the right-hand side of the above equation is the optimal action
in state x and is denoted by a∗ (x). The optimal policy is defined by π∗ (a∗ (x)|x) = 1. Given ℓ and

2

P , the objective of the planner is to compute the optimal action in all states, or equivalently, to
find the optimal policy.
The MDP problem can also be stated in the LP formulation (Manne, 1960),
max λ ,

(1)

λ,h

s.t.

B(λ1 + h) ≤ ℓ + P h ,

where B ∈ {0, 1}XA×X is a binary matrix such that the ith column has A ones in rows 1 + (i − 1)A

to iA. Let vπ be the stationary distribution under policy π and let µπ (x, a) = vπ (x)π(a|x). We can
write
X

π∗ = argmin
π

x∈X

= argmin
π

vπ (x)

X

X

π(a|x)ℓ(x, a)

a∈A

µπ (x, a)ℓ(x, a) = argmin µ⊤
πℓ .
π

(x,a)∈X ×A

In fact, the dual of LP (1) has the form of
min µ⊤ ℓ ,

(2)

µ∈RXA

s.t. µ⊤ 1 = 1, µ ≥ 0, µ⊤ (P − B) = 0 .
The objective function, µ⊤ ℓ, is the average loss under stationary distribution µ. The first two
constraints ensure that µ is a probability distribution over state-action space, while the last constraint ensures that µ is a stationary distribution. Given a solution µ, we can obtain a policy via
P
π(a|x) = µ(x, a)/ a′ ∈A µ(x, a′ ).

1.3

Approximations for Large State Spaces

The LP formulations (1) and (2) are not practical for large scale problems as the number of variables and constraints grows linearly with the number of states. Schweitzer and Seidmann (1985)
propose approximate linear programming (ALP) formulations. These methods were later improved by de Farias and Van Roy (2003a,b), Hauskrecht and Kveton (2003), Guestrin et al. (2004),
Petrik and Zilberstein (2009), Desai et al. (2012). As noted by Desai et al. (2012), the prior work
on ALP either requires access to samples from a distribution that depends on optimal policy or
assumes the ability to solve an LP with as many constraints as states. (See Section 2 for a more
detailed discussion.) Our objective is to design algorithms for very large MDPs that do not require
knowledge of the optimal policy.
In contrast to the aforementioned methods, which solve the primal ALPs (with value functions
as variables), we work with the dual form (2) (with stationary distributions as variables). Analogous
3

to ALPs, we control the complexity by limiting our search to a linear subspace defined by a small
number of features. Let d be the number of features and Φ be a (XA) × d matrix with features as

column vectors. By adding the constraint µ = Φθ, we get
min θ ⊤ Φ⊤ ℓ ,
θ

s.t.

θ ⊤ Φ⊤ 1 = 1, Φθ ≥ 0, θ ⊤ Φ⊤ (P − B) = 0 .

If a stationary distribution µ0 is known, it can be added to the linear span to get the ALP
min(µ0 + Φθ)⊤ ℓ ,

(3)

θ

s.t. (µ0 + Φθ)⊤ 1 = 1, µ0 + Φθ ≥ 0, (µ0 + Φθ)⊤ (P − B) = 0 .
Although µ0 + Φθ might not be a stationary distribution, it still defines a policy1
πθ (a|x) = P

[µ0 (x, a) + Φ(x,a),: θ]+
,
′
a′ [µ0 (x, a ) + Φ(x,a′ ),: θ]+

(4)

We denote the stationary distribution of this policy µθ which is only equal to µ0 + Φθ if θ is in the
feasible set.

1.4

Problem definition

With the above notation, we can now be explicit about the problem we are solving.
Definition 1 (Efficient Large-Scale Dual ALP). For an MDP specified by ℓ and P , the efficient
large-scale dual ALP problem is to produce parameters θb such
n
o
⊤
µ⊤
ℓ
≤
min
µ
ℓ
:
θ
feasible
for
(3)
+ O(ǫ)
θ
b
θ

(5)

in time polynomial in d and 1/ǫ. The model of computation allows access to arbitrary entries of Φ,
ℓ, P , µ0 , P ⊤ Φ, and 1⊤ Φ in unit time.
Importantly, the computational complexity cannot scale with X and we do not assume any
knowledge of the optimal policy. In fact, as we shall see, we solve a harder problem, which we
define as follows.
Definition 2 (Expanded Efficient Large-Scale Dual ALP). Let V : ℜd → ℜ+ be some “violation

function” that represents how far µ0 +Φθ is from a valid stationary distribution, satisfying V (θ) = 0

if θ is a feasible point for the ALP (3). The expanded efficient large-scale dual ALP problem is to
1

We use the notation [v]− = v ∧ 0 and [v]+ = v ∨ 0.

4

produce parameters θb such that
µ⊤
ℓ
θb



1
⊤
d
≤ min µθ ℓ + V (θ) : θ ∈ ℜ + O(ǫ),
ǫ

(6)

in time polynomial in d and 1/ǫ, under the same model of computation as in Definition 1.
Note that the expanded problem is strictly more general as guarantee (6) implies guarantee
(5). Also, many feature vectors Φ may not admit any feasible points. In this case, the dual ALP
problem is trivial, but the expanded problem is still meaningful.
Having access to arbitrary entries of the quantities in Definition 1 arises naturally in many
situations. In many cases, entries of P ⊤ Φ are easy to compute. For example, suppose that for any
state x′ there are a small number of state-action pairs (x, a) such that P (x′ |x, a) > 0. Consider
Tetris; although the number of board configurations is large, each state has a small number of
possible neighbors. Dynamics specified by graphical models with small connectivity also satisfy
this constraint. Computing entries of P ⊤ Φ is also feasible given reasonable features. If a feature ϕi
is a stationary distribution, then P ⊤ ϕi = B ⊤ ϕi . Otherwise, it is our prerogative to design sparse
feature vectors, hence making the multiplication easy. We shall see an example of this setting later.

1.5

Our Contributions

In this paper, we introduce an algorithm that solves the expanded efficient large-scale dual ALP
problem under a (standard) assumption that any policy converges quickly to its stationary distribution.
Our algorithm take as input a constant S and an error tolerance ǫ, and has access to the various
products listed in Definition 1. Define Θ = {θ : θ ⊤ Φ⊤ 1 = 1 − µ⊤
0 1, kθk ≤ S}. If no stationary
distribution is known, we can simply choose µ0 = 0. The algorithm is based on stochastic convex
optimization. We prove that for any δ ∈ (0, 1), after O(1/ǫ4 ) steps of gradient descent, the algorithm
finds a vector θb ∈ Θ such that, with probability at least 1 − δ,
µ⊤
ℓ ≤µ⊤
θℓ+
θb

1
1
k[µ0 + Φθ]− k1 +
(P − B)⊤ (µ0 + Φθ)
ǫ
ǫ

1

+ O(ǫ log(1/δ))

holds for all θ ∈ Θ; i.e., we solve the expanded problem for V (θ) equal to the L1 error of the

violation. The second and third terms are zero for feasible points (points in the intersection of
the feasible set of LP (2) and the span of the features). For points outside the feasible set, these
terms measure the extent of constraint violations for the vector µ0 + Φθ, which indicate how well
stationary distributions can be represented by the chosen features.

The above performance bound scales with 1/ǫ that can be large when the feasible set is empty
and ǫ is very small. We propose a second approach and show that this dependence can be eliminated
if we have extra information about the MDP. Our second approach is based on the constraint
5

sampling method that is already applied to large-scale linear programming and MDP problems
(de Farias and Van Roy, 2004, Calafiore and Campi, 2005, Campi and Garatti, 2008). We obtain
performance bounds, but under the condition that a suitable function that controls the size of
constraint violations is available. Our proof technique is different from previous work and gives
stronger performance bounds.
Our constraint sampling method takes two extra inputs: functions v1 and v2 that specify the
amount of constraint violations that we tolerate at each state-action pair. The algorithm samples
O( d log 1 ) constraints and solves the sampled LP problem. Let θe denote the solution of the sampled
ǫ

ǫ

ALP and θ∗ denote the solution of the full ALP subject to constraints v1 and v2 . We prove that
with high probability,

ℓ⊤ µθe ≤ ℓ⊤ µθ∗ + O(ǫ + kv1 k1 + kv2 k1 ) .

2

Related Work

de Farias and Van Roy (2003a) study the discounted version of the primal form (1). Let c ∈ RX

be a vector with positive components and γ ∈ (0, 1) be a discount factor. Let L : RX → RX be
P
the Bellman operator defined by (LJ)(x) = mina∈A (ℓ(x, a) + γ x′ ∈X P(x,a),x′ J(x′ )) for x ∈ X . Let

Ψ ∈ RX×d be a feature matrix. The exact and approximate LP problems are as follows:
max c⊤ J ,

max c⊤ Ψw ,

J∈RX

s.t.

w∈Rd

LJ ≥ J ,

s.t.

LΨw ≥ Ψw .

which can also be written as
max c⊤ J ,

max c⊤ Ψw ,

J∈RX

w∈Rd

s.t. ∀(x, a), ℓ(x, a) + γP(x,a),: J ≥ J(x) ,

s.t.

(7)

∀(x, a), ℓ(x, a) + γP(x,a),: Ψw ≥ (Ψw)(x) .

The optimization problem on the RHS is an approximate LP with the choice of J = Ψw. Let
 P∞ t

Jπ (x) = E
t=0 γ ℓ(xt , π(xt ))|x0 = x be value of policy π, J∗ be the solution of LHS, and πJ (x) =

argmina∈A (ℓ(x, a) + γP(x,a),: J) be the greedy policy with respect to J. Let ν ∈ ∆X be a probability

distribution and define µπ,ν = (1 − γ)ν ⊤ (I − γP π )−1 . de Farias and Van Roy (2003a) prove that

for any J satisfying the constraints of the LHS of (7),
kJπJ − J∗ k1,ν ≤
Define βu = γ maxx,a

P

x′

1
kJ − J∗ k1,µπ ,ν .
J
1−γ

(8)

P(x,a),x′ u(x′ )/u(x). Let U = {u ∈ RX : u ≥ 1, u ∈ span(Ψ), βu < 1}. Let

6

w∗ be the solution of ALP. de Farias and Van Roy (2003a) show that for any u ∈ U ,
kJ∗ − Ψw∗ k1,c ≤

2c⊤ u
min kJ∗ − Ψwk∞,1/u .
1 − βu w

(9)

This result has a number of limitations. First, solving ALP can be computationally expensive as
the number of constraints is large. Second, it assumes that the feasible set of ALP is non-empty.
Finally, Inequality (8) implies that c = µπΨw∗ ,ν is an appropriate choice to obtain performance
bounds. However, w∗ itself is function of c and is not known before solving ALP.
de Farias and Van Roy (2004) propose a computationally efficient algorithm that is based on
a constraint sampling technique. The idea is to sample a relatively small number of constraints
and solve the resulting LP. Let N ⊂ Rd be a known set that contains w∗ (solution of ALP). Let
V
V
µVπ,c (x) = µπ,c (x)V (x)/(µ⊤
π,c V ) and define the distribution ρπ,c (x, a) = µπ,c (x)/A. Let δ ∈ (0, 1)
P
and ǫ ∈ (0, 1). Let β u = γ maxx x′ P(x,π∗ (x)),x′ u(x′ )/u(x) and

(1 + β V )µ⊤
π∗ ,c V
sup kJ∗ − Ψwk∞,1/V ,
D=
⊤
2c J∗
w∈N

16AD
m≥
(1 − γ)ǫ



2
48AD
+ log
d log
(1 − γ)ǫ
δ



.

Let S be a set of m random state-action pairs sampled under ρVπ∗ ,c . Let w
b be a solution of the

following sampled LP:

max c⊤ Ψw ,

w∈Rd

s.t.

w ∈ N , ∀(x, a) ∈ S, ℓ(x, a) + γP(x,a),: Ψw ≥ (Ψw)(x) .

de Farias and Van Roy (2004) prove that with probability at least 1 − δ, we have
kJ∗ − Ψwk
b 1,c ≤ kJ∗ − Ψw∗ k1,c + ǫ kJ∗ k1,c .

This result has a number of limitations. First, vector µπ∗ ,c (that is used in the definition of D)
depends on the optimal policy, but an optimal policy is what we want to compute in the first
place. Second, we can no longer use Inequality (8) to obtain a performance bound (a bound on
kJπΨwb − J∗ k1,c ), as Ψw
b does not necessarily satisfy all constraints of ALP.

Desai et al. (2012) study a smoothed version of ALP, in which slack variables are introduced

that allow for some violation of the constraints. Let D ′ be a violation budget. The smoothed ALP
(SALP) has the form of
max c⊤ Ψw ,

max c⊤ Ψw −

w,s

s.t.

Ψw ≤ LΨw + s,

w,s

µ⊤
π∗ ,c s

′

≤ D , s ≥ 0,

7

2µ⊤
π∗ ,c s
,
1−γ

s.t. Ψw ≤ LΨw + s, s ≥ 0 .

The ALP on RHS is equivalent to LHS with a specific choice of D ′ . Let U = {u ∈ RX : u ≥ 1}

be a set of weight vectors. Desai et al. (2012) prove that if w∗ is a solution to above problem, then
kJ∗ − Ψw∗ k1,c ≤ inf kJ∗ − Ψwk∞,1/u
w,u∈U

2(µ⊤
π∗ ,c u)(1 + βu )
c u+
1−γ
⊤

!

.

The above bound improves (9) as U is larger than U and RHS in the above bound is smaller than
RHS of (9). Further, they prove that if η is a distribution and we choose c = (1−γ)η ⊤ (I −γP πΨw∗ ),
then

JµΨw∗ − J∗

1,η

1
≤
1−γ

inf kJ∗ − Ψwk∞,1/u

w,u∈U

2(µ⊤
π∗ ,ν u)(1 + βu )
c u+
1−γ
⊤

!!

.

Similar methods are also proposed by Petrik and Zilberstein (2009). One problem with this result
is that c is defined in terms of w∗ , which itself depends on c. Also, the smoothed ALP formulation
uses π∗ which is not known. Desai et al. (2012) also propose a computationally efficient algorithm.
Let S be a set of S random states drawn under distribution µπ∗ ,c . Let N ′ ⊂ Rd be a known set

that contains the solution of SALP. The algorithm solves the following LP:
max c⊤ Ψw −
w,s

s.t.

X
2
s(x) ,
(1 − γ)S
x∈S

∀x ∈ S, (Ψw)(x) ≤ (LΨw)(x) + s(x), s ≥ 0, w ∈ N ′ .

Let w
b be the solution of this problem. Desai et al. (2012) prove high probability bounds on
the approximation error kJ∗ − Ψwk
b 1,c . However, it is no longer clear if a performance bound
on kJ∗ − JπΨwb k1,c can be obtained from this approximation bound.

Next, we turn our attention to average cost ALP, which is a more challenging problem and is

also the focus of this paper. Let ν be a distribution over states, u : X → [1, ∞), η > 0, γ ∈ [0, 1],

Pγπ = γP π + (1 − γ)1ν ⊤ , and Lγ h = minπ (ℓπ + Pγπ h). de Farias and Van Roy (2006) propose the

following optimization problem:

min s1 + ηs2 ,

(10)

w,s1 ,s2

s.t.

Lγ Ψw − Ψw + s1 1 + s2 u ≥ 0, s2 ≥ 0 .

Let (w∗ , s1,∗ , s2,∗ ) be the solution of this problem. Define the mixing time of policy π by
τπ = inf

(

τ :

t−1
1 X ⊤ π t′
τ
ν (P ) ℓπ − λπ ≤ , ∀t
t ′
t
t =0

)

.

Let τ∗ = lim inf δ→0 {τπ : λπ ≤ λ∗ + δ}. Let πγ∗ be the optimal policy when discount factor is
8

γ. Let πγ,w be the greedy policy with respect to Ψw when discount factor is γ, µ⊤
γ,π = (1 −
P∞ t ⊤ π t
γ) t=0 γ ν (P ) and µγ,w = µγ,πγ,w . de Farias and Van Roy (2006) prove that if η ≥ (2 −
γ)µ⊤
γ,πγ∗ u,

λw ∗ − λ∗ ≤

(1 + β)η max(D ′′ , 1)
min h∗γ − Ψw
w
1−γ

∞,1/u

+ (1 − γ)(τ∗ + τπw∗ ) ,

⊤
where β = maxπ kI − γP π k∞,1/u , D ′′ = µ⊤
γ,w∗ V /(ν V ) and V = Lγ Ψw∗ − Ψw∗ + s1,∗ 1 + s2,∗ u.

Similar results are obtained more recently by Veatch (2013).

An appropriate choice for vector ν is ν = µγ,w∗ . Unfortunately, w∗ depends on ν. We should
also note that solving (10) can be computationally expensive. de Farias and Van Roy (2006) propose constraint sampling techniques similar to (de Farias and Van Roy, 2004), but no performance
bounds are provided.
Wang et al. (2008) study ALP (3) and show that there is a dual form for standard value function
based algorithms, including on-policy and off-policy updating and policy improvement. They also
study the convergence of these methods, but no performance bounds are shown.

3

A Reduction to Stochastic Convex Optimization

In this section, we describe our algorithm as a reduction from Markov decision problems to stochastic convex optimization. The main idea is to convert the ALP (3) into an unconstrained optimization over Θ by adding a function of the constraint violations to the objective, then run stochastic
gradient descent with unbiased estimated of the gradient.
For a positive constant H, form the following convex cost function by adding a multiple of the
total constraint violations to the objective of the LP (3):
c(θ) = ℓ⊤ (µ0 + Φθ) + H k[µ0 + Φθ]− k1 + H (P − B)⊤ (µ0 + Φθ)
⊤

⊤

1

= ℓ (µ0 + Φθ) + H k[µ0 + Φθ]− k1 + H (P − B) Φθ
1
X
X
⊤
= ℓ (µ0 + Φθ) + H
[µ0 (x, a) + Φ(x,a),: θ]− + H
(P − B)⊤
:,x′ Φθ .

(11)

x′

(x,a)

We justify using this surrogate loss as follows. Suppose we find a near optimal vector θb such that
b ≤ minθ∈Θ c(θ) + O(ǫ). We will prove
c(θ)
1. that

b−
[µ0 + Φθ]

1

and

b
(P − B)⊤ (µ0 + Φθ)

Lemma 2 in Section 3), and

b ≤ minθ∈Θ c(θ) + O(ǫ).
2. that ℓ⊤ (µ0 + Φθ)
9

1

are small and µ0 + Φθb is close to µθb (by

Input: Constant S > 0, number of rounds T , constant H.
Let ΠΘ be the Euclidean projection onto Θ.
Initialize θ1 = 0.
for t := 1, 2, . . . , T do
Sample (xt , at ) ∼ q1 and x′t ∼ q2 .
Compute subgradient estimate gt (12).
Update θt+1 = ΠΘ (θt − ηt gt ).
end forP
θbT = T1 Tt=1 θt .
Return policy πθbT .
Figure 1: The Stochastic Subgradient Method for Markov Decision Processes

As we will show, these two facts imply that with high probability, for any θ ∈ Θ,
µ⊤
ℓ ≤ µ⊤
θℓ+
θb

1
1
k[µ0 + Φθ]− k1 +
(P − B)⊤ (µ0 + Φθ)
ǫ
ǫ

1

+ O(ǫ) ,

which is to say that minimization of c(θ) solves the extended efficient large-scale ALP problem.
Unfortunately, calculating the gradients of c(θ) is O(XA). Instead, we construct unbiased
estimators and use stochastic gradient descent. Let T be the number of iterations of our algorithm.
Let q1 and q2 be distributions over the state-action and state space, respectively (we will later
discuss how to choose them). Let ((xt , at ))t=1...T be i.i.d. samples from q1 and (x′t )t=1...T be i.i.d.
samples from q2 . At round t, the algorithm estimates subgradient ∇c(θ) by
(P − B)⊤
Φ(xt ,at ),:
:,x′t Φ
I{µ0 (xt ,at )+Φ(xt ,at ),: θ<0} + H
s((P − B)⊤
gt (θ) = ℓ Φ − H
:,x′t Φθ).
q1 (xt , at )
q2 (x′t )
⊤

(12)

This estimate is fed to the projected subgradient method, which in turn generates a vector θt .
P
After T rounds, we average vectors (θt )t=1...T and obtain the final solution θbT = T θt /T . Vector
t=1

µ0 + ΦθbT defines a policy, which in turn defines a stationary distribution µθbT .2 The algorithm is
shown in Figure 1.
2

Recall that µθ is the stationary distribution of policy
πθ (a|x) = P

[µ0 (x, a) + Φ(x,a),: θ]+
.
′
′
a′ [µ0 (x, a ) + Φ(x,a ),: θ]+

With an abuse of notation, we use µθ to denote policy πθ as well.

10

3.1

Analysis

In this section, we state and prove our main result, Theorem 1. We begin with a discussion of
the assumptions we make then follow with the main theorem. We break the proof into two main
ingredients. First, we demonstrate that a good approximation to the surrogate loss gives a feature
vector that is almost a stationary distribution; this is Lemma 2. Second, we justify the use of
unbiased gradients in Theorem 3 and Lemma 5. The section concludes with the proof.
We make a mixing assumption on the MDP so that any policy quickly converges to its stationary
distribution.
Assumption A1 (Fast Mixing)
for all distributions d and

d′

For any policy π, there exists a constant τ (π) > 0 such that

over the state space, kdP π − d′ P π k1 ≤ e−1/τ (π) kd − d′ k1 .

Define
C1 =

max

(x,a)∈X ×A

Φ(x,a),:
,
q1 (x, a)

C2 = max
x∈X

(P − B)⊤
:,x Φ
.
q2 (x)

These constants appear in our performance bounds. So we would like to choose distributions q1
and q2 such that C1 and C2 are small. For example, if there is C ′ > 0 such that for any (x, a) and
i, Φ(x,a),i ≤ C ′ /(XA) and each column of P has only N non-zero elements, then we can simply

choose q1 and q2 to be uniform distributions. Then it is easy to see that
Φ(x,a),:
≤ C′ ,
q1 (x, a)

(P − B)⊤
:,x Φ
≤ C ′ (N + A) .
q2 (x)

As another example, if Φ:,i are exponential distributions and feature values at neighboring states
are close to each other, then we can choose q1 and q2 to be appropriate exponential distributions so
that Φ(x,a),: /q1 (x, a) and (P − B)⊤
:,x Φ /q2 (x) are always bounded. Another example is when

⊤ Φ / B ⊤ Φ < C ′′3 and we have access to
there exists a constant C ′′ > 0 such that for any x, P:,x
:,x
P
P
⊤ Φ and can sample
an efficient algorithm that computes Z1 = (x,a) Φ(x,a),: and Z2 = x B:,x

from q1 (x, a) =

Φ(x,a),: /Z1 and q2 (x) =

⊤ Φ /Z . In what follows, we assume that such
B:,x
2

distributions q1 and q2 are known.
We now state the main theorem.
Theorem 1. Consider an expanded efficient large-scale dual ALP problem. Suppose we apply the
stochastic subgradient method (shown in Figure 1) to the problem. Let ǫ ∈ (0, 1). Let T = 1/ǫ4 be
the number of rounds and H = 1/ǫ be the constraints multiplier in subgradient estimate (12). Let θbT
be the output of the stochastic subgradient method after T rounds and let the learning rate be η1 =
√
√
P
· · · = ηT = S/(G′ T ), where G′ = d + H(C1 + C2 ). Define V1 (θ) = (x,a) [µ0 (x, a) + Φ(x,a),: θ]−
3

This condition requires that columns of Φ are close to their one step look-ahead.

11

and V2 (θ) =

P

x′

(P − B)⊤
:,x′ (µ0 + Φθ) . Then, for any δ ∈ (0, 1), with probability at least 1 − δ,
ℓ
µ⊤
θbT

≤ min
θ∈Θ



µ⊤
θℓ


1
+ (V1 (θ) + V2 (θ)) + O(ǫ) ,
ǫ

(13)

where constants hidden in the big-O notation are polynomials in S, d, C1 , C2 , log(1/δ), V1 (θ),
V2 (θ), τ (µθ ), and τ (µθbT ).
Functions V1 and V2 are bounded by small constants for any set of normalized features: for any
θ ∈ Θ,
V1 (θ) ≤ kµ0 k1 + kΦθk1 ≤ 1 +
V2 (θ) ≤
≤

X

⊤
P:,x
′ (µ0 + Φθ) +

x′

X

P:,x′

x′

!⊤

X

(x,a)

X

Φ(x,a),: θ ≤ 1 + Sd ,
⊤
B:,x
′ (µ0 + Φθ)

x′

[µ0 + Φθ]+ +

X

B:,x′

x′

= (2)1⊤ [µ0 + Φθ]+

!⊤

[µ0 + Φθ]+

≤ (2)1⊤ |µ0 + Φθ|
= 2 + 2S .
Thus V1 and V2 can be very small given a carefully designed set of features. The output θbT is a
random vector as the algorithm is based on a stochastic convex optimization method. The above

theorem shows that with high probability the policy implied by this output is near optimal.
p
The optimal choice for ǫ is ǫ = V1 (θ∗ ) + V2 (θ∗ ), where θ∗ is the minimizer of RHS of (13)
and q
not known in advance. Once we obtain θbT , we can estimate V1 (θbT ) and V2 (θbT ) and use input
ǫ = V1 (θbT ) + V2 (θbT ) in a second run of the algorithm. This implies that the error bound scales
p
like O( V1 (θ∗ ) + V2 (θ∗ )).
The next lemma, providing the first ingredient of the proof, relates the amount of constraint
violation of a vector θ to resulting stationary distribution µθ .
Lemma 2. Let u ∈ RXA be a vector. Let N be the set of points (x, a) where u(x, a) < 0 and S be
complement of N . Assume
X
x,a

u(x, a) = 1,

X

(x,a)∈N

|u(x, a)| ≤ ǫ′ , u⊤ (P − B)

1

≤ ǫ′′ .

Vector [u]+ / k[u]+ k1 defines a policy, which in turn defines a stationary distribution µu . We have

that

kµu − uk1 ≤ τ (µu ) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′ .
12

Proof. Let f = u⊤ (P − B). From u⊤ (P − B)
X

(x,a)∈S

such that

P

x′

u(x, a)(P − B)(x,a),x′ = −

≤ ǫ′′ , we get that for any x′ ∈ X ,

1

X

(x,a)∈N

u(x, a)(P − B)(x,a),x′ + f (x′ )

|f (x′ )| ≤ ǫ′′ . Let h = [u]+ / k[u]+ k1 . Let H ′ = h⊤ (B − P ) 1 . We write
H′ =

X
x′

=

X

(x,a)∈S

1 X
1 + ǫ′ ′
x

h(x, a)(B − P )(x,a),x′
X

(x,a)∈S

u(x, a)(B − P )(x,a),x′

X
1 X
−
u(x, a)(B − P )(x,a),x′ + f (x′ )
1 + ǫ′ ′
x
(x,a)∈N


X
X
X
1 
−
u(x, a)(B − P )(x,a),x′ +
≤
f (x′ ) 
1 + ǫ′
x′
x′
(x,a)∈N


X
X
1  ′′
ǫ +
|u(x, a)| (B − P )(x,a),x′ 
≤
1 + ǫ′
′
(x,a)∈N x


′
′′
X
1  ′′
 ≤ 2ǫ + ǫ
ǫ
+
2
|u(x,
a)|
≤
1 + ǫ′
1 + ǫ′
=

(x,a)∈N

′

′′

≤ 2ǫ + ǫ .

Vector h is almost a stationary distribution in the sense that
h⊤ (B − P )
Let kwk1,S =

P

(x,a)∈S

1

≤ 2ǫ′ + ǫ′′ .

(14)

|w(x, a)|. First, we have that
kh − uk1 ≤ h −

u
1 + ǫ′

1

+ u−

u
1 + ǫ′

1,S

≤ 2ǫ′ .

Next we bound kµh − hk1 . Let ν0 = h be the initial state distribution. We will show that as we

run policy h (equivalently, policy µh ), the state distribution converges to µh and this vector is close

⊤
′
′′
h
to h. From (14), we have µ⊤
0 P = h B + v0 , where v0 is such that kv0 k1 ≤ 2ǫ + ǫ . Let M be a
h
X × (XA) matrix that encodes policy h, M(i,(i−1)A+1)
-(i,iA) = h(·|xi ). Other entries of this matrix

13

are zero. We get that
h⊤ P M h = (h⊤ B + v0 )M h = h⊤ BM h + v0 M h = h⊤ + v0 M h ,
⊤
h
where we used the fact that h⊤ BM h = h⊤ . Let µ⊤
1 = h P M which is the state-action distribution

after running policy h for one step. Let v1 = v0 M h P = v0 P h and notice that as kv0 k1 ≤ 2ǫ′ + ǫ′′ ,
we also have that kv1 k1 = P h⊤ v0⊤

1

≤ kv0 k1 ≤ 2ǫ′ + ǫ′′ . Thus,

⊤
⊤
µ⊤
1 P = h P + v1 = h B + v0 + v1 .

By repeating this argument for k rounds, we get that
⊤
h
µ⊤
k = h + (v0 + v1 + · · · + vk−1 )M

and it is easy to see that
(v0 + v1 + · · · + vk−1 )M h

1

≤

k−1
X
i=0

kvi k1 ≤ k(2ǫ′ + ǫ′′ ).

Thus, kµk − hk1 ≤ k(2ǫ′ + ǫ′′ ). Now notice that µk is the state-action distribution after k rounds of
policy µh . Thus, by mixing assumption, kµk − µh k1 ≤ e−k/τ (h) . By the choice of k = τ (h) log(1/ǫ′ ),

we get that kµh − hk1 ≤ τ (h) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + ǫ′ .

The second ingredient is the validity of using estimates of the subgradients. We assume access
to estimates of the subgradient of a convex cost function. Error bounds can be obtained from
results in the stochastic convex optimization literature; the following theorem, a high-probability
version of Lemma 3.1 of Flaxman et al. (2005) for stochastic convex optimization, is sufficient.
Theorem 3. Let Z be a positive constant and Z be a bounded subset of Rd such that for any

z ∈ Z, kzk ≤ Z. Let (ft )t=1,2,...,T be a sequence of real-valued convex cost functions defined over

Z. Let z1 , z2 , . . . , zT ∈ Z be defined by z1 = 0 and zt+1 = ΠZ (zt − ηft′ ), where ΠZ is the Euclidean

projection onto Z, η > 0 is a learning rate, and f1′ , . . . , fT′ are unbiased subgradient estimates such
√
that E [ft′ |zt ] = ∇f (zt ) and kft′ k ≤ F for some F > 0. Then, for η = Z/(F T ), for any δ ∈ (0, 1),

with probability at least 1 − δ,

T
T
X
X
√
ft (z) ≤ ZF T +
ft (zt ) − min
t=1

z∈Z

t=1

Proof. Let z∗ = argminz∈Z

PT

t=1 ft (z)

s

(1 +

4Z 2 T )





1
Z 2T
2 log + d log 1 +
.
δ
d

(15)

and ηt = ft′ − ∇ft (zt ). Define function ht : Z → R by

ht (z) = ft (z) + zηt . Notice that ∇ht (zt ) = ∇ft (zt ) + ηt = ft′ . By Theorem 1 of Zinkevich (2003),
14

we get that
T
X
t=1

ht (zt ) −

T
X
t=1

ht (z∗ ) ≤

T
X
t=1

ht (zt ) − min
z∈Z

T
X
t=1

√
ht (z) ≤ ZF T .

Thus,
T
X
t=1

Let St =

Pt−1

s=1 (z∗ −zs )ηs ,

ft (zt ) −

T
X
t=1

T
X
√
ft (z∗ ) ≤ ZF T +
(z∗ − zt )ηt .
t=1

which is a self-normalized sum (de la Peña et al., 2009). By Corollary 3.8

and Lemma E.3 of Abbasi-Yadkori (2012), we get that for any δ ∈ (0, 1), with probability at least

1 − δ,

v
!
u


t−1
u
X
Z 2t
1
t
2
|St | ≤
(zt − z∗ )
2 log + d log 1 +
1+
δ
d
s=1
s



1
Z 2t
2
≤ (1 + 4Z t) 2 log + d log 1 +
.
δ
d

Thus,
T
X
t=1

ft (zt ) − min
z∈Z

T
X
t=1

√
ft (z) ≤ ZF T +

s

(1 +

4Z 2 T )





Z 2T
1
.
2 log + d log 1 +
δ
d

Remark 4. Let BT denote RHS of (15). If all cost functions are equal to f , then by convexity of
P
f and an application of Jensen’s inequality, we obtain that f ( Tt=1 zt /T ) − minz∈Z f (z) ≤ BT /T .
As the next lemma shows, Theorem 3 can be applied in our problem to optimize cost function

c.
Lemma 5. Under the same conditions as in Theorem 1, we have that for any δ ∈ (0, 1), with
probability at least 1 − δ,

SG′
c(θbT ) − min c(θ) ≤ √ +
θ∈Θ
T

s

1 + 4S 2 T
T2





S 2T
1
2 log + d log 1 +
.
δ
d

Proof. We prove the lemma by showing that conditions of Theorem 3 are satisfied.

(16)
We be-

gin by calculating the subgradient and bounding its norm with a quantity independent of the
number of states. If µ0 (x, a) + Φ(x,a),: θ ≥ 0, then ∇θ [µ0 (x, a) + Φ(x,a),: θ]− = 0. Otherwise,

15

∇θ [µ0 (x, a) + Φ(x,a),: θ]− = −Φ(x,a),: . Calculating,
∇θ c(θ) = ℓ⊤ Φ + H
= ℓ⊤ Φ − H

X

(x,a)

X

∇θ [µ0 (x, a) + Φ(x,a),: θ]− + H
Φ(x,a),: I{µ0 (x,a)+Φ(x,a),: θ<0} + H

X
x′

X
x′

(x,a)

∇θ (P − B)⊤
:,x′ Φθ

⊤
(P − B)⊤
:,x′ Φs((P − B):,x′ Φθ) ,

(17)

where s(z) = I{z>0} − I{z<0} is the sign function. Let ± denote the plus or minus sign (the exact

sign does not matter here). Let G = k∇θ c(θ)k. We have that

v
v
2



2
u
u
uX
uX
d
d
X
X
X
u
u


±
G ≤ Ht
Φ(x,a),i  .
(P − B)(x,a),x′ Φ(x,a),i  + ℓ⊤ Φ + H t
i=1

x′

i=1

(x,a)

(x,a)

Thus,
v
v

u
u d
uX
d
uX
X
√
u

G ≤ t (ℓ⊤ Φ:,i )2 + H d + H t
i=1

i=1

(x,a)

X
±
(P − B)(x,a),x′
x′

v

2
u
uX
d
X
√
√
√
u
2
Φ(x,a),i  = d(1 + 3H) ,
≤ d + H d + Ht
i=1

!

2

Φ(x,a),i 

(x,a)

where we used ℓ⊤ Φ:,i ≤ kℓk∞ kΦ:,i k1 ≤ 1.

Next, we show that norm of the subgradient estimate is bounded by G′ :
(P − B)⊤
√
Φ(xt ,at ),:
:,x′t Φ
d + H(C1 + C2 ) .
+H
≤
kgt k ≤ ℓ Φ + H
q1 (xt , at )
q2 (x′t )
⊤

Finally, we show that the subgradient estimate is unbiased:
E [gt (θ)] = ℓ⊤ Φ − H

X

q1 (x, a)

(x,a)

+H
= ℓ⊤ Φ − H

X

Φ(x,a),:
I
q1 (x, a) {µ0 (x,a)+Φ(x,a),: θ<0}

X
x′

′

q2 (x )

(P − B)⊤
:,x′ Φ
q2 (x′ )

s((P − B)⊤
:,x′ Φθ)

Φ(x,a),: I{µ0 (x,a)+Φ(x,a),: θ<0} + H

X
⊤
(P − B)⊤
:,x′ Φs((P − B):,x′ Φθ)
x′

(x,a)

= ∇θ c(θ) .
The result then follows from Theorem 3 and Remark 4.

16

With both ingredients in place, we can prove our main result.
Proof of Theorem 1. Let bT be the RHS of (16). Equation (16) implies that with high probability
for any θ ∈ Θ,
ℓ⊤ (µ0 + ΦθbT ) + H V1 (θbT ) + H V2 (θbT ) ≤ ℓ⊤ (µ0 + Φθ) + H V1 (θ) + H V2 (θ) + bT .

(18)

From (18), we get that

1
def
V1 (θbT ) ≤
(2(1 + S) + H V1 (θ) + H V2 (θ) + bT ) = ǫ′ ,
H
1
def
V2 (θbT ) ≤
(2(1 + S) + H V1 (θ) + H V2 (θ) + bT ) = ǫ′′ .
H

(19)
(20)

Inequalities (19) and (20) and Lemma 2 give the following bound:

µ⊤
ℓ − (µ0 + ΦθbT )⊤ ℓ ≤ τ (µθbT ) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′ .
θb
T

(21)

From (18) we also have

ℓ⊤ (µ0 + ΦθbT ) ≤ ℓ⊤ (µ0 + Φθ) + H V1 (θ) + H V2 (θ) + bT ,

which, together with (21) and Lemma 2, gives the final result:

µ⊤
ℓ ≤ ℓ⊤ (µ0 + Φθ) + H V1 (θ) + H V2 (θ) + bT + τ (µθbT ) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′
θb
T

′
′
′′
′
≤ µ⊤
θ ℓ + H V1 (θ) + H V2 (θ) + bT + τ (µθbT ) log(1/ǫ )(2ǫ + ǫ ) + 3ǫ

+ τ (µθ ) log(1/V1 (θ))(2V1 (θ) + V2 (θ)) + 3V1 (θ) .
√
Recall that bT = O(H/ T ). Because H = 1/ǫ and T = 1/ǫ4 , we get that with high probability,
1
⊤
for any θ ∈ Θ, µ⊤
b ℓ ≤ µθ ℓ + ǫ (V1 (θ) + V2 (θ)) + O(ǫ).
θT

Let’s compare Theorem 1 with results of de Farias and Van Roy (2006). Their approach is to
relate the original MDP to a perturbed version4 and then analyze the corresponding ALP. (See
Section 2 for more details.) Let Ψ be a feature matrix that is used to estimate value functions.
Recall that λ∗ is the average loss of the optimal policy and λw is the average loss of the greedy
policy with respect to value function Ψw. Let h∗γ be the differential value function when the
restart probability in the perturbed MDP is 1 − γ. For vector v and positive vector u, define the
4

In a perturbed MDP, the state process restarts with a certain probability to a restart distribution. Such perturbed
MDPs are closely related to discounted MDPs.

17

weighted maximum norm kvk∞,u = maxx u(x) |v(x)|. de Farias and Van Roy (2006) prove that for

appropriate constants C, C ′ > 0 and weight vector u,
λw ∗ − λ∗ ≤

C
min h∗γ − Ψw
1−γ w

∞,u

+ C ′ (1 − γ) .

(22)

This bound has similarities to bound (13): tightness of both bounds depends on the quality of feature vectors in representing the relevant quantities (stationary distributions in (13) and value functions in (22)). Once again, we emphasize that the algorithm proposed by de Farias and Van Roy
(2006) is computationally expensive and requires access to a distribution that depends on optimal
policy.

4

Sampling Constraints

In this section we describe our second algorithm for average cost MDP problems. Using the results on polytope constraint sampling (de Farias and Van Roy, 2004, Calafiore and Campi, 2005,
Campi and Garatti, 2008), we reduce approximate the solution to the dual ALP with the solution
to a smaller, sampled LP. Basically, de Farias and Van Roy (2004) claim that given a set of affine
constraints in Rd and some measure q over these constraints, if we sample k = O(d log(1/δ)/ǫ)
constraints, then with probability at least 1 − δ, any point that satisfies all of these k sampled

constraints also satisfies 1 − ǫ of the original set of constraints under measure q. This result is

independent of the number of original constraints.

Let L be a family of affine constraints indexed by i: constraint i is satisfied at point w ∈ Rd
if a⊤
i w + bi ≥ 0. Let I be the family of constraints by selecting k random constraints in L with

respect to measure q.

Theorem 6 (de Farias and Van Roy (2004)). Assume there exists a vector that satisfies all con
2
straints in L. For any δ and ǫ, if we take m ≥ 4ǫ d log 12
ǫ + log δ , then, with probability 1 − δ, a
set I of m i.i.d. random variables drawn from L with respect to distribution q satisfies
sup
{w:∀i∈I,a⊤
i w+bi ≥0}

q({j : a⊤
j w + bj < 0}) ≤ ǫ .

Our algorithm takes the following inputs: a positive constant S, a stationary distribution µ0 ,
a set Θ = {θ : θ ⊤ Φ⊤ 1 = 1 − µ⊤
0 1, kθk ≤ S}, a distribution q1 over the state-action space, a
distribution q2 over the state space, and constraint violation functions v1 : X × A → [−1, 0] and

v2 : X → [0, 1]. We will consider two families of constraints:

L1 = {µ0 (x, a) + Φ(x,a),: θ ≥ v1 (x, a) | (x, a) ∈ X × A} ,
n
o[n
o
⊤
L2 = (P − B)⊤
(µ
+
Φθ)
≤
v
(x)
|
x
∈
X
(P
−
B)
(µ
+
Φθ)
≥
−v
(x)
|
x
∈
X
.
2
2
:,x 0
:,x 0
18

Input: Constant S > 0, stationary distribution µ0 , distributions q1
and q2 , constraint violation functions v1 and v2 , number of samples
k1 and k2 .
For i = 1, 2, let Ii be ki constraints sampled from Li under distribution
qi .
Let I be the set of vectors that satisfy all constraints in I1 and I2 .
Let θe be the solution to LP:
min ℓ⊤ (µ0 + Φθ) ,

(24)

θ∈Θ

s.t.

θ ∈ I, θ ∈ Θ .

Return policy µθe.
Figure 2: The Constraint Sampling Method for Markov Decision Processes

Let θ∗ be the solution of
min ℓ⊤ (µ0 + Φθ) ,

(23)

θ∈Θ

s.t.

θ ∈ L1 , θ ∈ L2 , θ ∈ Θ .

The constraint sampling algorithm is shown in Figure 2. We refer to (24) as the sampled ALP,
while we refer to (3) as the full ALP.

4.1

Analysis

We require Assumption A1 as well as:
Assumption A2 (Feasibility)

There exists a vector that satisfies all constraints L1 and L2 .

Validity of this assumption depends on the choice of functions v1 and v2 . Larger functions ensure
that this assumption is satisfied, but as we show, this leads to larger error.
The next two lemmas apply theorem 6 to constraints L1 and L2 , respectively.


2
Lemma 7. Let δ1 ∈ (0, 1) and ǫ1 ∈ (0, 1). If we choose k1 = ǫ41 d log 12
+
log
ǫ1
δ1 , then with
P
e − ≤ SC1 ǫ1 + kv1 k .
probability at least 1 − δ1 , (x,a) [µ0 (x, a) + Φ(x,a),: θ]
1

Proof. Applying theorem 6, we have that w.p. 1 − δ1 , q1 (µ0 (x, a) + Φ(x,a),: θe ≥ v1 (x, a)) ≥ 1 − ǫ1 ,

and thus

X

q1 (x, a)I{µ0 (x,a)+Φ

e

(x,a),: θ<v1 (x,a)}

(x,a)

19

≤ ǫ1 .

Let L =

P

(x,a)

e − . With probability 1 − δ1 ,
[µ0 (x, a) + Φ(x,a),: θ]
L=

X

e− I
[µ0 (x, a) + Φ(x,a),: θ]
{µ0 (x,a)+Φ

(x,a)

+

X

(x,a)

≤
≤
≤

X

e− I
[µ0 (x, a) + Φ(x,a),: θ]
{µ0 (x,a)+Φ

Φ(x,a),: θe I{µ0 (x,a)+Φ

(x,a)

X

Φ(x,a),:

(x,a)

X

e

(x,a),: θ≤v1 (x,a)}

e

(x,a),: θ≤v1 (x,a)}

θe I{µ0 (x,a)+Φ

SC1 q1 (x, a)I{µ0 (x,a)+Φ

e

(x,a),: θ>v1 (x,a)}

+ kv1 k1

e

(x,a),: θ≤v1 (x,a)}

e

(x,a),: θ≤v1 (x,a)}

(x,a)

+ kv1 k1

+ kv1 k1

≤ SC1 ǫ1 + kv1 k1 .

Lemma 8. Let δ2 ∈ (0, 1) and ǫ2 ∈ (0, 1). If we choose k2 =
probability at least 1 − δ2 , (P − B)⊤ Φθe

1

≤ SC2 ǫ2 + kv2 k1 .

Proof. Applying theorem 6, we have that q2
X
x

Let L′ =

P

x



4
ǫ2


d log

12
ǫ2


e ≤ v2 (x) ≥ 1 − ǫ2 . This yields
Φ
θ
(P − B)⊤
:,x

q2 (x)I{|(P −B)⊤

e|≥v2 (x)}

:,x Φθ

e
(P − B)⊤
:,x Φθ . Thus, with probability 1 − δ2 ,
X

≤ ǫ2 .

e
(P − B)⊤
e
:,x Φθ I{|(P −B)⊤
:,x Φθ |>v2 (x)}
x
X
e
(P − B)⊤
+
e
:,x Φθ I{|(P −B)⊤
:,x Φθ |≤v2 (x)}
x
X
θe I{|(P −B)⊤ Φθe|>v2 (x)} + kv2 k1
≤
(P − B)⊤
:,x Φ
:,x
x
X
≤
SC2 q2 (x)I{|(P −B)⊤ Φθe|>v2 (x)} + kv2 k1
:,x

L′ =


+ log δ22 , then with

x

≤ SC2 ǫ2 + kv2 k1 ,
where the last step follows from (25).

20

(25)

a1
d4

µ1

d1

µ2

d2

µ4

d2

µ3

a3

server1

server2

Figure 3: The 4D queueing network. Customers arrive at queue µ1 or µ3 then are referred to queue
µ2 or µ4 , respectively. Server 1 can either process queue 1 or 4, and server 2 can only process queue
2 or 3.

We are ready to prove the main result of this section. Let θe denote the solution of the sampled

ALP, θ∗ denote the solution of the full ALP (23), and µθe be the stationary distribution of the
solution policy. Our goal is to compare ℓ⊤ µθe and ℓ⊤ µθ∗ .

Theorem 9. Let ǫ ∈ (0, 1) and δ ∈ (0, 1). Let ǫ′ = SC1 ǫ + kv1 k1 and ǫ′′ = SC2 ǫ + kv2 k1 . If we


4
4
4
12
sample constraints with k1 = 4ǫ d log 12
ǫ + log δ and k2 = ǫ d log ǫ + log δ , then, with probability
1 − δ,
ℓ⊤ µθe ≤ ℓ⊤ µθ∗ + τ (µθe) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′
+ τ (µ∗ ) log(1/ kv1 k)(2 kv1 k + kv2 k) + 3 kv1 k .
Proof. Let δ1 = δ2 = δ/2. By Lemmas 7 and 8, w.p. 1 − δ,
e
(P − B)⊤ (µ0 + Φθ)

1

≤ ǫ′′ . Then by Lemma 2,

P

(x,a)

e − ≤ ǫ′ and
[µ0 (x, a) + Φ(x,a),: θ]

e ≤ τ (µ e) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′ .
ℓ⊤ µθe − ℓ⊤ (µ0 + Φθ)
θ

e ≤ ℓ⊤ (µ0 + Φθ∗ ). Thus,
We also have that ℓ⊤ (µ0 + Φθ)

ℓ⊤ µθe ≤ ℓ⊤ (µ0 + Φθ∗ ) + τ (µθe) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′
≤ ℓ⊤ µθ∗ + τ (µθe) log(1/ǫ′ )(2ǫ′ + ǫ′′ ) + 3ǫ′

+ τ (µθ∗ ) log(1/ kv1 k)(2 kv1 k + kv2 k) + 3 kv1 k ,
where the last step follows from Lemma 2.

21

5

Experiments

In this section, we apply both algorithms to the four-dimensional discrete-time queueing network
illustrated in Figure 5. This network has a relatively long history; see, e.g. Rybko and Stolyar
(1992) and more recently de Farias and Van Roy (2003a) (c.f. section 6.2). There are four queues,
µ1 , . . . , µ4 , each with state 0, . . . , B. Since the cardinality of the state space is X = (1 + B)4 , even
a modest B results in huge state-spaces. For time t, let Xt ∈ X be the state and si,t ∈ {0, 1},

i = 1, 2, 3, 3 denote whether queue i is being served. Server 1 only serves queue 1 or 4, server 2
only serves queue 2 or 3, and neither server can idle. Thus, s1,t + s4,t = 1 and s2,t + s3,t = 1. The
dynamics are as follows. At each time t, the following random variables are sampled independently:
A1,t ∼ Bernoulli(a1 ), A3,t ∼ Bernoulli(a3 ), and Di,t ∼ Bernoulli(di ∗ si,t ) for i = 1, 2, 3, 4. Using
e1 , . . . , e4 to denote the standard basis vectors, the dynamics are:
′
Xt+1
=Xt + A1,t e1 + A3,t e3

+ D1,t (e2 − e1 ) − D2,t e2
+ D3,t (e4 − e3 ) − D4,t e4 ,
′ )) (i.e. all four states are thresholded from below by 0 and above
and Xt+1 = max(0, min((B), Xt+1

by B). The loss function is the total queue size: ℓ(Xt ) = ||Xt ||1 . We compared our method against

two common heuristics. In the first, denoted LONGER, each server operates on the queue that is
longer with ties broken uniformly at random (e.g. if queue 1 and 4 had the same size, they are
equally likely to be served). In the second, denoted LBFS (last buffer first served), the downstream
queues always have priority (server 1 will serve queue 4 unless it has length 0, and server 2 will serve
queue 2 unless it has length 0). These heuristics are common and have been used an benchmarks
for queueing networks (e.g. de Farias and Van Roy (2003a)).
We used a1 = a3 = .08, d1 = d2 = .12, and d3 = d4 = .28, and buffer sizes B1 = B4 = 38, B2 =
B3 = 25 as the parameters of the network.. The asymmetric size was chosen because server 1 is the
bottleneck and tend to have has longer queues. The first two features are the stationary distributions
corresponding to two heuristics. We also included two types of non-stationary-distribution features.
For every interval (0, 5], (6, 10], . . . , (45, 50] and action A, we added a feature ψ with ϕ(x, a) = 1 if
ℓ(x, a) is in the interval and a = A. To define the second type, consider the three intervals I1 =
[0, 10], I2 = [11, 20], and I3 = [21, 25]. For every 4-tuple of intervals (J1 , J2 , J3 , J4 ) ∈ {I1 , I2 , I3 }4

and action A, we created a feature ψ with ψ(x, a) = 1 only if xi ∈ Ji and a = A. Every feature was

normalized to sum to 1. In total, we had 372 features which is about a 104 reduction in dimension
from the original problem.

22

loss of running average

total constraint violations

average loss of the running average policy

0.42

0.395

0.4

0.39

−2.3

10

0.385

0.38

0.38
0.36

−2.4

10

0.375

0.34
0.37
0.32

0.365

−2.5

10
0.3

0

1

2

3

4

0

1

2

4

3

4

0.36

0

1

2

3

4

x 10

x 10

4
4

x 10

Figure 4: The left plot is of the linear objective of the running average, i.e. ℓ⊤ Φθbt . The center
plot is the sum of the two constraint violations of θbt , and the right plot is ℓ⊤ µ̃θbt (the average loss of
the derived policy). The two horizontal lines correspond to the loss of the two heuristics, LONGER
and LBFS.

5.1

Stochastic Gradient Descent

We ran our stochastic gradient descent algorithm with I = 1000 sampled constraints and constraint
gain H = 2. Our learning rate began at 10−4 and halved every 2000 iterations. The results of
our algorithm are plotted in Figure 5.1, where θbt denotes the running average of θt . The left plot

is of the LP objective, ℓ⊤ (µ0 + Φθbt ). The middle plot is of the sum of the constraint violations,
[µ0 + Φθbt ]− + (P − B)⊤ Φθbt . Thus, c(θbt ) is a scaled sum of the first two plots. Finally, the
1

1

right plot is of the average losses, ℓ⊤ µθbt and the two horizontal lines correspond to the loss of the
two heuristics, LONGER and LBFS. The right plot demonstrates that, as predicted by our theory,
minimizing the surrogate loss c(θ) does lead to lower average losses.
All previous algorithms (including de Farias and Van Roy (2003a)) work with value functions,
while our algorithm works with stationary distributions. Due to this difference, we cannot use
the same feature vectors to make a direct comparison. The solution that we find in this different
approximating set is slightly worse than the solution of de Farias and Van Roy (2003a).

5.2

Constraint Sampling

For the constraint sampling algorithm, we sampled the simplex constraints uniformly with 10
different sample sizes: 508, 792, 1235, 1926, 3003, 4684, 7305, 11393, 17768, and 27712. Since
XA = 4.1 ∗ 106 , these sample sizes correspond to less that 1%. The stationary constraints were

sampled in the same proportion (i.e. A times fewer samples). Let a1 , . . . , aAN and b1 , . . . , bN be
the indices of the sampled simplex and stationary constraints, respectively. Explicitly, the sampled

23

LP is:
min(Φθ)⊤ ℓ ,

(26)

θ

s.t. (Φθ)⊤ 1 = 1, Φai ,; θ ≥ 0, ∀i = 1, . . . , AN,
Φθ ⊤ (P − B):,bi ≤ ǫs , ∀i = 1, . . . , N, kθk∞ ≤ M

(27)

where M and ǫ are necessary to ensure the LP always has a feasible and bounded solution. This
corresponds to setting v1 = 0 and v2 = ǫ. In particular, we used M = 3 and ǫ = 10−3 . Using
differenc values of ǫ did not have a large effect on the behavior of the algorithm.
For each sample size, we sample the constraints, solve the LP, then simulate the average loss of
the policy. We repeated this procedure 35 times for each sample size and plotted the mean with
error bars corresponding to the variance across each sample size in Figure 5.2. Note the log scale
on the x-axis. The best loss corresponds to 4684 sampled simplex constraints, or roughly 1%, and
is a marked improvement over the average loss found by the stochastic gradient descent method.
However, changing the sample size by a factor of 4 in either direction is enough to obliterate this
advantage.
average loss produced by the constraint sampling algorithm with variance bars
70
65
60

average loss

55
50
45
40
35
30
25

3

10

4

10
number of simplex constraints sampled

Figure 5: Average loss with variance error bars of the constraint sampling algorithm run with a
variety of sample sizes.
24

First, we notice that the mean average loss is not monotonic. If we use too few constraints, then
the sampled ALP does not reflect our original problem and we expect that the solution will make
poor policies. On the other hand, if we sample too many constraints, then the LP is too restrictive
and cannot adequately explore the feature space. To explain the increasing variance, recall that we
have three families of constraints: the simplex constraints, the stationarity constraints, and the box
constraints (i.e. |θ|∞ ≤ M ). Only the simplex and stationarity constraints are sampled. For the

small sample sizes, the majority of the active constraints are the box constraint so θ̃ (the minimizer

of the LP) is not very sensitive to the random sample. However, as the sample size grows, so does
the number of active simplex and stationarity constraints; hence, the random constraints affect θ̃
to a greater degree and the variance increases.

6

Conclusions

In this paper, we defined and solved the extended large-scale efficient ALP problem. We proved
that, under certain assumptions about the dynamics, the stochastic subgradient method produces
a policy with average loss competitive to all θ ∈ Θ, not just all θ producing a stationary distri-

bution. We demonstrated this algorithm on the Rybko-Stoylar four-dimensional queueing network

and recovered a policy better than two common heuristics and comparable to previous results on
ALPs de Farias and Van Roy (2003a). A future direction is to find other interesting regularity
conditions under which we can handle large-scale MDP problems. We also plan to conduct more
experiments with challenging large-scale problems.

7

Acknowledgements

We gratefully acknowledge the support of the NSF through grant CCF-1115788 and of the ARC
through an Australian Research Council Australian Laureate Fellowship (FL110100281).

